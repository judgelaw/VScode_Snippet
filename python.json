{
	// Place your snippets for python here. Each snippet is defined under a snippet name and has a prefix, body and 
	// description. The prefix is what is used to trigger the snippet and the body will be expanded and inserted. Possible variables are:
	// $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. Placeholders with the 
	// same ids are connected.
	// Example:
	// "Print to console": {
	// 	"prefix": "log",
	// 	"body": [
	// 		"console.log('$1');",
	// 		"$2"
	// 	],
	// 	"description": "Log output to console"
	// }


	"整数入力高速化": {
		"prefix": "import sys input",
		"body": [		
			"import sys",
			"input = sys.stdin.buffer.readline",
		],
		"description": "整数入力高速化"
	},

	"入力高速化": {
		"prefix": "import sys input",
		"body": [		
			"import sys",
			"input = lambda: sys.stdin.readline().rstrip()",
		],
		"description": "入力高速化"
	},
    
	"整数入力": {
		"prefix": "int(input())",
		"body": [
			"int(input())",
		],
		"description": "整数入力"
	},

	"空白区切り整数入力": {
		"prefix": "map(int,input().split())",
		"body": [
			"map(int,input().split())",
		],
		"description": "空白区切り整数入力"
	},

	"空白区切り文字列→リスト": {
		"prefix": "list(input().split())",
		"body": [
			"list(input().split())",
		],
		"description": "空白区切り文字列→リスト"
	},

	"空白区切り整数入力→リスト": {
		"prefix": "list(map(int, input().split()))",
		"body": [
			"list(map(int, input().split()))",
		],
		"description": "空白区切り整数入力→リスト"
	},

	"文字列→一字ずつリスト化": {
		"prefix": "list(input())",
		"body": [
			"list(input())",
		],
		"description": "文字列→一字ずつリスト化"
	},

	"数字列→一字ずつリスト化": {
		"prefix": "list(map(int,input()))",
		"body": [
			"list(map(int,input()))",
		],
		"description": "数字列→一字ずつリスト化"
	},

	"N行1列の文字列入力": {
		"prefix": "[input() for _ in range($1N)",
		"body": [
			"[input() for _ in range($1N)",
		],
		"description": "N行1列の文字列入力"
	},

	"N行1列の整数入力": {
		"prefix": "[int(input()) for _ in range($1N)",
		"body": [
			"[int(input()) for _ in range($1N)",
		],
		"description": "N行1列の整数入力"
	},

	"N行N列の文字列入力": {
		"prefix": "[input().split()",
		"body": [
			"[input().split() for l in range($1N)",
		],
		"description": "N行N列の文字列入力"
	},

	"N行N列の整数入力": {
		"prefix": "[list(map(int, input().split()))",
		"body": [
			"[list(map(int, input().split()))  for _ in range($1N)",
		],
		"description": "N行N列の整数入力"
	},

    "def make_vec(a,*n):": {
        "prefix": "def make_vec(a=0,*n):",
        "body": [
            "def make_vec(a,*n):",
            "    if len(n)==1:",
            "        t=type(a)",
            "        return [t(a) for _ in range(n[0])]",
            "    else:return [make_vec(a,*n[1:]) for _ in range(n[0])]",
        ],
        "description": "初期値aの多次元行列を生成"
    },	

    "class Vector_2D": {
        "prefix": "class Vector_2D",
        "body": [
            "class Vector_2D:",
            "",
            "    def __init__(self,r,c,a):",
            "        self.r=r",
            "        self.c=c",
            "        self.V=[a for _ in range(r*c+1)]",
            "",
            "    def get(self,i,j):",
            "        return self.V[self.c*i+j]",
            "",
            "    def write(self,i,j,a):",
            "        self.V[self.c*i+j]=a",
            "",
            "    def chmin(self,i,j,a):",
            "        self.V[self.c*i+j]=min(self.V[self.c*i+j],a)",
        ],
        "description": "2次元配列を1次元化する"
    },

    "chain.from_iterable": {
        "prefix": "chain.from_iterable",
        "body": [
            "from itertools import chain",
            "list(chain.from_iterable())",
        ],
        "description": "多次元配列を一次元に"
    },

    "cf": {
        "prefix": "cf",
        "body": [
            "def solve():",
            "    res=0",
            "",
            "",
            "    print(res)",
            "    return",
            "",
            "T=int(input())",
            "for _ in range(T):solve()",
        ],
        "description": "codeforces"
    },



	"GCJtemplate": {
		"prefix": "GCJ",
		"body": [
            "def solve(case):",
            "    res=0",
            "",
            "    print(\"Case #\"+str(case)+\":\",res)",
            "",
            "T=int(input())",
            "for i in range(1,T+1):solve(i)",
		],
		"description": "GCJtemplate"
	},

	"文字リスト→出力": {
		"prefix": "print(''.join(S))",
		"body": [
			"print(''.join($1S))",
		],
		"description": "文字リスト→出力"
	},

	"整数リスト→出力": {
		"prefix": "print(''.join(map(str,A)))",
		"body": [
			"print(''.join(map(str,$1A)))",
		],
		"description": "整数リスト→出力"
	},

	"整数リスト→空白出力": {
		"prefix": "print(' '.join(map(str,A))",
		"body": [
			"print(' '.join(map(str,$1A)))",
		],
		"description": "整数リスト→空白出力"
	},


	"整数リスト→改行出力": {
		"prefix": "print('\n'.join(map(str,S)))",
		"body": [
			"print('\n'.join(map(str,$1S)))",
		],
		"description": "整数リスト→改行出力"
	},

    "deb": {
        "prefix": "deb",
        "body": [
            "file=sys.stderr",
        ],
        "description": "デバッグ用コンソール出力オプション"
    },


	"for i in range(N):": {
		"prefix": "for i in range(N)",
		"body": [
			"for i in range($1N)",
		],
		"description": "0からN-1までのfor文"
	},

	"defaultdict as dd": {
		"prefix": "from collections import defaultdict as dd",
		"body": [
			"from collections import defaultdict as dd",
		],
		"description": "defaultdict"
	},	
	
	"入れ子dd": {
		"prefix": "dd(lambda:dd(int))",
		"body": [
			"dd(lambda:dd(int))",
		],
		"description": "入れ子dd"
	},	

    "無限dd": {
        "prefix": "recdd",
        "body": [
            "from collections import defaultdict as dd",
            "def recdd():",
            "    return dd(recdd)",
        ],
        "description": "無限defaultdict"
    },


	"dd初期値指定": {
		"prefix": "dd(lambda:-1)",
		"body": [
			"dd(lambda:-1)",
		],
		"description": "dd初期値指定"
	},	

	"itertools as itr": {
		"prefix": "import itertools as itr",
		"body": [
			"import itertools as itr",
		],
		"description": "itertools"
	},	

	"from copy import copy,deepcopy": {
		"prefix": "from copy import copy,deepcopy",
		"body": [
			"from copy import copy,deepcopy",
		],
		"description": "copy"
	},	


	"collections as col ": {
		"prefix": "import collections as col",
		"body": [
			"import collections as col",
		],
		"description": "collections"
	},	
	
	"functools": {
		"prefix": "import functools",
		"body": [
			"import functools",
		],
		"description": "functools"
	},	

	"from decimal import Decimal": {
		"prefix": "from decimal import Decimal",
		"body": [
			"from decimal import Decimal",
		],
		"description": "decimal"
	},	

	" from fractions import Fraction as F": {
        "prefix": " from fractions import Fraction as F",
        "body": [
            "from fractions import Fraction as F",
        ],
        "description": "分数モジュール"
    },


	"setrecursionlimit": {
		"prefix": "sys.setrecursionlimit(10**8)",
		"body": [
			"sys.setrecursionlimit(10**8)",
		],
		"description": "再帰上限設定"
	},	

	"deque": {
		"prefix": "from collections import deque",
		"body": [
			"from collections import deque",
		],
		"description": "deque"
	},	

	"bisect": {
		"prefix": "from bisect import bisect",
		"body": [
			"from bisect import bisect",
		],
		"description": "bisect"
	},	
	
	"heapq": {
		"prefix": "from heapq import heapify,heappop as hpop,heappush as hpush",
		"body": [
			"from heapq import heapify,heappop as hpop,heappush as hpush",
		],
		"description": "heapq"
	},	


	"numpy": {
		"prefix": "import numpy as np",
		"body": [
			"import numpy as np",
		],
		"description": "numpy"
	},	

    "PythonControl": {
        "prefix": "import control as ct",
        "body": [
            "import control as ct",
        ],
        "description": "PythonControl"
    },


    "pyplot": {
        "prefix": "plt",
        "body": [
            "import matplotlib.pyplot as plt",
            "",
        ],
        "description": "グラフ表示"
    },


	"numba": {
		"prefix": "from numba import njit,i8",
		"body": [
			"from numba import njit,i8",
		],
		"description": "numba"
	},	

	"njit": {
		"prefix": "@njit((),cache=True)",
		"body": [
			"@njit(($1),cache=True)",
		],
		"description": "njit"
	},

    "Slide_Minimum": {
        "prefix": "Slide_Minimum",
        "body": [
            "# 配列Aの連続K個中の最小値を求める",
            "def Slide_Minimum(A,K):",
            "    ret=[]",
            "    q=deque()",
            "",
            "    N=len(A)",
            "    for i in range(N):",
            "        a=A[i]",
            "        while q and q[0]<=i-K:q.popleft()",
            "        while q and A[q[-1]]>a:q.pop()",
            "        q.append(i)",
            "        ret.append(A[q[0]])",
            "",
            "    return ret",
        ],
        "description": "スライド最小値"
    },

    "Slide_Maximum": {
        "prefix": "Slide_Maximum",
        "body": [
            "# 配列Aの連続K個中の最大を求める",
            "def Slide_Maximum(A,K):",
            "    ret=[]",
            "    q=deque()",
            "",
            "    N=len(A)",
            "    for i in range(N):",
            "        a=A[i]",
            "        while q and q[0]<=i-K:q.popleft()",
            "        while q and A[q[-1]]<a:q.pop()",
            "        q.append(i)",
            "        ret.append(A[q[0]])",
            "",
            "    return ret",
        ],
        "description": "スライド最大値"
    },


    "sortedcontainers": {
        "prefix": "SortedSet",
        "body": [
            "from sortedcontainers import SortedSet",
        ],
        "description": "sortedcontainersのSortedset"
    },



    "SortedSet": {
        "prefix": "SortedSet",
        "body": [
            "# https://github.com/tatyam-prime/SortedSet/blob/main/SortedSet.py",
            "import math",
            "from bisect import bisect_left, bisect_right",
            "from typing import Generic, Iterable, Iterator, TypeVar, Union, List",
            "T = TypeVar('T')",
            "",
            "class SortedSet(Generic[T]):",
            "    BUCKET_RATIO = 50",
            "    REBUILD_RATIO = 170",
            "",
            "    def _build(self, a=None) -> None:",
            "        \"Evenly divide `a` into buckets.\"",
            "        if a is None: a = list(self)",
            "        size = self.size = len(a)",
            "        bucket_size = int(math.ceil(math.sqrt(size / self.BUCKET_RATIO)))",
            "        self.a = [a[size * i // bucket_size : size * (i + 1) // bucket_size] for i in range(bucket_size)]",
            "    ",
            "    def __init__(self, a: Iterable[T] = []) -> None:",
            "        \"Make a new SortedSet from iterable. / O(N) if sorted and unique / O(N log N)\"",
            "        a = list(a)",
            "        if not all(a[i] < a[i + 1] for i in range(len(a) - 1)):",
            "            a = sorted(set(a))",
            "        self._build(a)",
            "",
            "    def __iter__(self) -> Iterator[T]:",
            "        for i in self.a:",
            "            for j in i: yield j",
            "",
            "    def __reversed__(self) -> Iterator[T]:",
            "        for i in reversed(self.a):",
            "            for j in reversed(i): yield j",
            "    ",
            "    def __len__(self) -> int:",
            "        return self.size",
            "    ",
            "    def __repr__(self) -> str:",
            "        return \"SortedSet\" + str(self.a)",
            "    ",
            "    def __str__(self) -> str:",
            "        s = str(list(self))",
            "        return \"{\" + s[1 : len(s) - 1] + \"}\"",
            "",
            "    def _find_bucket(self, x: T) -> List[T]:",
            "        \"Find the bucket which should contain x. self must not be empty.\"",
            "        for a in self.a:",
            "            if x <= a[-1]: return a",
            "        return a",
            "",
            "    def __contains__(self, x: T) -> bool:",
            "        if self.size == 0: return False",
            "        a = self._find_bucket(x)",
            "        i = bisect_left(a, x)",
            "        return i != len(a) and a[i] == x",
            "",
            "    def add(self, x: T) -> bool:",
            "        \"Add an element and return True if added. / O(√N)\"",
            "        if self.size == 0:",
            "            self.a = [[x]]",
            "            self.size = 1",
            "            return True",
            "        a = self._find_bucket(x)",
            "        i = bisect_left(a, x)",
            "        if i != len(a) and a[i] == x: return False",
            "        a.insert(i, x)",
            "        self.size += 1",
            "        if len(a) > len(self.a) * self.REBUILD_RATIO:",
            "            self._build()",
            "        return True",
            "",
            "    def discard(self, x: T) -> bool:",
            "        \"Remove an element and return True if removed. / O(√N)\"",
            "        if self.size == 0: return False",
            "        a = self._find_bucket(x)",
            "        i = bisect_left(a, x)",
            "        if i == len(a) or a[i] != x: return False",
            "        a.pop(i)",
            "        self.size -= 1",
            "        if len(a) == 0: self._build()",
            "        return True",
            "    ",
            "    def lt(self, x: T) -> Union[T, None]:",
            "        \"Find the largest element < x, or None if it doesn't exist.\"",
            "        for a in reversed(self.a):",
            "            if a[0] < x:",
            "                return a[bisect_left(a, x) - 1]",
            "",
            "    def le(self, x: T) -> Union[T, None]:",
            "        \"Find the largest element <= x, or None if it doesn't exist.\"",
            "        for a in reversed(self.a):",
            "            if a[0] <= x:",
            "                return a[bisect_right(a, x) - 1]",
            "",
            "    def gt(self, x: T) -> Union[T, None]:",
            "        \"Find the smallest element > x, or None if it doesn't exist.\"",
            "        for a in self.a:",
            "            if a[-1] > x:",
            "                return a[bisect_right(a, x)]",
            "",
            "    def ge(self, x: T) -> Union[T, None]:",
            "        \"Find the smallest element >= x, or None if it doesn't exist.\"",
            "        for a in self.a:",
            "            if a[-1] >= x:",
            "                return a[bisect_left(a, x)]",
            "    ",
            "    def __getitem__(self, x: int) -> T:",
            "        \"Return the x-th element, or IndexError if it doesn't exist.\"",
            "        if x < 0: x += self.size",
            "        if x < 0: raise IndexError",
            "        for a in self.a:",
            "            if x < len(a): return a[x]",
            "            x -= len(a)",
            "        raise IndexError",
            "    ",
            "    def index(self, x: T) -> int:",
            "        \"Count the number of elements < x.\"",
            "        ans = 0",
            "        for a in self.a:",
            "            if a[-1] >= x:",
            "                return ans + bisect_left(a, x)",
            "            ans += len(a)",
            "        return ans",
            "",
            "    def index_right(self, x: T) -> int:",
            "        \"Count the number of elements <= x.\"",
            "        ans = 0",
            "        for a in self.a:",
            "            if a[-1] > x:",
            "                return ans + bisect_right(a, x)",
            "            ans += len(a)",
            "        return ans",
        ],
        "description": ""
    },

    "SortedMultiset": {
        "prefix": "SortedMultiset",
        "body": [
            "# https://github.com/tatyam-prime/SortedSet/blob/main/SortedMultiset.py",
            "import math",
            "from bisect import bisect_left, bisect_right, insort",
            "from typing import Generic, Iterable, Iterator, TypeVar, Union, List",
            "T = TypeVar('T')",
            "",
            "class SortedMultiset(Generic[T]):",
            "    BUCKET_RATIO = 50",
            "    REBUILD_RATIO = 170",
            "",
            "    def _build(self, a=None) -> None:",
            "        \"Evenly divide `a` into buckets.\"",
            "        if a is None: a = list(self)",
            "        size = self.size = len(a)",
            "        bucket_size = int(math.ceil(math.sqrt(size / self.BUCKET_RATIO)))",
            "        self.a = [a[size * i // bucket_size : size * (i + 1) // bucket_size] for i in range(bucket_size)]",
            "    ",
            "    def __init__(self, a: Iterable[T] = []) -> None:",
            "        \"Make a new SortedMultiset from iterable. / O(N) if sorted / O(N log N)\"",
            "        a = list(a)",
            "        if not all(a[i] <= a[i + 1] for i in range(len(a) - 1)):",
            "            a = sorted(a)",
            "        self._build(a)",
            "",
            "    def __iter__(self) -> Iterator[T]:",
            "        for i in self.a:",
            "            for j in i: yield j",
            "",
            "    def __reversed__(self) -> Iterator[T]:",
            "        for i in reversed(self.a):",
            "            for j in reversed(i): yield j",
            "    ",
            "    def __len__(self) -> int:",
            "        return self.size",
            "    ",
            "    def __repr__(self) -> str:",
            "        return \"SortedMultiset\" + str(self.a)",
            "    ",
            "    def __str__(self) -> str:",
            "        s = str(list(self))",
            "        return \"{\" + s[1 : len(s) - 1] + \"}\"",
            "",
            "    def _find_bucket(self, x: T) -> List[T]:",
            "        \"Find the bucket which should contain x. self must not be empty.\"",
            "        for a in self.a:",
            "            if x <= a[-1]: return a",
            "        return a",
            "",
            "    def __contains__(self, x: T) -> bool:",
            "        if self.size == 0: return False",
            "        a = self._find_bucket(x)",
            "        i = bisect_left(a, x)",
            "        return i != len(a) and a[i] == x",
            "",
            "    def count(self, x: T) -> int:",
            "        \"Count the number of x.\"",
            "        return self.index_right(x) - self.index(x)",
            "",
            "    def add(self, x: T) -> None:",
            "        \"Add an element. / O(√N)\"",
            "        if self.size == 0:",
            "            self.a = [[x]]",
            "            self.size = 1",
            "            return",
            "        a = self._find_bucket(x)",
            "        insort(a, x)",
            "        self.size += 1",
            "        if len(a) > len(self.a) * self.REBUILD_RATIO:",
            "            self._build()",
            "",
            "    def discard(self, x: T) -> bool:",
            "        \"Remove an element and return True if removed. / O(√N)\"",
            "        if self.size == 0: return False",
            "        a = self._find_bucket(x)",
            "        i = bisect_left(a, x)",
            "        if i == len(a) or a[i] != x: return False",
            "        a.pop(i)",
            "        self.size -= 1",
            "        if len(a) == 0: self._build()",
            "        return True",
            "",
            "    def lt(self, x: T) -> Union[T, None]:",
            "        \"Find the largest element < x, or None if it doesn't exist.\"",
            "        for a in reversed(self.a):",
            "            if a[0] < x:",
            "                return a[bisect_left(a, x) - 1]",
            "",
            "    def le(self, x: T) -> Union[T, None]:",
            "        \"Find the largest element <= x, or None if it doesn't exist.\"",
            "        for a in reversed(self.a):",
            "            if a[0] <= x:",
            "                return a[bisect_right(a, x) - 1]",
            "",
            "    def gt(self, x: T) -> Union[T, None]:",
            "        \"Find the smallest element > x, or None if it doesn't exist.\"",
            "        for a in self.a:",
            "            if a[-1] > x:",
            "                return a[bisect_right(a, x)]",
            "",
            "    def ge(self, x: T) -> Union[T, None]:",
            "        \"Find the smallest element >= x, or None if it doesn't exist.\"",
            "        for a in self.a:",
            "            if a[-1] >= x:",
            "                return a[bisect_left(a, x)]",
            "    ",
            "    def __getitem__(self, x: int) -> T:",
            "        \"Return the x-th element, or IndexError if it doesn't exist.\"",
            "        if x < 0: x += self.size",
            "        if x < 0: raise IndexError",
            "        for a in self.a:",
            "            if x < len(a): return a[x]",
            "            x -= len(a)",
            "        raise IndexError",
            "",
            "    def index(self, x: T) -> int:",
            "        \"Count the number of elements < x.\"",
            "        ans = 0",
            "        for a in self.a:",
            "            if a[-1] >= x:",
            "                return ans + bisect_left(a, x)",
            "            ans += len(a)",
            "        return ans",
            "",
            "    def index_right(self, x: T) -> int:",
            "        \"Count the number of elements <= x.\"",
            "        ans = 0",
            "        for a in self.a:",
            "            if a[-1] > x:",
            "                return ans + bisect_right(a, x)",
            "            ans += len(a)",
            "        return ans",
        ],
        "description": "SortedMultiset"
    },

    "class LargeHeapq:": {
        "prefix": "class LargeHeapq:",
        "body": [
            "from heapq import heapify,heappop as hpop,heappush as hpush",
            "",
            "",
            "class LargeHeapq:",
            "    def __init__(self):self.q=[]",
            "    def push(self,i):",
            "        if type(i)==int:hpush(self.q,-i)",
            "        else:",
            "            v=-i[0]",
            "            hpush(self.q,(v,*i[1:]))",
            "    def pop(self):",
            "        if type(self.q[0])==int:return -hpop(self.q)",
            "        else:",
            "            d=hpop(self.q)",
            "            v=-d[0]",
            "            return -v,*d[1:]",
            "    def top(self):return -self.q[0]",
            "    def len(self):return len(self.q)",
        ],
        "description": ""
    },


    "class Double_Ended_Priority_Queue:": {
        "prefix": "class Double_Ended_Priority_Queue:",
        "body": [
            "class Double_Ended_Priority_Queue:",
            "",
            "    def __init__(self,A=[]):",
            "",
            "        self.S=[]",
            "        self.L=[]",
            "",
            "        self.D=dd(int)",
            "",
            "        for a in A:",
            "            hpush(self.S,a)",
            "            hpush(self.L,~a)",
            "            self.D[a]+=1",
            "",
            "    def push(self,v):",
            "",
            "        hpush(self.S,v)",
            "        hpush(self.L,~v)",
            "        self.D[v]+=1",
            "",
            "    def max_pop(self):",
            "",
            "        ret=~hpop(self.L)",
            "        while self.D[ret]==0:ret=~hpop(self.L)",
            "",
            "        self.D[ret]-=1",
            "        return ret",
            "    ",
            "    def min_pop(self):",
            "",
            "        ret=hpop(self.S)",
            "        while self.D[ret]==0:ret=hpop(self.S)",
            "",
            "        self.D[ret]-=1",
            "        return ret",
            "",
            "    def max_val(self):return ~self.L[0]",
            "",
            "    def min_val(self):return self.S[0]",
        ],
        "description": "最大最小を取り出せる優先度付きキュー"
    },

    "class Modint": {
        "prefix": "class Modint",
        "body": [

            "class Modint:",
            "    \"\"\"ミュータブルなModintクラス\"\"\"",
            "    __slots__ = (\"value\",)",
            "    MOD = 1000000007  # デフォルトの法",
            "",
            "    def __init__(self, value):",
            "        self.value = int(value) % self.MOD",
            "",
            "    # ---- 文字表示 ----",
            "    def __repr__(self):",
            "        return str(self.value)",
            "",
            "    def __int__(self):",
            "        return self.value",
            "",
            "    # ---- 加減乗除 ----",
            "    def __add__(self, other):",
            "        return Modint(self.value + int(other))",
            "",
            "    def __sub__(self, other):",
            "        return Modint(self.value - int(other))",
            "",
            "    def __mul__(self, other):",
            "        return Modint(self.value * int(other))",
            "",
            "    def __truediv__(self, other):",
            "        inv = pow(int(other), self.MOD - 2, self.MOD)",
            "        return Modint(self.value * inv)",
            "",
            "    def __pow__(self, power):",
            "        return Modint(pow(self.value, power, self.MOD))",
            "",
            "    def __neg__(self):",
            "        return Modint(-self.value)",
            "",
            "    # ---- 右側演算 (int + Modint など) ----",
            "    def __radd__(self, other):",
            "        return self.__add__(other)",
            "",
            "    def __rsub__(self, other):",
            "        return Modint(int(other) - self.value)",
            "",
            "    def __rmul__(self, other):",
            "        return self.__mul__(other)",
            "",
            "    def __rtruediv__(self, other):",
            "        inv = pow(self.value, self.MOD - 2, self.MOD)",
            "        return Modint(int(other) * inv)",
            "",
            "    # ---- 比較 ----",
            "    def __eq__(self, other):",
            "        if isinstance(other, Modint):",
            "            return self.value == other.value",
            "        return self.value == (int(other) % self.MOD)",
            "",
            "    def __ne__(self, other):",
            "        return not self.__eq__(other)",
            "",
            "    # ---- 累算代入演算 ----",
            "    def __iadd__(self, other):",
            "        self.value = (self.value + int(other)) % self.MOD",
            "        return self",
            "",
            "    def __isub__(self, other):",
            "        self.value = (self.value - int(other)) % self.MOD",
            "        return self",
            "",
            "    def __imul__(self, other):",
            "        self.value = (self.value * int(other)) % self.MOD",
            "        return self",
            "",
            "    def __itruediv__(self, other):",
            "        inv = pow(int(other), self.MOD - 2, self.MOD)",
            "        self.value = (self.value * inv) % self.MOD",
            "        return self",
        ],
        "description": "Modint構造体"
    },


    "pyplot基本形": {
        "prefix": "pyplot",
        "body": [
            "import matplotlib.pyplot as plt",
            "plt.plot(range(len(ScoreMove)),ScoreMove)",
            "",
            "plt.xlabel(\"loop cnt\")",
            "plt.ylabel(\"Score\")",
            "",
            "plt.show()",
        ],
        "description": "pyplot基本形"
    },



    "sys.stdin.buffer.read": {
        "prefix": "sys.stdin.buffer.read",
        "body": [
            "read = sys.stdin.buffer.read",
            "readline = sys.stdin.buffer.readline",
            "readlines = sys.stdin.buffer.readlines",
        ],
        "description": "buffer系読み込み"
    },


	"標準入力": {
		"prefix": "stdinput",
		"body": [
			"################################################",
			"################################################",
			"import io",
			"import sys",
			"",
			"_INPUT = \"\"\"\\",
			"$1",
			"\"\"\"",
			"sys.stdin = io.StringIO(_INPUT)",
			"sys.stdin.buffer = io.BytesIO(_INPUT.encode('ascii'))",
			"################################################",
			"################################################",
			"",
			"import sys",
			"input = lambda: sys.stdin.readline().rstrip()",
			"",
			"",
			"$2",
		],
		"description": "標準入力"
	},	

	"INF": {
		"prefix": "INF",
		"body": [
			"float('INF')",
		],
		"description": "INF"
	},

	"MOD=998244353": {
		"prefix": "MOD=998244353",
		"body": [
			"MOD=998244353",
		],
		"description": "MOD=998244353"
	},

	"MOD=10**9+7": {
		"prefix": "MOD=10**9+7",
		"body": [
			"MOD=10**9+7",
		],
		"description": "MOD=10**9+7"
	},

	"round": {
		"prefix": "round=lambda x:(x*2+1)//2",
		"body": [
			"round=lambda x:int((x*2+1)//2)",
		],
		"description": "roundを四捨五入にする"
	},	

    "def conv_n_base": {
        "prefix": "def conv_n_base",
        "body": [
            "# 10進法からn進法に変換",
            "def conv_n_base(i,n):",
            "",
            "    i=int(i)",
            "    ret=[]",
            "",
            "    while i:",
            "        d,m=divmod(i,n)",
            "        ret.append(m)",
            "        i=d",
            "",
            "    return ''.join(map(str,ret[::-1]))",
        ],
        "description": "10進法からn進法に変換"
    },

	"popcount": {
		"prefix": "popcount",
		"body": [
			"bit_count()",
		],
		"description": "2進数に直したときのon-bitを数える"
	},	

    "ffs": {
        "prefix": "ffs",
        "body": [
            "# ビット表記した際に最初に1が現れる場所を返す",
            "def ffs(i):return (-i&i).bit_length()",
        ],
        "description": "ビット表記した際に最初に1が現れる場所を返す"
    },


    "def a20": {
        "prefix": "def a20",
        "body": [
            "# \"a\"を0としたindexを返す",
            "def a20(k):return ord(k)-ord(\"a\")",
        ],
        "description": "aを0としたindexを返す"
    },



	"4方向カーソル": {
		"prefix": "cur=((1,0),(0,1),(-1,0),(0,-1))",
		"body": [
			"cur=((1,0),(0,1),(-1,0),(0,-1))",
		],
		"description": "4方向カーソル"
	},

	"8方向カーソル": {
		"prefix": "cur=((1,0),(1,1),(0,1),(-1,1),(-1,0),(-1,-1),(0,-1),(1,-1))",
		"body": [
			"cur=((1,0),(1,1),(0,1),(-1,1),(-1,0),(-1,-1),(0,-1),(1,-1))",
		],
		"description": "8方向カーソル"
	},

    "RLDUカーソル": {
        "prefix": "cur=dd(list)",
        "body": [
            "cur=dd(list)",
            "cur[\"R\"]=[1,0]",
            "cur[\"L\"]=[-1,0]",
            "cur[\"U\"]=[0,1]",
            "cur[\"D\"]=[0,-1]",
        ],
        "description": "RLDUカーソル"
    },

    "if not": {
        "prefix": "if not",
        "body": [
            "if not (0<=i+di<H and 0<=j+dj<W):continue",
        ],
        "description": "グリッド範囲チェック"
    },


	"N行N列空リスト": {
		"prefix": "[[None] * N for i in range(N)]",
		"body": [
			"[[None] * N for i in range($1N)]",
			"$2",
		],
		"description": "N行N列空リスト"
	},	

	"降順sort": {
		"prefix": "sorted()",
		"body": [
			"sorted($1)",
		],
		"description": "降順sort"
	},

	"昇順sort": {
		"prefix": "sorted(,reverse=True)",
		"body": [
			"sorted($1,reverse=True)",
		],
		"description": "昇順sort"
	},

	"多次元sort": {
		"prefix": "sorted(A, reverse=True, key=lambda x: x[$11])",
		"body": [
			"sorted($1A, reverse=$2True, key=lambda x: x[$3])",
		],
		"description": "多次元sort"
	},

    "argsort": {
        "prefix": "argsort",
        "body": [
            "# 配列をソートした場合のindexのみを返す",
            "def argsort(A,rev=False):return sorted(range(len(A)),reverse=rev,key=A.__getitem__)",
            "",
        ],
        "description": "argsort"
    },

    "def next_permutation": {
        "prefix": "def next_permutation",
        "body": [
            "# 辞書順で入力の次のものを返す",
            "# ない場合はNoneを返す",
            "def next_permutation(A):",
            "",
            "    N=len(A)",
            "",
            "    for i in range(N-1,0,-1):",
            "        if A[i-1]>=A[i]:continue",
            "            ",
            "        for j in range(N-1,i-1,-1):",
            "            if A[i-1]>=A[j]:continue",
            "",
            "            A[i-1],A[j]=A[j],A[i-1]",
            "",
            "            l,r=i,N-1",
            "            while l<r:",
            "                A[l],A[r]=A[r],A[l]",
            "",
            "                l+=1",
            "                r-=1",
            "",
            "            return A",
            "",
            "    return None",
        ],
        "description": "next permutation"
    },

    "def prev_permutation": {
        "prefix": "def prev_permutation",
        "body": [
            "# 辞書順で入力の前のものを返す",
            "# ない場合はNoneを返す",
            "def prev_permutation(A):",
            "",
            "    N=len(A)",
            "",
            "    for i in range(N-1,0,-1):",
            "        if A[i-1]<=A[i]:continue",
            "            ",
            "        for j in range(N-1,i-1,-1):",
            "            if A[i-1]<=A[j]:continue",
            "",
            "            A[i-1],A[j]=A[j],A[i-1]",
            "",
            "            l,r=i,N-1",
            "            while l<r:",
            "                A[l],A[r]=A[r],A[l]",
            "",
            "                l+=1",
            "                r-=1",
            "",
            "            return A",
            "",
            "    return None",
        ],
        "description": "prev permutation"
    },


	"exit(0)": {
		"prefix": "exit(0)",
		"body": [
			"exit(0)",
		],
		"description": "exit(0)"
	},

    "def sum2D": {
        "prefix": "def sum2D",
        "body": [
            "# 二次元累積和から長方形領域の総和を返す",
            "def sum2D(si,sj,ti,tj):",
            "    return S[ti+1][tj+1]-S[si][tj+1]-S[ti+1][sj]+S[si][sj]",
            "",
            "# 二次元累積和を作る",
            "S=[[0 for _ in range(N+1)]for _ in range(N+1)]",
            "for i in range(N):",
            "    for j in range(N):",
            "        S[i+1][j+1]=A[i][j]+S[i][j+1]+S[i+1][j]-S[i][j]",
        ],
        "description": "二次元累積和"
    },

    "def sum3D": {
        "prefix": "def sum3D",
        "body": [
            "# 三次元累積和から立方体領域の総和を返す",
            "def sum3D(si,sj,sk,ti,tj,tk):",
            "    ret=0",
            "",
            "    ret-=S[si][sj][sk]",
            "    ret+=S[si][tj][sk]",
            "    ret+=S[ti][sj][sk]",
            "    ret-=S[ti][tj][sk]",
            "    ret+=S[si][sj][tk]",
            "    ret-=S[si][tj][tk]",
            "    ret-=S[ti][sj][tk]",
            "    ret+=S[ti][tj][tk]",
            "",
            "    return ret",
            "",
            "",
            "N=int(input())",
            "",
            "# N*N*Nの三次元累積和を作る",
            "S=[[[0 for _ in range(N+1)] for _ in range(N+1)] for _ in range(N+1)]",
            "",
            "for i in range(N):",
            "    for j in range(N):",
            "        for k in range(N):",
            "            ",
            "            # 生の値を入力",
            "            temp=A3[i][j][k]",
            "",
            "            # マンハッタン距離1:足す",
            "            temp+=S[i][j+1][k+1]",
            "            temp+=S[i+1][j][k+1]",
            "            temp+=S[i+1][j+1][k]",
            "",
            "            # マンハッタン距離2:引く",
            "            temp-=S[i+1][j][k]",
            "            temp-=S[i][j+1][k]",
            "            temp-=S[i][j][k+1]",
            "",
            "            # マンハッタン距離3:足す",
            "            temp+=S[i][j][k]",
            "",
            "            S[i+1][j+1][k+1]=temp",
        ],
        "description": "三次元累積和"
    },


    "rect_lap_check": {
        "prefix": "rect_lap_check",
        "body": [
            "# 直方体の重複判定",
            "# 重複ありならTrueを返す",
            "def rect_lap_check(ABCD):",
            "",
            "    for i in range(N):",
            "        a1,b1,c1,d1=ABCD[i]",
            "        for j in range(N):",
            "            if i==j:continue",
            "            a2,b2,c2,d2=ABCD[j]",
            "            if max(a1,a2)<min(c1,c2) and max(b1,b2)<min(d1,d2):return True",
            "",
            "    return False",
        ],
        "description": "長方形の重複判定"
    },


	"unionfind": {
		"prefix": "unionfind",
		"body": [
			"import sys",
			"sys.setrecursionlimit(10**8)",
			"",
            "def find(x):",
            "    if par[x]!=x:par[x]=find(par[x])",
            "    return par[x]",
            "",
            "def union(a,b):",
            "    a=find(a)",
            "    b=find(b)",
            "",
            "    if a==b:return",
            "    if rank[a]<rank[b]:a,b=b,a",
            "",
            "    par[b]=a",
            "    rank[a]+=rank[b]",
            "    rank[b]=rank[a]",
            "",
            "    return",
			"",
			"",
			"par=(list(range(N+1)))",
			"rank=[1 for _ in range(N+1)]",
		],
		"description": "UnionFind"
	},

    "class UnionFind:": {
        "prefix": "class UnionFind:",
        "body": [
            "sys.setrecursionlimit(10**8)",
			"",
            "class UnionFind:",
            "    def __init__(self,n):",
            "        self.par=list(range(n+1))",
            "        self.rank=[1 for _ in range(n+1)]",
            "",
            "    def find(self,x):",
            "        if self.par[x]!=x:self.par[x]=self.find(self.par[x])",
            "        return self.par[x]",
            "",
            "    def union(self,a,b):",
            "        if self.same(a,b):return ",
            "",
            "        a=self.par[a]",
            "        b=self.par[b]",
            "",
            "        if self.rank[a]<self.rank[b]:a,b=b,a",
            "",
            "        self.par[b]=a",
            "        self.rank[a]+=self.rank[b]",
            "        self.rank[b]=self.rank[a]",
            "",
            "        return",
            "",
            "    def same(self,a,b):",
            "        if self.find(a)==self.find(b):return True",
            "        else:return False",
        ],
        "description": "クラスUnionFind"
    },

    "class PotentialUnionFind:": {
        "prefix": "class PotentialUnionFind:",
        "body": [
            "sys.setrecursionlimit(10**8)",
            "",
            "class PotentialUnionFind:",
            "    def __init__(self,n):",
            "        self.par=list(range(n+1))",
            "        self.rank=[1 for _ in range(n+1)]",
            "        self.diffp=[0 for _ in range(n+1)]",
            "",
            "    def find(self,x):",
            "        if self.par[x]==x:return x",
            "        ",
            "        ret=self.find(self.par[x])",
            "        self.diffp[x]+=self.diffp[self.par[x]]",
            "        self.par[x]=ret",
            "        return ret",
            "        ",
            "",
            "    # Unionが上手くいけばTrueを返す",
            "    # a,bが同じ集合でも差が同じならTrueを返す",
            "    def union(self,a,b,p):",
            "        if self.same(a,b):",
            "            if self.diff(a,b)==p:return True",
            "            return False",
            "",
            "        p+=self.acm_pot(a)-self.acm_pot(b)",
            "",
            "        a=self.par[a]",
            "        b=self.par[b]",
            "",
            "        if self.rank[a]<self.rank[b]:",
            "            a,b=b,a",
            "            p*=-1",
            "",
            "        self.par[b]=a",
            "        self.diffp[b]=p",
            "",
            "        self.rank[a]+=self.rank[b]",
            "        self.rank[b]=self.rank[a]",
            "",
            "        return True",
            "",
            "    def same(self,a,b):",
            "        return self.find(a)==self.find(b)",
            "",
            "    # 同じ集合内なら差を返す",
            "    # 異なればNoneを返す",
            "    def diff(self,a,b):",
            "        if self.same(a,b):",
            "            return self.acm_pot(b)-self.acm_pot(a)",
            "",
            "    def acm_pot(self,a):",
            "        self.find(a)",
            "        return self.diffp[a]",
        ],
        "description": "重み付きUnionFind"
    },

    "gcd": {
        "prefix": "gcd",
        "body": [
            "from math import gcd",
        ],
        "description": "gcd"
    },

    "拡張ユークリッド": {
        "prefix": "def ext_gcd(a,b)",
        "body": [
            "# ax+by=gcd(a,b)を満たす",
            "# x,y,gcd(a,b)の組を求める",
            "def ext_gcd(a,b):",
            "",
            "    if b==0:return 1,0,a",
            "    ",
            "    d,m=divmod(a,b)",
            "    x,y,g=ext_gcd(b,m)",
            "",
            "    return y,x-d*y,g",
        ],
        "description": "拡張ユークリッドの互除法"
    },

    "中国剰余定理": {
        "prefix": "def CRT",
        "body": [
            "# x≡a1(mod m1)",
            "# x≡a2(mod m2)",
            "# ...",
            "# を満たすx(mod m)を求める",
            "# m=-1なら解なし",
            "def CRT(A,M):",
            "",
            "    assert len(A)==len(M)",
            "",
            "    N=len(A)",
            "    rx,rm=0,1",
            "",
            "    for i in range(N):",
            "        a,m=A[i],M[i]",
            "",
            "        x,y,g=ext_gcd(rm,m)",
            "",
            "        td,tm=divmod(a-rx,g)",
            "        if tm:return -1,-1",
            "",
            "        m//=g",
            "        temp=(td*x)%m",
            "        rx+=rm*temp",
            "",
            "        rm*=m",
            "",
            "    return rx,rm",
        ],
        "description": "中国剰余定理"
    },


	"lcm(a,b)": {
		"prefix": "lcm(a,b)",
		"body": [
			"import math",
			"def lcm(a,b):",
			"    return (a*b)//math.gcd(a,b)",
		],
		"description": "lcm"
	},
	"comb(a,b)": {
		"prefix": "comb(a,b)",
		"body": [
			"from math import factorial",
			"def comb(n,r):",
			"    return factorial(n)//(factorial(n-r)*factorial(r))",
		],
		"description": "組合せ"
	},
	"extgcd(*n)": {
		"prefix": "extgcd(*n)",
		"body": [
			"from functools import reduce",
			"from math import gcd",
			"def extgcd(*n):",
			"    return reduce(gcd,n)",
		],
		"description": "3引数以上のGCD"
	},

    "LF_Coeff": {
        "prefix": "LF_Coeff",
        "body": [
            "# 点(x1,y1)、(x2,y2)を通る一次関数の",
            "# 傾きと切片を求める",
            "# ただし傾き=INFの場合は切片にx座標を記録する",
            "def LF_Coeff(x1, y1, x2, y2):",
            "    if x1!=x2:",
            "        a = (y2 - y1) / (x2 - x1)",
            "        b = y1 - a * x1",
            "    else:",
            "        a=INF",
            "        b=x1    ",
            "    return a, b",
        ],
        "description": "一次関数の係数を求める"
    },


    "list(map(lambda x:int(x)-1, input().split()))": {
        "prefix": "list(map(lambda x:int(x)-1, input().split()))",
        "body": [
            "list(map(lambda x:int(x)-1, input().split()))",
        ],
        "description": "1-indexedから0-indexedに変換して入力受け取り"
    },



	"ビット全探索": {
		"prefix": "itr.product(range(2),repeat=N)",
		"body": [
			"itr.product(range(2),repeat=N)",
		],
		"description": "ビット全探索用イテレータ"
	},


	"めぐる式二分探索": {
		"prefix": "def meguru_bisearch",
		"body": [
			"def judge(mid):",
			"",
			"    ##ここに判定条件を書く",
            "",
			"    if :return True",
			"    else:return False",
			"",
			"##ng,okの条件に気をつける",
			"def meguru_bisearch(ng, ok):",
			"",
            "    while abs(ok-ng)>1:",
			"        mid=(ok+ng)//2",
			"        if judge(mid):ok=mid",
			"        else:ng=mid",
			"",
			"    return ok",
		],
		"description": "めぐる式二分探索"
	},

	"三分探索": {
		"prefix": "def trisearch",
		"body": [
			"def judge(c1,c2):",
			"",
			"##ここに判定条件を書く",
			"    if :",
			"        return 1",
			"    else:",
			"        return 0",
			"",
			"def trisearch(low, high,N):",
			"",
			"    ##許容誤差をepsとする",
			"    eps=",
			"",
			"    while abs(high-low)>eps:",
			"        c1=(high+2*low)/3",
			"        c2=(2*high+low)/3",
			"        if judge(c1,c2):",
			"            low=c1",
			"        else:",
			"            high=c2",
			"    return low",
		],
		"description": "三分探索"
	},


	"lru_cache自動メモ化": {
		"prefix": "from functools import lru_cache",
		"body": [
			"from functools import lru_cache",
			"",
			"@lru_cache(maxsize=None)",
		],
		"description": "自動メモ化(昔の)"
	},

    "cache": {
        "prefix": "cache",
        "body": [
            "from functools import cache",
            "",
            "@cache",
        ],
        "description": "自動メモ化"
    },


    "深さ優先探索(再帰)": {
        "prefix": "dfs",
        "body": [
            "from collections import defaultdict as dd",
            "sys.setrecursionlimit(10**8)",
            "",
            "##再帰を使ったDFS",
            "##行きがけの順番を配列d、帰りがけの順番を配列fに記録",
            "def dfs(s):",
            "",
            "    ##行きがけで処理するときはこの辺でやる",
            "",
            "    for t in edge[s]:",
            "        if chk[t]:continue",
            "        dfs(t)",
            "",
            "    ##帰りがけで処理するときはこの辺でやる",
            "",
            "",
            "##有向グラフを辞書edgeに記録する",
            "edge=dd(list)",
            "chk=[False]*N",
            "",
            "dfs()",
        ],
        "description": "深さ優先探索(再帰)"
    },


	"繰り返し二乗法": {
		"prefix": "def reppow(x,n,mod)",
		"body": [
            "def reppow(x,n,mod):",
            "##(x**n)%modを繰り返し二乗法によって算出",
            "##pow(x,n,mod)と同じ",
            "",
            "    ret=1",
            "    while n:",
            "        if n&1:ret=(ret*x)%mod",
            "        x=(x*x)%mod",
            "        n>>=1",
            "    return ret",
		],
		"description": "繰り返し二乗法"
	},

    "def modinv": {
        "prefix": "def modinv",
        "body": [
            "# mod Mにおけるxのmod逆元を求める",
            "# x*inv(x)≡1(mod M)より",
            "# inv(x)*x-mM=1と変形して",
            "# 拡張ユークリッドを使う",
            "def modinv(x,M):",
            "    ret,_,_=ext_gcd(x,M)",
            "    return ret",
        ],
        "description": ""
    },

    "modcomb": {
        "prefix": "modcomb",
        "body": [
            "##n以下の階乗とそのmod逆元を作る",
            "def modfact(n):",
            "",
            "    fact[0]=1",
            "    invfact[0]=1",
            "    ",
            "    for i in range(n):",
            "        fact[i+1]=((i+1)*fact[i])%MOD",
            "        invfact[i+1]=pow(fact[i+1],MOD-2,MOD)",
            "    ",
            "",
            "",
            "##modを取った組合せを計算する",
            "def modcomb(n,r):",
            "",
            "    if r<=0 or n<r:return 0",
            "",
            "    ret=0",
            "    ret=(fact[n]*invfact[r])%MOD",
            "    ret=(ret*invfact[n-r])%MOD",
            "",
            "    return ret",
        ],
        "description": "mod組合せ"
    },

    "class ModComb:": {
        "prefix": "class ModComb:",
        "body": [
            "# modを取ったコンビネーションを計算する",
            "# modは別途定義する",
            "class ModComb:",
            "",
            "    ##n以下の階乗とそのmod逆元を作る",
            "    def __init__(self,N) -> None:",
            "        ",
            "        self.fact=[0]*(N+1)",
            "        self.invfact=[0]*(N+1)",
            "",
            "        self.fact[0]=1",
            "        self.invfact[0]=1",
            "",
            "        for i in range(N):",
            "            self.fact[i+1]=((i+1)*self.fact[i])%MOD",
            "            self.invfact[i+1]=pow(self.fact[i+1],MOD-2,MOD)",
            "",
            "",
            "    ##modを取った組合せを計算する",
            "    def modcomb(self,n,r) -> int:",
            "",
            "        if r<=0 or n<r:return 0",
            "",
            "        ret=(self.fact[n]*self.invfact[r])%MOD",
            "        ret=(ret*self.invfact[n-r])%MOD",
            "",
            "        return ret",
        ],
        "description": "mod組合せクラス"
    },


	"floorsum": {
		"prefix": "def floorsum(n,m,a,b):",
		"body": [
            "import sys",
            "sys.setrecursionlimit(10**8)",
            "",
            "##y=(ax+b)/M (0<x<=n)以下の格子点の数を求める",
            "def floorsum(n,m,a,b):",
            "    ans=0",
            "    if a>=m:",
            "        ans+=(n-1)*n*(a//m)//2",
            "        a%=m",
            "    if b>=m:",
            "        ans+=n*(b//m)",
            "        b%=m",
            "",
            "    y_max=(a*n+b)//m",
            "    x_max=(y_max*m-b)",
            "    if y_max==0:",
            "        return ans",
            "",
            "    ans+=(n-(x_max+a-1)//a)*y_max",
            "    ans+=floorsum(y_max,a,m,(a-x_max%a)%a)",
            "    return ans",
		],
		"description": "floorsum"
	},
	
	"ミラーラビン素数判定法": {
        "prefix": "def Miller_Rabin",
        "body": [
            "# ビット表記した際に最初に1が現れる場所を返す",
            "def ffs(i):return (-i&i).bit_length()",
            "",
            "##ミラーラビン素数判定法",
            "##素数ならTrue,非素数ならFalseを返す",
            "def Miller_Rabin(N):",
            "",
            "    ##1は非素数",
            "    if N==1:",
            "        return False",
            "",
            "    ##2は素数その他2の倍数は合成数",
            "    if N%2==0:",
            "        if N==2:return True",
            "        else:return False",
            "",
            "    ##偶数は篩落としたのでNは奇数でありN-1は偶数となる",
            "    ##ここでN-1を2^s*dと表すこととする",
            "    temp=N-1",
            "    s=ffs(N-1)",
            "",
            "    d=(N-1)>>(s-1)",
            "",
            "    ##比較対象リスト",
            "    ##2^32未満なら2,7,61",
            "    ##2^64未満なら2, 325, 9375, 28178, 450775, 9780504, 1795265022",
            "    ##それ以上は2以上N未満の乱数50個を使う",
            "",
            "    if N<2**32:complist=(2,7,61)",
            "    elif N<2**64:complist=(2, 325, 9375, 28178, 450775, 9780504, 1795265022)",
            "    else:",
            "        from random import randint",
            "        complist=set()",
            "        while len(complist)<50:complist.add(randint(2,N-1))",
            "",
            "    ##aをcomplist中の数字でそれぞれ試してみる",
            "    for a in complist:",
            "        if N<=a:break",
            "",
            "        ##(a^d)%N=1ならこのaについてはミラーラビンテスト合格",
            "        if pow(a,d,N)==1:continue",
            "",
            "        ##0<=r<sを満たす(a^(d*(2^r)))%Nを見ていき",
            "        ##-1≡N-1を満たすものが1つでもあればこのaについてミラーラビンテスト合格",
            "        ##1つもなければその時点で不合格(非素数)",
            "        for r in range(s):",
            "            temp=pow(a,d<<r,N)",
            "            if temp==N-1:break",
            "        else:",
            "            return False",
            "",
            "    ##すべてのaについてミラーラビンテストが合格したならおそらく素数と判定できる",
            "    return True",
        ],
        "description": "ミラーラビン素数判定法"
    },


	"線形篩": {
		"prefix": "def prime(N):",
		"body": [
			"def prime(N):",
			"    ##Pをsetに変えたらアカン",
			"    P=[]",
			"    f=[0 for _ in range(N+1)]",
			"",
			"    for i in range(2,N+1):",
			"        if f[i]==0:",
			"            P.append(i)",
			"            f[i]=i",
			"",
			"        for j in P:",
			"            if i*j>N or j>f[i]:break",
			"",
			"            f[i*j]=j",
			"",
			"    return P",

		],
		"description": "線形篩"
	},

    "素因数分解": {
        "prefix": "def fact",
        "body": [
            "def fact(N):",
            "    P=[]",
            "    temp = N",
            "",
            "    for i in range(2, int(N**0.5)+1):",
            "        if temp%i==0:",
            "            cnt=0",
            "            while temp%i==0:",
            "                cnt+=1",
            "                temp //= i",
            "            P.append([i, cnt])",
            "",
            "    if temp!=1:",
            "        P.append([temp, 1])",
            "",
            "    if P==[]:",
            "        P.append([N, 1])",
            "",
            "    return P",
        ],
        "description": "素因数分解"
    },


    "def divenum": {
        "prefix": "def divenum",
        "body": [
            "##約数列挙",
            "def divenum(N):",
            "    D=[]",
            "    for i in range(1, int(N**0.5)+1):",
            "        if N%i==0:",
            "            D.append(i)",
            "            if N//i!=i:",
            "                D.append(N//i)",
            "",
            "    D=sorted(D)",
            "    return D",
        ],
        "description": "約数列挙"
    },

    "オイラーのトーシェント関数": {
        "prefix": "def euler_phi",
        "body": [
            "def fact(N):",
            "    P=[]",
            "    temp = N",
            "",
            "    for i in range(2, int(N**0.5)+1):",
            "        if temp%i==0:",
            "            cnt=0",
            "            while temp%i==0:",
            "                cnt+=1",
            "                temp //= i",
            "            P.append([i, cnt])",
            "",
            "    if temp!=1:",
            "        P.append([temp, 1])",
            "",
            "    if P==[]:",
            "        P.append([N, 1])",
            "",
            "    return P",
            "",
            "def euler_phi(n):",
            "    P=fact(n)",
            "    ret=n",
            "",
            "    for k,_ in P:",
            "        ret//=k",
            "        ret*=(k-1)",
            "",
            "    return ret",
        ],
        "description": "オイラーのトーシェント関数"
    },


    "2つの長方形の重複部分": {
        "prefix": "def rectangle_overlap(rect1,rect2):",
        "body": [
            "# 長方形どうしの重なり部分の座標返す",
            "# 長方形の対角の座標を持っておく",
            "def rectangle_overlap(rect1,rect2):",
            "    x11,y11,x12,y12=rect1",
            "    x21,y21,x22,y22=rect2",
            "",
            "    x_min=max(x11,x21)",
            "    x_max=min(x12,x22)",
            "    y_min=max(y11,y21)",
            "    y_max=min(y12,y22)",
            "",
            "    # 重なり部分の長方形の座標は(x_min,y_min,x_max,y_max)",
            "    if x_max<=x_min or y_max<=y_min:return None",
            "    return x_min,y_min,x_max,y_max",
        ],
        "description": "2つの長方形の重複部分"
    },

    "長方形の面積": {
        "prefix": "def rectangle_area(rect)",
        "body": [
            "# 長方形の面積",
            "# 長方形の対角の座標を持っておく",
            "def rectangle_area(rect):",
            "    x1,y1,x2,y2=rect",
            "    return (x2-x1)*(y2-y1)",
        ],
        "description": "長方形の面積"
    },

    "2つの直方体の重複部分": {
        "prefix": "def cuboid_overlap(cube1,cube2)",
        "body": [
            "# 直方体どうしの重なり部分の対角の座標を返す",
            "# 直方体の対角の座標を持っておく",
            "def cuboid_overlap(cube1,cube2):",
            "    x11,y11,z11,x12,y12,z12=cube1",
            "    x21,y21,z21,x22,y22,z22=cube2",
            "",
            "    x_min=max(x11,x21)",
            "    x_max=min(x12,x22)",
            "    y_min=max(y11,y21)",
            "    y_max=min(y12,y22)",
            "    z_min=max(z11,z21)",
            "    z_max=min(z12,z22)",
            "",
            "    if x_max <= x_min or y_max <= y_min or z_max <= z_min:return None",
            "    return x_min,y_min,z_min,x_max,y_max,z_max",
        ],
        "description": "2つの直方体の重複部分"
    },

    "直方体の体積": {
        "prefix": "def cuboid_volume(cube):",
        "body": [
            "# 直方体の体積を返す",
            "# 直方体の対角の座標を持っておく",
            "def cuboid_volume(cube):",
            "    x1,y1,z1,x2,y2,z2=cube",
            "    return (x2-x1)*(y2-y1)*(z2-z1)",
        ],
        "description": "直方体の体積"
    },


    "def rot2d90deg(rootx,rooty,x,y)": {
        "prefix": "def rot2d90deg(rootx,rooty,x,y)",
        "body": [
            "##二次元座標回転",
            "##座標x,yをrootx,rootyに対して90[deg]回転する",
            "def rot2d90deg(rootx,rooty,x,y):",
            "    x-=rootx",
            "    y-=rooty",
            "",
            "    x=-y",
            "    y=x",
            "",
            "    x+=rootx",
            "    y+=rooty",
            "",
            "    return x,y",
        ],
        "description": "2次元座標90度回転"
    },

    "def rot2d(rootx,rooty,x,y,th):": {
        "prefix": "def rot2d(rootx,rooty,x,y,th):",
        "body": [
            "from math import sin,cos,pi",
            "",
            "##2次元座標回転",
            "##座標x,yをrootx,rootyに対してth[rad]回転する",
            "def rot2d(rootx,rooty,x,y,th):",
            "",
            "    x-=rootx",
            "    y-=rooty",
            "",
            "    x=x*cos(th)-y*sin(th)",
            "    y=x*sin(th)+y*cos(th)",
            "",
            "    x+=rootx",
            "    y+=rooty",
            "",
            "    return x,y",
        ],
        "description": "2次元座標回転"
    },

    "def grid_r_rot(A)": {
        "prefix": "def grid_r_rot(A)",
        "body": [
            "##2次元行列Aを時計回りに回転する",
            "##zip版",
            "def grid_r_rot(A):",
            "    return list(zip(*A[::-1]))",
            "",
            "##普通に行列操作する(少し速い?)",
            "def grid_r_rot1(A):",
            "    N=len(A)",
            "    M=len(A[0])",
            "    retA=[]",
            "",
            "    for i in range(N):",
            "        temp=[]",
            "        for j in range(M):",
            "            temp.append(A[N-j-1][i])",
            "",
            "        retA.append(temp)",
            "    return retA",
        ],
        "description": "座標右回転"
    },


    "def grid_l_rot(A)": {
        "prefix": "def grid_l_rot(A)",
        "body": [
            "##2次元行列Aを反時計回りに回転する",
            "##zip版",
            "def grid_l_rot(A):",
            "    return list(zip(*A))[::-1]",
            "",
            "##普通に行列操作する(少し速い?)",
            "def grid_l_rot1(A):",
            "    N=len(A)",
            "    M=len(A[0])",
            "    retA=[[None for _ in range(N)]for _ in range(M)]",
            "",
            "    for i in range(N):",
            "        for j in range(M):",
            "            retA[N-j-1][i]=A[i][j]",
            "",
            "    return retA",
        ],
        "description": "座標左回転"
    },



    "def prdmat(A,B):": {
        "prefix": "def prdmat(A,B):",
        "body": [
            "##N行M列の行列AとM行K列の行列Bの行列積Cを計算する",
            "def prdmat(A,B):",
            "",
            "    global MOD",
            "",
            "    N=len(A)",
            "    M=len(A[0])",
            "    M1=len(B)",
            "    K=len(B[0])",
            "",
            "    assert M==M1",
            "",
            "    ##Bを転置する",
            "    tB=transmat(B)",
            "",
            "    ##行列積CはN行K列となる",
            "    C=[[0 for _ in range(K)] for _ in range(N)]",
            "",
            "    for i in range(N):",
            "        a=A[i]",
            "        for j in range(K):",
            "            b=tB[j]",
            "            temp=0",
            "            for k in range(M):",
            "                temp+=(a[k]*b[k])%MOD",
            "                temp%=MOD",
            "            C[i][j]=temp",
            "    return C",
        ],
        "description": "行列積"
    },

    "def reppowmat(A,n):": {
        "prefix": "def reppowmat(A,n):",
        "body": [
            "##繰り返し二乗法によって行列累乗を求める",
            "def reppowmat(A,n):",
            "",
            "    ##単位行列を作る",
            "    l=len(A)",
            "    ret=[[0 for _ in range(l)] for _ in range(l)]",
            "    for i in range(l):",
            "        ret[i][i]=1",
            "",
            "    while n:",
            "        if n&1:",
            "            ret=prdmat(ret,A)",
            "        A=prdmat(A,A)",
            "",
            "        n>>=1",
            "",
            "    return ret",
        ],
        "description": "行列累乗"
    },

    "def closs(px,py,ax,ay,bx,by)": {
        "prefix": "def cross(px,py,ax,ay,bx,by)",
        "body": [
            "##P=(px,py),A=(ax,ay),B=(bx,by)に対して",
            "##ベクトルPA,PBの外積PA×PBを計算する",
            "def cross(px,py,ax,ay,bx,by):",
            "    PA=(ax-px,ay-py)",
            "    PB=(bx-px,by-py)",
            "    return PA[0]*PB[1]-PA[1]*PB[0]",
        ],
        "description": "3点に対する外積"
    },


    "def calc_rank(A):": {
        "prefix": "def calc_rank(A):",
        "body": [
            "def calc_rank(A):",
            "    N=len(A)",
            "    A=progress_elimination(A)",
            "",
            "    res=0",
            "    for i in range(N):    ",
            "        if A[i][i]!=0:",
            "            res+=1",
            "",
            "    return res",
        ],
        "description": "行列ランク計算"
    },

    "def progress_elimination(A):": {
        "prefix": "def progress_elimination(A):",
        "body": [
            "##前進消去",
            "def progress_elimination(A):",
            "    global MOD",
            "",
            "    N=len(A)",
            "    assert N==len(A[0])",
            "    res=1",
            "    rank=N",
            "    for i in range(N):",
            "        ##A[i][i]=0なら同じ行で非ゼロの",
            "        ##他の列と入れ替えができないか探す",
            "        if A[i][i]==0:",
            "            for j in range(i+1,N):",
            "                if A[i][j]!=0:",
            "                    ##非ゼロの列があればj列とi列入れ替え",
            "                    ##置換に伴う符号反転-1を行列式の外にかけておく",
            "                    for k in range(N):",
            "                        A[k][j],A[k][i]=A[k][i]%MOD,A[k][j]%MOD",
            "                        res*=-1",
            "                    break",
            "            else:",
            "                ##無ければ仕方ないのでcontinue",
            "                ##rankを1減らして行列式の値も0とする",
            "                res*=0",
            "                rank-=1",
            "                continue",
            "",
            "",
            "        ##A[i][i]のMOD逆元を求めてA[i][i]=1とするため",
            "        ##Aのi行目の各要素をA[i][i]で割る=revAiをかける",
            "        ##この時行列式の外に出すA[i][i]をresにかける",
            "",
            "        revAi=pow(A[i][i],MOD-2,MOD)",
            "        res=(res*A[i][i])%MOD",
            "        for k in range(i,N):",
            "            A[i][k]=A[i][k]*revAi%MOD",
            "        ",
            "        ##A[j]行の各要素から(A[i]の各要素*A[j][i])を引いていき",
            "        ##Aのi+1行目以降j列を0にしていく",
            "        for j in range(i+1,N):",
            "            if A[j][i]==0:",
            "                continue",
            "",
            "            jmul=A[j][i]",
            "            ##Aのj(i<j<N)行目の各要素A[j][k]からA[i][k]*jmul倍したものを引いていく",
            "            for k in range(i,N):",
            "                A[j][k]=(A[j][k]-jmul*A[i][k])%MOD",
            "                ",
            "        #for a in A:",
            "        #    print(a)",
            "",
            "    return A,res",
        ],
        "description": "行列式,前進消去"
    },

    "def invmat(A):": {
        "prefix": "def invmat(A):",
        "body": [
            "MOD=998244353",
            "##N行N列の正方行列Aに対してAB=Eとなる行列Bを掃き出し法にて求める",
            "def invmat(A):",
            "",
            "    ",
            "    N=len(A)",
            "    assert N==len(A[0])",
            "",
            "    ##単位行列Bを用意する",
            "    B=[[0 for _ in range(N)] for _ in range(N)]",
            "    for i in range(N):",
            "        B[i][i]=1",
            "",
            "",
            "    for i in range(N):",
            "        ##A[i][i]=0ならi列が非ゼロの",
            "        ##他の行を足せないか探す",
            "        if A[i][i]==0:",
            "            for j in range(i+1,N):",
            "                if A[j][i]!=0:",
            "                    ##i列が非ゼロの行があればその行の値を足す",
            "                    for k in range(N):",
            "                        A[i][k]=(A[j][k]+A[i][k])%MOD",
            "                        B[i][k]=(B[j][k]+B[i][k])%MOD",
            "                    break",
            "            else:",
            "                ##無ければrank!=Nであり逆行列は存在しない",
            "                return -1",
            "",
            "        ##前進消去を行う",
            "        ##A[i][i]=1とするためA[i][i]のMOD逆元revAiを求めて",
            "        ##Aのi行目の各要素をA[i][i]で割る=revAiをかける",
            "        ##Bのi行目も同様に操作する",
            "        revAi=pow(A[i][i],MOD-2,MOD)",
            "        for k in range(N):",
            "            A[i][k]=A[i][k]*revAi%MOD",
            "            B[i][k]=B[i][k]*revAi%MOD",
            "",
            "        ##A[j]行の各要素から(A[i]の各要素*A[j][i])を引いていき",
            "        ##i行目以外のj列を0にしていく",
            "        for j in range(N):",
            "            if j==i or A[j][i]==0:",
            "                continue",
            "",
            "            jmul=A[j][i]",
            "            ##Aのj行目の各要素A[j][k]からA[i][k]*jmul倍したものを引いていく",
            "            ##Bの方も同様に操作する",
            "            for k in range(N):",
            "                A[j][k]=(A[j][k]-jmul*A[i][k])%MOD",
            "                B[j][k]=(B[j][k]-jmul*B[i][k])%MOD",
            "",
            "    return B",
        ],
        "description": "逆行列"
    },

    "def transmat(A):": {
        "prefix": "def transmat(A):",
        "body": [
            "##N行M列の行列AをM行N列の行列transAに転置する",
			"##return list(zip(*A))と同じ",
            "def transmat(A):",
            "",
            "    N=len(A)",
            "    M=len(A[0])",
            "",
            "    transA=[[0 for _ in range(N) ] for _ in range(M)]",
            "    for i in range(N):",
            "        for j in range(M):",
            "            transA[j][i]=A[i][j]",
            "",
            "    return transA",
        ],
        "description": "行列転置"
    },


    "def LUdecomp(mat):": {
        "prefix": "def LUdecomp(mat)",
        "body": [
            "##LU分解する",
            "##逆元としてMOD逆元を使う",
            "##下三角行列の対角成分を1とするドゥーリトル法",
            "##判定は入れていないが首座行列式が0となるものがあれば分解不能",
            "def LUdecomp(mat):",
            "    global MOD",
            "",
            "    N=len(mat)",
            "    assert N==len(mat[0])",
            "",
            "    L=[[0 for _ in range(N)] for _ in range(N)]",
            "    U=[[0 for _ in range(N)] for _ in range(N)]",
            "",
            "    ##横⇒縦⇒横⇒縦⇒…で埋めていく",
            "    for i in range(N):",
            "        #Lの対角成分は1",
            "        L[i][i]=1",
            "",
            "        ##i行目の横を見ていく",
            "        for j in range(i,N):",
            "            temp=0",
            "            for k in range(i):",
            "                temp+=U[k][j]*L[i][k]",
            "                temp%=MOD",
            "            #print(\"U\",i,j)",
            "            U[i][j]=(mat[i][j]-temp)%MOD",
            "",
            "        ##i列目の縦を見ていく",
            "        ##U[i][i]のMOD逆元を求める",
            "        revU=pow(U[i][i],MOD-2,MOD)",
            "        for j in range(i+1,N):",
            "            temp=0",
            "            for k in range(i):",
            "                temp+=U[k][i]*L[j][k]",
            "                temp%=MOD",
            "",
            "            #print(\"L\",j,i)",
            "            L[j][i]=((mat[j][i]-temp)*revU)%MOD",
            "",
            "    return L,U",
        ],
        "description": "LU分解"
    },

    "edge=dd(list)": {
        "prefix": "edge=dd(list)",
        "body": [
            "##各頂点とつながる辺を辞書edgeに記録する",
            "edge=dd(list)",
            "for _ in range($1):",
            "    a,b=map(int,input().split())",
            "    edge[a].append(b)",
            "    edge[b].append(a)",
        ],
        "description": "edge基本形"
    },


    "def Cycle_Detect_DFS(s):": {
        "prefix": "def Cycle_Detect_DFS(s):",
        "body": [
            "# 閉路検出機能付きDFS",
            "# サイクル中の頂点をリストに格納する",
            "def Cycle_Detect_DFS(s):",
            "",
            "    chk[s]=True",
            "    q.append(s)",
            "",
            "    for t in edge[s]:",
            "        if fin[t]:continue",
            "        elif chk[t]:",
            "            CycleDetect=True",
            "            while q:",
            "                v=q.pop()",
            "                fin[v]=True",
            "                CycleList.append(v)",
            "            return",
            "        else:Cycle_Detect_DFS(t)",
            "",
            "        if CycleDetect:return",
            "",
            "    q.pop(s)",
            "    fin[s]=True",
            "    return",
            "",
            "",
            "chk=dd(bool)",
            "fin=dd(bool)",
            "q=deque()",
            "CycleDetect=False",
            "CycleList=[]",
        ],
        "description": "閉路検出機能付きDFS"
    },



    "def BFS(i)": {
        "prefix": "def BFS(i)",
        "body": [
            "##N頂点の幅優先探索",
            "##chkに始点iからの距離を入れていく",
            "def BFS(i):",
            "",
            "    q=deque()",
            "    chk=[INF for _ in range(N+1)]",
            "    chk[i]=0",
            "",
            "    while q:",
            "        s=q.popleft()",
            "        for t in edge[s]:",
            "            if chk[t]==INF:",
            "                chk[t]=chk[s]+1",
            "    return",
        ],
        "description": "シンプルなBFS"
    },

    "kruskal": {
        "prefix": "kruskal",
        "body": [
            "##辺a,bを結ぶ重みwの辺を##",
            "##edge[i]=[a,b,w]の形で持っておく##",
            "##重みの総和costを返す##",
            "##選ばれた辺をTに書き留める##",
            "",
            "import sys",
            "sys.setrecursionlimit(10**8)",
            "",
            "class UnionFind:",
            "    def __init__(self,n):",
            "        self.par=list(range(n+1))",
            "        self.rank=[1 for _ in range(n+1)]",
            "",
            "    def find(self,x):",
            "        if self.par[x]!=x:self.par[x]=self.find(self.par[x])",
            "        return self.par[x]",
            "",
            "    def union(self,a,b):",
            "        if self.same(a,b):return ",
            "",
            "        a=self.par[a]",
            "        b=self.par[b]",
            "",
            "        if self.rank[a]<self.rank[b]:a,b=b,a",
            "",
            "        self.par[b]=a",
            "        self.rank[a]+=self.rank[b]",
            "        self.rank[b]=self.rank[a]",
            "",
            "        return",
            "",
            "    def same(self,a,b):",
            "        if self.find(a)==self.find(b):return True",
            "        else:return False",
            "",
            "class kruskal:",
            "",
            "",
            "    def __init__(self,N):",
            "        self.uf=UnionFind(N+1)",
            "        self.edge=[]",
            "        self.T=[]",
            "        self.cost=0",
            "        self.N=N",
            "",
            "    def add_edge(self,a,b,w):",
            "        self.edge.append((a,b,w))",
            "",
            "",
            "    def solve(self):",
            "        self.edge=sorted(self.edge, reverse=False, key=lambda x: x[2])",
            "",
            "        for a,b,w in self.edge:",
            "            if self.uf.same(a,b):continue",
            "",
            "            self.T.append((a,b,w))",
            "",
            "            self.cost+=w",
            "            self.uf.union(a,b)",
            "",
            "        return self.cost",
            "",
            "    def all_connect(self):",
            "        p=self.uf.find(1)",
            "        return self.uf.rank[p]==self.N",
        ],
        "description": "クラス化したクラスカル法"
    },

    "class prim:": {
        "prefix": "class prim:",
        "body": [
            "# 辺a,bを結ぶ重みwの辺を",
            "# edge[a]=[b,w],edge[b]=[a,w]の形で持っておく",
            "# 適当な点からスタートし確定している点から",
            "# コストが最小の辺を調べ次の点を確定させる",
            "# 確定した点は配列chkにTrueを書き込む",
            "# コストが最小となる辺はheapqによって管理する",
            "",
            "",
            "from heapq import heappop as hpop,heappush as hpush",
            "",
            "class prim:",
            "",
            "    def __init__(self,N):",
            "        self.edge=[[]for _ in range(N+1)]",
            "        self.chk=[False for _ in range(N+1)]",
            "        self.cnt=0",
            "        self.cost=0",
            "",
            "    def add_edge(self,s,t,w):",
            "        self.edge[s].append((w,t))",
            "",
            "    def solve(self,s=1):",
            "        q=[]",
            "        for w,t in self.edge[s]:hpush(q,(w,t))",
            "",
            "        self.chk[s]=1",
            "        self.cnt+=1",
            "",
            "        while len(q):",
            "            w,t=hpop(q)",
            "            if self.chk[t]==False:",
            "                self.chk[t]=True",
            "                self.cnt+=1",
            "                self.cost+=w",
            "                for nw,nt in self.edge[t]:",
            "                    if self.chk[nt]==False:hpush(q,(nw,nt))",
            "",
            "        return self.cost",
        ],
        "description": ""
    },


    "ダイクストラ法": {
        "prefix": "dijkstra",
        "body": [
            "",
            "##dijkstra法",
            "",
            "def dijkstra(start):",
            "    ##costに始点から見た高さを記録する",
            "    ##最初はINFで初期化しておく",
            "    cost=[INF for _ in range(N+1)]",
            "    cost[start]=0",
            "    chk=[False for _ in range(N+1)]",
            "    res=0",
            "    ##qをheapqとして使う",
            "    q=[]",
            "",
            "    hpush(q,(0,start))",
            "",
            "    ##heapqで近い順に値を決定していく",
            "    while len(q):",
            "        c,s=hpop(q)",
            "        if chk[s]==True:continue",
            "        chk[s]=True",
            "        for nowc,t in edge[s]:",
            "            if c+nowc<cost[t]:",
            "                cost[t]=c+nowc",
            "                hpush(q,(c+nowc,t))",
            "",
            "    return res",
            "",
            "##edgeに重さw、終点tをタプルで記録する",
            "edge=dd(list)",
            "for _ in range(#クエリの数):",
            "    w,u,v=map(int,input().split())",
            "    edge[u].append((w,v))",
            "    edge[v].append((w,u))",
            "",
            "dijkstra(1)",
        ],
        "description": "ダイクストラ法"
    },

    "dijkstra": {
        "prefix": "dijkstra",
        "body": [
            "from heapq import heapify,heappop as hpop,heappush as hpush",
            "INF=float('INF')",
            "",
            "",
            "class Graph:",
            "    def __init__(self,N):",
            "",
            "        self.edge=[[]for _ in range(N+1)]",
            "",
            "        ##costに始点から見た高さを記録する",
            "        ##最初はINFで初期化しておく",
            "        self.cost=[INF for _ in range(N+1)]",
            "        self.pre=[-1 for _ in range(N+1)]",
            "        self.path=[]",
            "",
            "        ##qをheapqとして使う",
            "        self.q=[]",
            "",
            "    def add_edge(self,u,v,w):",
            "        self.edge[u].append((w,v))",
            "",
            "    def dijkstra(self,start,goal):",
            "",
            "        self.cost[start]=0",
            "        hpush(self.q,(0,start))",
            "",
            "        ##heapqで近い順に値を決定していく",
            "        while len(self.q):",
            "            c,s=hpop(self.q)   ",
            "",
            "            if c>self.cost[s]:continue",
            "",
            "            if s==goal:",
            "",
            "                # 経路復元する",
            "                while ~self.pre[s]:",
            "                    self.path.append((self.pre[s],s))",
            "                    s=self.pre[s]",
            "                ",
            "                self.path=self.path[::-1]",
            "                return c",
            "            ",
            "            for nowc,t in self.edge[s]:",
            "                if c+nowc<self.cost[t]:",
            "                    self.cost[t]=c+nowc",
            "                    self.pre[t]=s",
            "                    hpush(self.q,(c+nowc,t))",
            "",
            "        return -1",
        ],
        "description": "ダイクストラクラス化"
    },


    "Bellman-Ford": {
        "prefix": "Bellman-Ford",
        "body": [
            "from collections import defaultdict as dd",
            "INF=float('INF')",
            "neg=\"NEGATIVE CYCLE\"",
            "",
            "",
            "##入力",
            "V,E,r=map(int,input().split())",
            "",
            "##辺情報入力",
            "edge=dd(list)",
            "for _ in range(E):",
            "    s,t,d=map(int,input().split())",
            "    edge[s].append((t,d))",
            "",
            "##始点からの距離情報初期化",
            "dist=[INF for _ in range(V)]",
            "dist[r]=0",
            "",
            "",
            "##ベルマンフォード本体",
            "for loop in range(V):",
            "    ",
            "    ##loop回目の確認中に更新が行われるかフラグで管理",
            "    f=False",
            "",
            "    for i in range(V):",
            "",
            "        ##まだ到達していない頂点ならば確認しない",
            "        if dist[i]==INF:continue",
            "",
            "        ##頂点iから接続される点の距離更新確認",
            "        ##更新がある場合はfをTrueとする",
            "        for j,c in edge[i]:",
            "            if dist[j]>dist[i]+c:",
            "                dist[j]=dist[i]+c",
            "                f=True",
            "",
            "",
            "    ##更新がなければ終了",
            "    if not f:break",
            "",
            "",
            "",
            "else:",
            "    ##V回の確認後に更新が行われるならば負閉路が存在している",
            "    if f:",
            "        print(neg)",
            "        exit(0)",
            "",
            "##出力",
            "for a in dist:",
            "    if a==INF:print(\"INF\")",
            "    else:print(a)",
        ],
        "description": "ベルマンフォード法"
    },


    "Warshall-Floyd": {
        "prefix": "Warshall-Floyd",
        "body": [
            "##Warshall-Floyd法:O(N^3:Nは頂点の数)",
            "##DP[k][i][j]をiからjへ行くためにkを経由する場合のコストとする",
            "##kはインラインでできるのでDP[i][j]としてよい",
            "",
            "##DPテーブル初期化",
            "DP=[[INF for _ in range(N)]for _ in range(N)]",
            "##始点終点が同じならコスト0",
            "for i in range(N):",
            "    DP[i][i]=0",
            "",
            "##与えられたedgeのコストを入力",
            "for _ in range(M):",
            "",
            "##ワ―シャルフロイド本体の3重ループ",
            "for k in range(N):",
            "    for i in range(N):",
            "        for j in range(N):",
            "            ##点iから点jへ直接移動するか",
            "            ##点kを経由するかコストの小さい方を採用",
            "            DP[i][j]=min(DP[i][j],DP[i][k]+DP[k][j])",
        ],
        "description": "ワ―シャルフロイド法"
    },



    "fenwicktree": {
        "prefix": "class fenwick",
        "body": [
            "##1-indexedのFenwickTree",
            "##区間和とxorに対応",
            "class fenwick:",
            "    ##配列fwを要素数nで初期化する",
            "    def __init__(self, n):",
            "        self.size = n",
            "        self.tree = [0] * (n+1)",
            "",
            "    ##iにxを加算する",
            "    def add(self, i, x):",
            "        assert 1<=i<=self.size",
            "        while i <= self.size:",
            "            self.tree[i] += x",
            "            ##LSBを加算して次のインデックスを求める",
            "            i += i & -i",
            "",
            "    ##iにxをxorする",
            "    def xoradd(self, i, x):",
            "        assert 1 <= i <= self.size",
            "        while i <= self.size:",
            "            self.tree[i] ^= x",
            "            i += i & -i",
            "",
            "    ##[l,r]の区間和を取得する",
            "    ##[0,r]から[0,l]を引く",
            "    def sum(self, l, r):",
            "        assert 0 <= l <= r <= self.size",
            "        return self.sum0(r) - self.sum0(l)",
            "",
            "    ##[0,r]の総和を取得する",
            "    def sum0(self, r):",
            "        s = 0",
            "        while r > 0:",
            "            s += self.tree[r]",
            "            r -= r & -r",
            "        return s",
            "",
            "    ##[l,r]のxorを取得する",
            "    ##[0,r]と[0,l]のxorを取る",
            "    def xorsum(self, l, r):",
            "        assert 0 <= l <= r <= self.size",
            "        return self.xorsum0(r)^self._xorsum0(l-1)",
            "",
            "    ##[0,r]のxorを取得する",
            "    def xorsum0(self, r):",
            "        s = 0",
            "        while r > 0:",
            "            s ^= self.tree[r]",
            "            r -= r & -r",
            "        return s",
        ],
        "description": "フェニック木"
    },

    "fenwick": {
        "prefix": "class fenwick",
        "body": [
            "from operator import add",
            "",
            "##1-indexedのFenwickTree",
            "##モノイド演算子を渡す",
            "class fenwick:",
            "    ##配列fwを要素数nで初期化する",
            "    def __init__(self, n ,initval=0 ,op=add):",
            "        self.size = n",
            "        self.op = op",
            "        self.initval = initval",
            "",
            "        self.tree = [initval for _ in range(n+1)]",
            "",
            "    ##iにxを加算する",
            "    def add(self, i, x):",
            "        assert 1<=i<=self.size",
            "        while i <= self.size:",
            "            self.tree[i] = self.op(self.tree[i],x)",
            "            ##LSBを加算して次のインデックスを求める",
            "            i += i & -i",
            "",
            "    ##[l,r]の区間和を取得する",
            "    ##[0,r]から[0,l]を引く",
            "    def sum(self, l, r):",
            "        assert 0 <= l <= r <= self.size",
            "        return self.sum0(r) - self.sum0(l)",
            "",
            "    ##[0,r]の総和を取得する",
            "    def sum0(self, r):",
            "        s = self.initval",
            "        while r > 0:",
            "            s = self.op(s,self.tree[r])",
            "            r -= r & -r",
            "        return s",
            "",
            "    def __getitem__(self,i):",
            "        if type(i)==tuple:return self.sum(i[0],i[1])",
            "        else:return self.sum0(i)",
        ],
        "description": "演算子を渡すfenwick木"
    },


    "segtree": {
        "prefix": "segtree",
        "body": [
            "n2=1",
            "while (n2<=N+2): n2*=2",
            "segtree=[set() for _ in range(2*n2-1)]",
        ],
        "description": "セグメント木初期化"
    },


    "def get_range_pos(s,e):": {
        "prefix": "def get_range_pos(s,e):",
        "body": [
            "##[s,e]の区間を取得する",
            "def get_range_pos(s,e):",
            "    s+=n2",
            "    e+=n2",
            "    poslist=[]",
            "    while s<e:",
            "        if s%2!=0:",
            "            poslist.append(s)",
            "            s+=1 ",
            "        s//=2",
            "        if e%2!=0:",
            "            e-=1",
            "            poslist.append(e)",
            "        e//=2",
            "",
            "    return poslist",
        ],
        "description": "セグメント木区間取得"
    },

    "class SegmentTree": {
        "prefix": "class SegmentTree",
        "body": [
            "from operator import add",
            "",
            "class SegmentTree:",
            "    def __init__(self,n,initval=0,op=add):",
            "",
            "        if type(n)==list:self.size = len(n)",
            "        else:self.size = n",
            "        self.initval = initval",
            "        self.op = op",
            "",
            "        l=self.size.bit_length()",
            "",
            "        self.n2=1<<l",
            "        self.tree=[initval for _ in range(self.n2<<1)]",
            "",
            "        if type(n)==list:",
            "            for i,a in enumerate(n):self.point_set(i,a)",
            "",
            "",
            "",
            "    # ある区間[l,r)に対応するセグ木上のindexを取得する",
            "    def range_2_idx(self,l,r):",
            "        l+=self.n2",
            "        r+=self.n2",
            "",
            "        ret=[]",
            "",
            "        while l<r:",
            "            if l&1:",
            "                ret.append(l)",
            "                l+=1",
            "            l>>=1",
            "            if r&1:",
            "                r-=1",
            "                ret.append(r)",
            "            r>>=1",
            "",
            "        return ret",
            "",
            "    # ある1点idxに対応するセグ木上のindexを取得する",
            "    def point_2_idx(self,idx):",
            "        idx+=self.n2",
            "        ret=[]",
            "        while idx>0:",
            "            ret.append(idx)",
            "            idx>>=1",
            "",
            "        return ret",
            "",
            "    # 一点更新",
            "    # 前の値を完全に更新する",
            "    def point_set(self,pos,val):",
            "        ",
            "        # まず一点更新",
            "        R=self.point_2_idx(pos)",
            "        self.tree[R[0]]=val",
            "",
            "        # その影響を上まで伝搬させる",
            "        for idx in R[1:]:",
            "            self.tree[idx]=self.op(self.tree[idx<<1],self.tree[(idx<<1)|1])",
            "",
            "    # 一点操作",
            "    # 前の値も操作の対象にする",
            "    def point_op(self,pos,val):",
            "        ",
            "        R=self.point_2_idx(pos)",
            "        self.tree[R[0]]=self.op(self.tree[R[0]],val)",
            "",
            "        # その影響を上まで伝搬させる",
            "        for idx in R[1:]:",
            "            self.tree[idx]=self.op(self.tree[idx<<1],self.tree[(idx<<1)|1])",
            "",
            "    # 一点取得",
            "    def point_val(self,pos):",
            "        R=self.point_2_idx(pos)",
            "        ret=self.initval",
            "",
            "        for idx in R:ret=self.op(ret,self.tree[idx])",
            "",
            "        return ret",
            "",
            "    # 区間更新",
            "    # 前の値を完全に更新する",
            "    def range_set(self,l,r,val):",
            "",
            "        R=self.range_2_idx(l,r)",
            "        for idx in R:self.tree[idx]=val",
            "",
            "    # 区間操作",
            "    # 前の値も操作の対象にする",
            "    def range_op(self,l,r,val):",
            "",
            "        R=self.range_2_idx(l,r)",
            "        for idx in R:self.tree[idx]=self.op(self.tree[idx],val)",
            "",
            "    # 区間取得",
            "    def range_val(self,l,r):",
            "",
            "        R=self.range_2_idx(l,r)",
            "        ret=self.initval",
            "",
            "        for idx in R:ret=self.op(ret,self.tree[idx])",
            "",
            "        return ret",
            "",
            "    # tree[l,r]なら[l,r)の区間取得",
            "    # tree[l]ならlの一点取得を行う",
            "    def __getitem__(self,i):",
            "        if type(i)==tuple:return self.range_val(i[0],i[1])",
            "        else:return self.point_val(i)",
            "",
            "    # printでtreeの中身を表示",
            "    def __repr__(self):",
            "        return str(self.tree)",
        ],
        "description": "セグ木クラス"
    },

    "class kd_tree_2D:": {
        "prefix": "class kd_tree_2D:",
        "body": [
            "class kd_tree_2D:",
            "",
            "",
            "    # S=[x座標,y座標,index]の形で渡す",
            "    def __init__(self,S):",
            "",
            "",
            "        N=len(S)",
            "",
            "        # あるindexより下の要素の",
            "        # 各最大最小を記録しておく",
            "        self.xmin=[INF]*N",
            "        self.xmax=[-INF]*N",
            "        self.ymin=[INF]*N",
            "        self.ymax=[-INF]*N",
            "",
            "        # あるindexより下の要素の",
            "        # indexの範囲を記録",
            "        self.idxmin=[-1]*N",
            "        self.idxmax=[-1]*N",
            "",
            "        # あるindexの要素の左右の子となる",
            "        # 要素をL,Rに記録していく",
            "        self.L=[-1]*N",
            "        self.R=[-1]*N",
            "",
            "        self.S=S",
            "        self.par=N//2",
            "        self.const_kdtree(0,N,0)",
            "",
            "    def const_kdtree(self,imin,imax,axis):",
            "",
            "        n=imax-imin",
            "        c=(imax+imin)//2",
            "",
            "        self.idxmin[c]=imin",
            "        self.idxmax[c]=imax",
            "",
            "        # 対象の範囲で対象の軸についてソートする",
            "        self.S[imin:imax]=sorted(self.S[imin:imax],key=lambda a: a[axis])",
            "",
            "        # 今回の探索の中心となる点のindexを求める",
            "",
            "        x,y,_=self.S[c]",
            "        if n==1:",
            "            self.xmin[c]=x",
            "            self.xmax[c]=x",
            "            self.ymin[c]=y",
            "            self.ymax[c]=y",
            "",
            "            return ",
            "        ",
            "        # 左側を再帰的に探索する",
            "        c1=(c+imin)//2",
            "        if imin<=c1<c:",
            "            self.L[c]=c1",
            "            self.const_kdtree(imin,c,axis^1)",
            "",
            "            self.xmin[c]=min(x,self.xmin[c1])",
            "            self.xmax[c]=max(x,self.xmax[c1])",
            "            self.ymin[c]=min(y,self.ymin[c1])",
            "            self.ymax[c]=max(y,self.ymax[c1])",
            "",
            "        # 右側を再帰的に探索する",
            "        c2=(imax+c+1)//2",
            "        if c<c2<imax:",
            "",
            "            self.R[c]=c2",
            "            self.const_kdtree(c+1,imax,axis^1)",
            "",
            "            self.xmin[c]=min(self.xmin[c],self.xmin[c2])",
            "            self.xmax[c]=max(self.xmax[c],self.xmax[c2])",
            "            self.ymin[c]=min(self.ymin[c],self.ymin[c2])",
            "            self.ymax[c]=max(self.ymax[c],self.ymax[c2])",
            "",
            "",
            "    # 範囲内の点の数を数えてindexリストを返す",
            "    def count_value(self,sx,tx,sy,ty,p=-1):",
            "",
            "        if p==-1:p=self.par",
            "",
            "        # 親の範囲を確認する",
            "        xminp=self.xmin[p]",
            "        xmaxp=self.xmax[p]",
            "        yminp=self.ymin[p]",
            "        ymaxp=self.ymax[p]",
            "",
            "        ret=[]",
            "",
            "        # 各最大最小の外側をチェックする",
            "        if tx<xminp or xmaxp<sx or ty<yminp or ymaxp<sy:return ret",
            "",
            "",
            "        # 完全に含まれているならその中の要素はすべて含まれる",
            "        elif sx<=xminp<=xmaxp<=tx and sy<=yminp<=ymaxp<=ty:",
            "            imin=self.idxmin[p]",
            "            imax=self.idxmax[p]",
            "",
            "            S=self.S[imin:imax]",
            "            for _,_,k in S:ret.append(k)",
            "            ",
            "            return ret",
            "            ",
            "        # 上以外は再帰的にチェック",
            "        else:",
            "",
            "            xp,yp,i=self.S[p]",
            "            ",
            "",
            "            # まず今の要素が範囲内かチェック",
            "            if sx<=xp<=tx and sy<=yp<=ty:ret.append(i)",
            "",
            "",
            "            # 左右の葉について再帰的にチェックしていく",
            "            l,r=self.L[p],self.R[p]",
            "            if ~l:ret+=self.count_value(sx,tx,sy,ty,l)",
            "            if ~r:ret+=self.count_value(sx,tx,sy,ty,r)",
            "",
            "            return ret",
        ],
        "description": "kd木(2次元)"
    },



    "根付き木作成": {
        "prefix": "class RootTree",
        "body": [
            "class RootTree:",
            "    def __init__(self,N):",
            "        self.edge=[[] for _ in range(N+1)]",
            "        self.depth=[-1 for _ in range(N+1)]",
            "        self.par=[-1 for _ in range(N+1)]",
            "        self.son=[[] for _ in range(N+1)]",
            "",
            "    def add_edge(self,a,b):",
            "        self.edge[a].append(b)",
            "        self.edge[b].append(a)",
            "",
            "    def solve(self,st=1):",
            "        q=deque()",
            "        q.append(st)",
            "        self.depth[st]=0",
            "",
            "        while q:",
            "            s=q.popleft()",
            "            for t in self.edge[s]:",
            "                if self.depth[t]==-1:",
            "                    self.depth[t]=self.depth[s]+1",
            "                    self.son[s].append(t)",
            "                    self.par[t]=s",
            "                    q.append(t)",
        ],
        "description": "根付き木作成"
    },


	"トポロジカルソート": {
		"prefix": "def topsort(s)",
		"body": [
            "sys.setrecursionlimit(10**8)",
            "class TopologicalSort:",
            "",
            "    def __init__(self,N):",
            "        self.seen=[False for _ in range(N+1)]",
            "        self.edge=[[] for _ in range(N+1)]",
            "        self.order=[]",
            "",
            "    def add_edge(self,s,t):",
            "        self.edge[s].append(t)",
            "",    
            "    # orderは最後に反転させる",
            "    def solve(self,s):",
            "        self.seen[s]=True",
            "        for t in self.edge[s]:",
            "            if self.seen[t]==False:",
            "                self.solve(t)",
            "",
            "        self.order.append(s)",
            "",
		],
		"description": "トポロジカルソート"
	},

    "強いトポロジカルソート": {
        "prefix": "topsort",
        "body": [
            "from heapq import heapify,heappop as hpop,heappush as hpush",
            "",
            "class TopologicalSort:",
            "",
            "    def __init__(self,N):",
            "        self.seen=[False for _ in range(N+1)]",
            "        self.edge=[[] for _ in range(N+1)]",
            "        self.order=[]",
            "        self.ind=[0 for _ in range(N+1)]",
            "        self.N=N",
            "",
            "    def add_edge(self,s,t):",
            "        self.edge[s].append(t)",
            "        self.ind[t]+=1",
            "",
            "    def solve(self):",
            "        q=[]",
            "        for i in range(self.N):",
            "            if self.ind[i]==0:hpush(q,i)",
            "",
            "        while q:",
            "            ##qの最小要素を取り出しorderに追加する",
            "            s=hpop(q)",
            "            self.order.append(s)",
            "",
            "            ##iの子を確認し入り次数を減らす",
            "            ##入り次数が0になればqに追加する",
            "            for t in self.edge[s]:",
            "                self.ind[t]-=1",
            "                if self.ind[t]==0:",
            "                    hpush(q,t)",
        ],
        "description": "強いトポロジカルソート、処理順を問わない場合小さいほうから並べる"
    },

    "SCC": {
        "prefix": "SCC",
        "body": [
            "from collections import defaultdict as dd",
            "sys.setrecursionlimit(10**8)",
            "",
            "##再帰を使ったDFS",
            "##行きがけの順番を配列d、帰りがけの順番を配列fに記録",
            "def dfs(edge,k):",
            "",
            "##行きがけで処理するときはこの辺でやる",
            "    global dcnt,fcnt",
            "    dcnt+=1",
            "    d[k]=dcnt",
            "",
            "    for i in edge[k]:",
            "        if d[i]!=-1:",
            "            continue",
            "        dfs(edge,i)",
            "",
            "",
            "##帰りがけで処理するときはこの辺でやる",
            "    fcnt+=1",
            "    f[k]=[k,fcnt]",
            "",
            "def rdfs(edge,k):",
            "",
            "##行きがけで処理するときはこの辺でやる",
            "    global cnt",
            "    chk[k]=cnt",
            "    SCC[cnt].add(k)",
            "    for i in edge[k]:",
            "        if chk[i]!=-1:",
            "            continue",
            "        rdfs(edge,i)",
            "",
            "##有向グラフを辞書edgeに記録する",
            "##強連結成分分解用に逆向き矢印も辞書redgeに記録",
            "N,M=map(int,input().split())",
            "edge,redge=dd(list),dd(list)",
            "",
            "for i in range(M):",
            "    A,B=map(int,input().split())",
            "    edge[A].append(B)",
            "    redge[B].append(A)",
            "",
            "d=[-1 for _ in range(N+1)]",
            "f=[None for _ in range(N+1)]",
            "",
            "##とりあえずDFSで探索順を記録",
            "dcnt,fcnt=0,0",
            "for i in range(1,N+1):",
            "    if d[i]==-1:",
            "        dfs(edge,i)",
            "",
            "##帰りがけで遅かった順に逆向きDFSを行い",
            "##行き止まりになるまでの範囲を",
            "##一つの強連結成分(SCC)とする",
            "f=f[1:]",
            "f=sorted(f, reverse=True, key=lambda x: x[1])",
            "chk=[-1 for _ in range(N+1)]",
            "cnt=0",
            "SCC=dd(set)",
            "",
            "for k,v in f:",
            "    if chk[k]==-1:",
            "        rdfs(redge,k)",
            "        cnt+=1",
        ],
        "description": "強連結成分分解(SCC)"
    },

    "def Tarjan_SCC()": {
        "prefix": "def Tarjan_SCC()",
        "body": [
            "from collections import defaultdict as dd,deque",
            "sys.setrecursionlimit(10**8)",
            "",
            "##Taejan_SCC",
            "##参考:https://www.youtube.com/watch?v=wUgWX0nc4NY",
            "def Tarjan_SCC():",
            "",
            "    def DFS(s):",
            "",
            "        nonlocal NodeID,SCCcnt",
            "",
            "        q.append(s)",
            "        onStack[s]=True",
            "",
            "        IDs[s]=NodeID ",
            "        LLV[s]=NodeID",
            "        NodeID+=1    ",
            "",
            "        for t in edge[s]:",
            "            ##まだ見ていないノードなら探索する",
            "            if IDs[t]==-1:DFS(t)",
            "            ##現在のSCC候補ならLLVを更新する",
            "            if onStack[t]:LLV[s]=min(LLV[s],LLV[t])",
            "",
            "        ##LLVの始点まで戻ってきたらスタック中のLLVをすべて更新する",
            "        if IDs[s]==LLV[s]:",
            "            templist=[]",
            "            while q:",
            "                node=q.pop()",
            "                onStack[node]=False",
            "                LLV[node]=IDs[s]",
            "                templist.append(node)",
            "                if (node==s):break",
            "",
            "            SCCset.append(templist)",
            "            SCCcnt+=1",
            "",
            "",
            "    NodeID=0",
            "    SCCcnt=0",
            "",
            "    IDs=dd(lambda:-1)",
            "    LLV=dd(int)",
            "    SCCset=[]",
            "    onStack=dd(bool)",
            "    q=deque()",
            "",
            "    for i in range(N):",
            "        if IDs[i]==-1:DFS(i)",
            "                ",
            "    return SCCset",
        ],
        "description": "Tarjan's SCC"
    },

    "Tarjan_SCC": {
        "prefix": "Tarjan_SCC",
        "body": [
            "##Tarjan_SCC",
            "##参考:https://www.youtube.com/watch?v=wUgWX0nc4NY",
            "",
            "",
            "class Graph:",
            "",
            "    def __init__(self,N):",
            "",
            "        self.edge=[[]for _ in range(N)]",
            "",
            "        self.NodeID=0",
            "        self.SCCcnt=0",
            "        self.IDs=[-1 for _ in range(N)]",
            "        self.LLV=[0 for _ in range(N)]",
            "        self.onStack=[False for _ in range(N)]",
            "        self.q=deque()",
            "",
            "        self.SCCset=[]",
            "",
            "    def add_edge(self,s,t):",
            "        self.edge[s].append(t)",
            "",
            "",
            "    def DFS(self,s):",
            "",
            "        self.q.append(s)",
            "        self.onStack[s]=True",
            "",
            "        self.IDs[s]=self.NodeID ",
            "        self.LLV[s]=self.NodeID",
            "        self.NodeID+=1    ",
            "",
            "        for t in self.edge[s]:",
            "            ##まだ見ていないノードなら探索する",
            "            if self.IDs[t]==-1:self.DFS(t)",
            "            ##現在のSCC候補ならLLVを更新する",
            "            if self.onStack[t]:self.LLV[s]=min(self.LLV[s],self.LLV[t])",
            "",
            "        ##LLVの始点まで戻ってきたらスタック中のLLVをすべて更新する",
            "        if self.IDs[s]==self.LLV[s]:",
            "            templist=[]",
            "            while self.q:",
            "                node=self.q.pop()",
            "                self.onStack[node]=False",
            "                self.LLV[node]=self.IDs[s]",
            "                templist.append(node)",
            "                if (node==s):break",
            "",
            "            self.SCCset.append(templist)",
            "            self.SCCcnt+=1",
            "",
            "    def Tarjan_SCC(self):",
            "",
            "        for i in range(N):",
            "            if self.IDs[i]==-1:self.DFS(i)",
            "                    ",
            "        return self.SCCset[::-1]",
        ],
        "description": "Tarjan's SCCクラス化"
    },


    "def Ford_Fulkerson(s,t):": {
        "prefix": "def Ford_Fulkerson(s,t):",
        "body": [
            "from collections import defaultdict as dd",
            "sys.setrecursionlimit(10**8)",
            "INF=float('INF')",
            "",
            "def FFdfs(s,t,F):",
            "",
            "    ##tに到達したら流量を戻す",
            "    if s==t:return F",
            "",
            "    chk[s]=True",
            "    ##パスを全探索",
            "    for k in edge[s].keys():",
            "",
            "        ##ループを形成していないか確認",
            "        if chk[k]:continue",
            "",
            "        ##まだ流す容量が存在するか確認",
            "        if edge[s][k]<=0:continue",
            "",
            "        ##tまでのパスを見つけたら流せるだけ流す",
            "        flow=FFdfs(k,t,min(F,edge[s][k]))",
            "",
            "        ##流せなければ次を見る",
            "        if flow==0:continue",
            "",
            "        ##流せるなら再帰的に流量を戻していく",
            "        edge[s][k]-=flow",
            "        edge[k][s]+=flow",
            "        return flow",
            "",
            "    ##流せるパスが無ければ無し",
            "    return 0",
            "",
            "",
            "def Ford_Fulkerson(s,t):",
            "    ret=0",
            "    while 1:",
            "        for i in range(E+1):chk[i]=False",
            "        F=FFdfs(s,t,INF)",
            "        if F==0: return ret",
            "        ret+=F",
            "",
            "",
            "V,E=map(int,input().split())",
            "",
            "edge=dd(lambda:dd(lambda:-1))",
            "for i in range(E):",
            "    u,v,c=map(int,input().split())",
            "    edge[u][v]=c",
            "    edge[v][u]=0",
            "",
            "chk=[False]*(E+1)",
            "res=Ford_Fulkerson(0,V-1)",
            "",
            "print(res)",
        ],
        "description": "フォード-ファルカーソン法(最大流)"
    },

    "Ford_Fulkerson": {
        "prefix": "Ford_Fulkerson",
        "body": [
            "class Graph:",
            "",
            "    def __init__(self):",
            "        self.chk=dd(bool)",
            "        self.edge=dd(lambda:dd(lambda:-1))",
            "",
            "    def add_edge(self,s,t,f):",
            "        self.edge[s][t]=f",
            "        self.edge[t][s]=0",
            "",
            "    def FFdfs(self,s,t,F):",
            "",
            "        ##tに到達したら流量を戻す",
            "        if s==t:return F",
            "",
            "        self.chk[s]=True",
            "        ##パスを全探索",
            "        for k,v in self.edge[s].items():",
            "",
            "            ##ループを形成していないか確認",
            "            if self.chk[k]:continue",
            "",
            "            ##まだ流す容量が存在するか確認",
            "            if v<=0:continue",
            "",
            "            ##tまでのパスを見つけたら流せるだけ流す",
            "            flow=self.FFdfs(k,t,min(F,v))",
            "",
            "            ##流せなければ次を見る",
            "            if flow==0:continue",
            "",
            "            ##流せるなら再帰的に流量を戻していく",
            "            self.edge[s][k]-=flow",
            "            self.edge[k][s]+=flow",
            "            return flow",
            "",
            "        ##流せるパスが無ければ無し",
            "        return 0",
            "",
            "",
            "    def Ford_Fulkerson(self,s,t):",
            "        ret=0",
            "        while 1:",
            "            self.chk.clear()",
            "            F=self.FFdfs(s,t,INF)",
            "            if F==0: return ret",
            "            ret+=F",
        ],
        "description": "フォードファルカーソンクラス化"
    },


    "def Dinic": {
        "prefix": "def Dinic",
        "body": [
            "sys.setrecursionlimit(10**8)",
            "from collections import defaultdict as dd,deque",
            "INF=float('INF')",
            "",
            "##辺の追加",
            "##sからtヘ容量fの辺を張る",
            "def add_edge(s,t,f):",
            "    ssize=len(edge[s])",
            "    tsize=len(edge[t])",
            "",
            "    edge[s].append([t,f,tsize])",
            "    edge[t].append([s,0,ssize])",
            "",
            "    return ",
            "",
            "##始点からの深さを調べる",
            "def D_BFS(s):",
            "",
            "    for i in range(V+1):depth[i]=INF",
            "    depth[s]=0",
            "",
            "    q=deque()",
            "    q.append(s)",
            "    while len(q):",
            "        s=q.popleft()",
            "        for to,cost,_ in edge[s]:",
            "",
            "            if cost and depth[to]==INF:",
            "                depth[to]=depth[s]+1",
            "                q.append(to)",
            "",
            "    return",
            "",
            "##流量チェック",
            "def D_DFS(s,t,F):",
            "",
            "    if s==t:return F",
            "    ",
            "    itr=chk[s]",
            "    for i in range(itr,len(edge[s])):",
            "",
            "        to,cost,rev=edge[s][i]",
            "",
            "        ##まだ流す容量が存在するか確認",
            "        if cost==0:continue",
            "",
            "        ##より深い点か確認",
            "        if depth[s]>=depth[to]:continue",
            "",
            "        ##tまでのパスを見つけたら流せるだけ流す",
            "        flow=D_DFS(to,t,min(F,cost))",
            "",
            "        ##流せるなら再帰的に流量を戻していく",
            "        if flow>0:",
            "",
            "            edge[s][i][1]-=flow",
            "            edge[to][rev][1]+=flow",
            "",
            "            chk[s]=i",
            "            return flow",
            "",
            "    chk[s]=len(edge[s])",
            "    return 0",
            "",
            "def Dinic(s,t):",
            "",
            "    Flow=0",
            "    while 1:",
            "        D_BFS(s)",
            "        if depth[t]==INF:return Flow",
            "",
            "        for i in range(V+1):chk[i]=0",
            "",
            "        F=INF",
            "        while F>0:",
            "            F=D_DFS(s,t,INF)",
            "            Flow+=F",
            "            ",
            "V,E=map(int,input().split())",
            "",
            "##辞書に[行き先,コスト,対応する辺の位置]を記録する",
            "edge=dd(list)",
            "for i in range(E):",
            "    u,v,c=map(int,input().split())",
            "    add_edge(u,v,c)",
            "",
            "depth=[INF]*(V+1)",
            "chk=[0]*(V+1)",
            "",
            "res=Dinic(0,V-1)",
            "print(res)",
        ],
        "description": "Dinic法(最大流)"
    },


    "Dinic": {
        "prefix": "Dinic",
        "body": [
            "class Graph:",
            "",
            "    def __init__(self,n) -> None:",
            "        self.n=n",
            "        self.edge=[[] for _ in range(n)]",
            "        self.chk=[0 for _ in range(n)]",
            "        self.depth=[INF for _ in range(n)]",
            "",
            "        self.edge_len=[]",
            "",
            "    ##辺の追加",
            "    ##sからtヘ容量fの辺を張る",
            "    def add_edge(self,s,t,f) -> None:",
            "        ssize=len(self.edge[s])",
            "        tsize=len(self.edge[t])",
            "",
            "        self.edge[s].append([t,f,tsize])",
            "        self.edge[t].append([s,0,ssize])",
            "",
            "        return ",
            "",
            "    ##始点からの深さを調べる",
            "    def D_BFS(self,s,t) -> None:",
            "",
            "        for i in range(self.n):self.depth[i]=INF",
            "        self.depth[s]=0",
            "",
            "        q=deque()",
            "        q.append(s)",
            "        while len(q):",
            "            s=q.popleft()",
            "            ds=self.depth[s]",
            "            for to,cost,_ in self.edge[s]:",
            "",
            "                if cost and self.depth[to]==INF:",
            "                    self.depth[to]=ds+1",
            "                    if to==t:return",
            "                    q.append(to)",
            "",
            "        return",
            "",
            "    ##流量チェック",
            "    def D_DFS(self,s,t) -> int:",
            "",
            "        stack=deque()",
            "        stack.append(s)",
            "",
            "        while stack:",
            "            u=stack[-1]",
            "            if u==t:",
            "                stack.pop()",
            "                break",
            "",
            "            itr=self.chk[u]",
            "            itr_end=self.edge_len[u]",
            "            ",
            "            for i in range(itr,itr_end):",
            "                ",
            "                v,cost,rev=self.edge[u][i]",
            "",
            "                ##まだ流す容量が存在するか確認",
            "                if cost==0:continue",
            "",
            "                ##より深い点か確認",
            "                if self.depth[u]>=self.depth[v]:continue",
            "",
            "                # 次の点が調べ終わっていないか確認",
            "                if self.chk[v]>=self.edge_len[v]:continue",
            "",
            "                self.chk[u]=i",
            "                stack.append(v)",
            "",
            "                break",
            "",
            "            else:",
            "                # 流せなければこの頂点は諦める",
            "                self.chk[u]=itr_end",
            "                stack.pop()",
            "",
            "        # tにたどり着かないなら当然流量0",
            "        else:return 0",
            "",
            "        f=INF",
            "        uvset=[]",
            "",
            "        ##tまでのパスを見つけたら逆へ辿っていき流量の最大をチェックして流していく",
            "        while stack:",
            "            u=stack.pop()",
            "            v,cost,rev=self.edge[u][self.chk[u]]",
            "",
            "            # 経路中の流量のボトルネックを調査",
            "            f=min(f,cost)",
            "",
            "            # 後で更新する",
            "            uvset.append((u,self.chk[u],v,rev))",
            "",
            "        # 順辺の流量を減らす",
            "        for u,i,v,j in uvset:",
            "            self.edge[u][i][1]-=f",
            "            self.edge[v][j][1]+=f",
            "",
            "        return f",
            "",
            "    def Dinic(self,s,t) -> int:",
            "",
            "        self.edge_len=list(map(len,self.edge))",
            "",
            "        Flow=0",
            "        while 1:",
            "            self.D_BFS(s,t)",
            "            if self.depth[t]==INF:return Flow",
            "",
            "            for i in range(self.n):self.chk[i]=0",
            "",
            "            while 1:",
            "                F=self.D_DFS(s,t)",
            "                Flow+=F",
            "            ",
            "                if F<=0:break",
        ],
        "description": "非再帰Dinicクラス化"
    },



    "def Bipartile_Matching():": {
        "prefix": "def Bipartile_Matching():",
        "body": [
            "##二部マッチング",
            "##参考:https://snuke.hatenablog.com/entry/2019/05/07/013609",
            "",
            "def Bipartile_Matching():",
            "",
            "    global root,backpath",
            "",
            "    res=0",
            "    f=True",
            "    while f:",
            "        f=False",
            "        q=deque()",
            "        for i in range(L):",
            "            ##まだマッチング対象が見つかっていなければ",
            "            ##iを始点としてキューに追加",
            "            if L2R[i]==-1:",
            "                root[i]=i",
            "                q.append(i)",
            "",
            "        while q:",
            "            s=q.pop()",
            "",
            "            ##逆辺を辿った先のrootが-1になっていればcontinue",
            "            if ~L2R[root[s]]: continue",
            "            ",
            "            ##始点から接続されている辺を全探索する",
            "            for t in edge[s]:",
            "",
            "                if R2L[t]==-1:",
            "                    ##逆辺が存在する場合は辿っていく",
            "                    while ~t:",
            "                        R2L[t]=s",
            "                        L2R[s],t=t,L2R[s]",
            "                        s=backpath[s]",
            "",
            "                    f=True",
            "                    res+=1",
            "                    break",
            "",
            "                ##仮のtに対するマッチング候補の情報を更新しキューに追加する",
            "                temps=R2L[t]",
            "                if ~backpath[temps]:continue",
            "",
            "                backpath[temps]=s",
            "                root[temps]=root[s]",
            "                q.append(temps)",
            "",
            "",
            "        ##更新があれば逆辺・始点情報を初期化する",
            "        if f:",
            "            backpath=[-1]*L",
            "            root=[-1]*L",
            "",
            "    return res",
            "",
            "",
            "L,R,E=map(int,input().split())",
            "",
            "##辞書にを記録する",
            "edge=dd(list)",
            "for i in range(E):",
            "    a,b=map(int,input().split())",
            "    edge[a].append(b)",
            "    ",
            "##L2R:Lから見たRのマッチングを記録",
            "##R2L:Rから見たLのマッチングを記録",
            "##backpath:L側に逆辺が張られている場合の辿る先",
            "##root:逆辺を考慮したLの始点を記録",
            "",
            "L2R=[-1]*L",
            "R2L=[-1]*R",
            "backpath=[-1]*L",
            "root=[-1]*L",
            "",
            "res=Bipartile_Matching()",
            "print(res)",
        ],
        "description": "二部マッチング"
    },

    "class Bipartile_Matching": {
        "prefix": "class Bipartile_Matching",
        "body": [
            "##二部マッチング",
            "##参考:https://snuke.hatenablog.com/entry/2019/05/07/013609",
            "",
            "",
            "class Bipartile_Matching:",
            "",
            "    def __init__(self,L,R):",
            "",
            "",
            "        ##L2R:Lから見たRのマッチングを記録",
            "        ##R2L:Rから見たLのマッチングを記録",
            "        ##backpath:L側に逆辺が張られている場合の辿る先",
            "        ##root:逆辺を考慮したLの始点を記録",
            "",
            "        self.L=L",
            "        self.R=R",
            "        self.L2R=[-1]*L",
            "        self.R2L=[-1]*R",
            "        self.backpath=[-1]*L",
            "        self.root=[-1]*L",
            "        self.edge=dd(list)",
            "",
            "    def add_edge(self,s,t):",
            "        self.edge[s].append(t)",
            "",
            "",
            "    def match(self):",
            "        res=0",
            "        f=True",
            "        while f:",
            "            f=False",
            "            q=deque()",
            "            for i in range(self.L):",
            "                ##まだマッチング対象が見つかっていなければ",
            "                ##iを始点としてキューに追加",
            "                if self.L2R[i]==-1:",
            "                    self.root[i]=i",
            "                    q.append(i)",
            "",
            "            while q:",
            "                s=q.popleft()",
            "",
            "                ##逆辺を辿った先がすでに決まっていればcontinue",
            "                if ~self.L2R[self.root[s]]:continue",
            "                ",
            "                ##始点から接続されている辺を全探索する",
            "                for t in self.edge[s]:",
            "",
            "                    if self.R2L[t]==-1:",
            "                        ##逆辺が存在する場合は辿っていく",
            "                        while t!=-1:",
            "                            self.R2L[t]=s",
            "                            self.L2R[s],t=t,self.L2R[s]",
            "                            s=self.backpath[s]",
            "",
            "                        f=True",
            "                        res+=1",
            "                        break",
            "",
            "                    ##仮のtに対するマッチング候補の情報を更新しキューに追加する",
            "                    temps=self.R2L[t]",
            "                    if ~self.backpath[temps]:continue",
            "",
            "                    self.backpath[temps]=s",
            "                    self.root[temps]=self.root[s]",
            "                    q.append(temps)",
            "",
            "",
            "            ##更新があれば逆辺・始点情報を初期化する",
            "            if f:",
            "                self.backpath=[-1]*self.L",
            "                self.root=[-1]*self.L",
            "",
            "        return res",
        ],
        "description": "二部マッチングクラス化"
    },


    "def Palindrome_chk(S):": {
        "prefix": "def Palindrome_chk(S):",
        "body": [
            "##文字列の回文判定",
            "def Palindrome_chk(S):",
            "    N=len(S)",
            "",
            "    for i in range(N//2):",
            "        if S[i]!=S[N-i-1]:return False",
            "    return True",
        ],
        "description": "回文判定"
    },

    "groupby": {
        "prefix": "groupby",
        "body": [
            "from itertools import groupby",
            "L=[(k,len(list(g))) for k,g in groupby($1)]",
        ],
        "description": "ランレングス圧縮"
    },

    "RLE": {
        "prefix": "RLE",
        "body": [
            "##ランレングス圧縮",
            "def RLE(S):",
            "    ret=[]",
            "",
            "    for a in S:",
            "        if len(ret) and ret[-1][0]==a:ret[-1][1]+=1",
            "        else:ret.append([a,1])",
            "",
            "    return ret",
        ],
        "description": "ランレングス圧縮"
    },

    "class RollingHash:": {
        "prefix": "class RollingHash:",
        "body": [
             "from random import randint",
            "hmod=(1<<31)-1",
            "hbase1=randint(0,hmod-1)",
            "hbase2=randint(0,hmod-1)",
            "",
            "# ハッシュ化する文字列の最大の長さを定義",
            "HASH_MAX_SIZE=10**6+5",
            "",
            "# pow[i]:baseのi乗を記録",
            "pow1=[0]*(HASH_MAX_SIZE+1)",
            "pow1[0]=1",
            "pow2=[0]*(HASH_MAX_SIZE+1)",
            "pow2[0]=1",
            "",
            "for i in range(HASH_MAX_SIZE):",
            "    pow1[i+1]=pow1[i]*hbase1%hmod",
            "    pow2[i+1]=pow2[i]*hbase2%hmod",
            "",
            "",
            "# \"a\"を1としたindexを返す",
            "def a21(k):return ord(k)-ord(\"a\")+1",
            " ",
            "class RollingHash:",
            " ",
            "    # ローリングハッシュを構成する",
            "    def __init__(self,S):",
            " ",
            "        S=str(S)",
            "        lenS=len(S)",
            " ",
            "        # hash[i]:先頭からi文字目までのハッシュ値を記録",
            "        self.hash1=[0]*(lenS+1)",
            "        self.hash2=[0]*(lenS+1)",
            "        ",
            "        for i,s in enumerate(S):",
            "            self.hash1[i+1]=self.hash1[i]*hbase1+a21(s)",
            "            self.hash1[i+1]%=hmod",
            " ",
            "            self.hash2[i+1]=self.hash2[i]*hbase2+a21(s)",
            "            self.hash2[i+1]%=hmod",
            " ",
            "",
            "    # l文字目からr文字目までのhash値を返す[l,r]",
            "    def hashval(self,l,r):",
            "        ret1=(self.hash1[r]-self.hash1[l]*pow1[r-l])%hmod",
            "        ret2=(self.hash2[r]-self.hash2[l]*pow2[r-l])%hmod",
            "        return (ret1<<32)|ret2",
            "    ",
            "",
            "    # [i1,j1]の後ろにotherの[i2,j2]を結合したhash値を返す",
            "    def concat(self,i1,j1,other,i2,j2):",
            "        pre_ha=self.hashval(i1,j1)",
            "        temp1=pre_ha>>32",
            "        temp2=pre_ha&((1<<32)-1)",
            "",
            "        temp1*=pow1[j2-i2]",
            "        temp1%=hmod",
            "        temp2*=pow2[j2-i2]",
            "        temp2%=hmod",
            "",
            "        pos_ha=other.hashval(i2,j2)",
            "",
            "        temp1+=pos_ha>>32",
            "        temp1%=hmod",
            "        temp2+=pos_ha&((1<<32)-1)",
            "        temp2%=hmod",
            "",
            "        return (temp1<<32)|temp2",
        ],
        "description": "ローリングハッシュ"
    },

    "class ZoblistHash": {
        "prefix": "class ZoblistHash",
        "body": [
            "from random import randrange",
            "MOD=(1<<61)-1",
            "",
            "class ZoblistHash:",
            "",
            "    # N以下の数字をハッシュ化する",
            "    def __init__(self,N):",
            "        self.HashTable=[randrange(1,MOD-1) for _ in range(N+1)]",
        ],
        "description": "ZobristHash"
    },


    "def Manacher(S):": {
        "prefix": "def Manacher(S):",
        "body": [
            "# Manacher:文字列のインデックスに対して回文となっている範囲の半径を返す",
            "# 奇数長のみだがダミー文字を挟むことで偶数長にも対応できる",
            "def Manacher(S):",
            "",
            "    N=len(S)",
            "    i,j=0,0",
            "    ret=[0]*N",
            "    while i<N:",
            "        while i-j>=0 and i+j<N and S[i-j]==S[i+j]:j+=1",
            "        ret[i]=j",
            "",
            "        k=1",
            "        while i>=k and k+ret[i-k]<j:",
            "            ret[i+k]=ret[i-k]",
            "            k+=1",
            "",
            "        i+=k",
            "        j-=k",
            "",
            "    return ret",
        ],
        "description": "Manacher"
    },

    "def edit_dist": {
        "prefix": "def edit_dist",
        "body": [
            "def edit_dist(S,T):",
            "",
            "    sl=len(S)",
            "    tl=len(T)",
            "",
            "    DP=[[INF for _ in range(tl+1)] for _ in range(sl+1)]",
            "",
            "    for i in range(sl+1):DP[i][0]=i",
            "    for j in range(tl+1):DP[0][j]=j",
            "",
            "    for i in range(sl):",
            "        for j in range(tl):",
            "            if S[i]==T[j]:c=0",
            "            else:c=1",
            "",
            "            DP[i+1][j+1]=min(DP[i+1][j]+1,DP[i][j+1]+1,DP[i][j]+c)",
            "",
            "    return DP[sl][tl]",
        ],
        "description": "レーベンシュタイン距離、編集距離"
    },


    "def FFTConvolve": {
        "prefix": "def FFTConvolve",
        "body": [
            "from cmath import exp,pi",
            "",
            "# O(NlogN)のFFTを用いた畳み込み",
            "def FFTConvolve(A,B):",
            "    ",
            "",
            "    def Cooley_Tukey_FFT(sig,inv=False):",
            "",
            "        # バタフライ演算用の並び替え",
            "        for i,j in enumerate(op_order):",
            "            if i<j:sig[i],sig[j]=sig[j],sig[i]",
            "",
            "        # L回バタフライ演算する",
            "        for l in range(1,L+1):",
            "",
            "            # グループ内の数",
            "            g=1<<l",
            "            # グループ内の数の半分",
            "            hg=g>>1",
            "            # グループの数",
            "            gn=N>>l",
            "",
            "",
            "            # i個グループを作る",
            "            for i in range(gn):",
            "",
            "                # グループの先頭要素",
            "                gbase=g*i",
            "",
            "                # retのうちhg以降のものは複素数乗算を行う",
            "                # 逆変換なら複素共役をかける",
            "                if inv:",
            "                    for j in range(hg):sig[gbase+hg+j]*=z[gn*j].conjugate()",
            "                else:",
            "                    for j in range(hg):sig[gbase+hg+j]*=z[gn*j]",
            "                ",
            "                # グループ内の2**l個をバタフライ演算する",
            "                # 前半は足すだけ",
            "                # 後半は前の値を引く",
            "                for j in range(hg):",
            "                    p=gbase+j",
            "                    q=gbase+(j+hg)%g",
            "",
            "                    # バタフライ演算本体",
            "                    sig[p],sig[q]=sig[p]+sig[q],sig[p]-sig[q]",
            "",
            "",
            "        # 逆変換ならNで割る",
            "        if inv:",
            "            for i in range(N):sig[i]/=N",
            "",
            "",
            "        return sig",
            "",
            "    # Lビットの数列を逆転して並べる",
            "    # O(NlogN)のはず",
            "    def bit_reverse(L):",
            "",
            "        if N==1:return [0]",
            "",
            "        ret=[0]*N",
            "        for i in range(0,N,2):",
            "",
            "            temp=0",
            "            for j in range(L):",
            "                if i&(1<<j):temp+=1<<(L-j-1)",
            "",
            "            ret[i]=temp",
            "            ret[i+1]=temp+N//2",
            "",
            "        return ret",
            "",
            "",
            "    # 各関数内で使う変数の準備",
            "",
            "    # 最低限必要なCの長さ",
            "    N=len(A)+len(B)-1",
            "    preN=N",
            "",
            "    # 2べきに合わせる",
            "    L=N.bit_length()",
            "    if N.bit_count()>1:N=1<<L",
            "    else:L-=1",
            "",
            "    # 単位円上のexpを事前計算",
            "    z=[0]*(N+1)",
            "    z[0]=1",
            "    f=exp(((-2*pi)*1j/N))",
            "    for i in range(1,N+1):z[i]=z[i-1]*f",
            "",
            "    # ビット反転列を用意",
            "    op_order=bit_reverse(L)",
            "",
            "    # ゼロ埋め",
            "    pA=[0]*(N-len(A))",
            "    pB=[0]*(N-len(B))",
            "",
            "",
            "    # 周波数領域に変換",
            "    FA=Cooley_Tukey_FFT(A+pA)",
            "    FB=Cooley_Tukey_FFT(B+pB)",
            "",
            "",
            "    # 周波数領域で積をとる",
            "    FC=[0]*N",
            "    for i in range(N):FC[i]=FA[i]*FB[i]",
            "",
            "",
            "    # 逆変換で時間領域へ変換",
            "    C=Cooley_Tukey_FFT(FC,True)",
            "",
            "    return C[:preN]",

        ],
        "description": "FFT"
    },

    "数論変換FFT": {
        "prefix": "def NTT",
        "body": [
            "# O(NlogN)のFFTを用いた畳み込み",
            "# 数論変換バージョン",
            "def NTT(A,B,ROOT=3,MOD=998244353):",
            "",
            "    # MOD-1をビット表記した際に最初に1が現れる場所を返す",
            "    m1=MOD-1",
            "    ffs=(-m1&m1).bit_length()",
            "",
            "    # (MOD-1)//(1<<ffs)",
            "    pw=m1>>(ffs-1)",
            "",
            "",
            "    def Cooley_Tukey_FFT(sig,inv=False):",
            "",
            "        # バタフライ演算用の並び替え",
            "        for i,j in enumerate(op_order):",
            "            if i<j:sig[i],sig[j]=sig[j],sig[i]",
            "",
            "        # L回バタフライ演算する",
            "        for l in range(1,L+1):",
            "",
            "            # グループ内の数",
            "            g=1<<l",
            "            # グループ内の数の半分",
            "            hg=g>>1",
            "            # グループの数",
            "            gn=N>>l",
            "",
            "            # 回転子の1回転分の値",
            "            if inv:r=invz[l]",
            "            else:r=z[l]",
            "",
            "            # i個グループを作る",
            "            for i in range(gn):",
            "",
            "                # グループの先頭要素",
            "                gbase=g*i",
            "",
            "                # 回転子",
            "                rot=1",
            "",
            "                # retのうちhg以降のものは複素数乗算を行う",
            "                # 逆変換なら複素共役をかける",
            "                for j in range(hg):",
            "                    q=gbase+j+hg",
            "                    sig[q]*=rot",
            "                    sig[q]%=MOD",
            "",
            "                    rot*=r",
            "                    rot%=MOD",
            "",
            "",
            "                # グループ内の2**l個をバタフライ演算する",
            "                # 前半は足すだけ",
            "                # 後半は前の値を引く",
            "                for j in range(hg):",
            "                    p=gbase+j",
            "                    q=gbase+j+hg",
            "",
            "                    # バタフライ演算本体",
            "                    sig[p],sig[q]=sig[p]+sig[q],sig[p]-sig[q]",
            "                    sig[p]%=MOD",
            "                    sig[q]%=MOD",
            "",
            "        # 逆変換ならNで割る",
            "        if inv:",
            "            for i in range(N):",
            "                sig[i]*=invN",
            "                sig[i]%=MOD",
            "",
            "",
            "        return sig",
            "",
            "    # Lビットの数列を逆転して並べる",
            "    # O(NlogN)のはず",
            "    def bit_reverse(L):",
            "",
            "        if N==1:return [0]",
            "",
            "        ret=[0]*N",
            "        for i in range(0,N,2):",
            "",
            "            temp=0",
            "            for j in range(L):",
            "                if i&(1<<j):temp+=1<<(L-j-1)",
            "",
            "            ret[i]=temp",
            "            ret[i+1]=temp+(N>>1)",
            "",
            "        return ret",
            "",
            "",
            "    # 各関数内で使う変数の準備",
            "",
            "    # 最低限必要なCの長さ",
            "    N=len(A)+len(B)-1",
            "    preN=N",
            "",
            "    # 2べきに合わせる",
            "    L=N.bit_length()",
            "    if N.bit_count()>1:N=1<<L",
            "    else:L-=1",
            "",
            "    invN=pow(N,-1,MOD)",
            "",
            "    # N以下の累乗根を求める",
            "    # z[0]:1乗根",
            "    # 998244353=119*2**23+1より",
            "    # 2の23乗根まで求める",
            "    w=pow(ROOT,pw,MOD)",
            "",
            "    z=[0]*(ffs+1)",
            "    z[0]=1",
            "    z[1]=w",
            "",
            "    for i in range(1,ffs):z[i+1]=(z[i]*z[i])%MOD",
            "    z.reverse()",
            "",
            "    # 逆変換用",
            "    invz=[0]*(ffs+1)",
            "    for i in range(ffs):invz[i]=pow(z[i],-1,MOD)",
            "",
            "    # ビット反転列を用意",
            "    op_order=bit_reverse(L)",
            "",
            "    # ゼロ埋め",
            "    pA=[0]*(N-len(A))",
            "    pB=[0]*(N-len(B))",
            "",
            "",
            "    # 周波数領域に変換",
            "    FA=Cooley_Tukey_FFT(A+pA)",
            "    FB=Cooley_Tukey_FFT(B+pB)",
            "",
            "",
            "    # 周波数領域で積をとる",
            "    FC=[0]*N",
            "    for i in range(N):",
            "        FC[i]=FA[i]*FB[i]",
            "        FC[i]%=MOD",
            "",
            "    # 逆変換で時間領域へ変換",
            "    C=Cooley_Tukey_FFT(FC,True)",
            "",
            "    return C[:preN]",
        ],
        "description": "数論変換"
    },


    "bitDP": {
        "prefix": "bitDP",
        "body": [
            "bitDP=[[INF for _ in range(1<<N)]for _ in range(N)]",
            "for i in range(N):bitDP[i][1<<i]=0",
            "",
            "for s in range(1<<N):",
            "    for i in range(N):",
            "        if s&(1<<i)==0:continue",
            "        if bitDP[i][s]==INF:continue",
            "",
            "        for j in range(N):",
            "            if s&(1<<j):continue",
            "            if DP[i][j]==INF:continue",
            "",
            "            bitDP[j][s|(1<<j)]=min(bitDP[j][s|(1<<j)],$1)",
        ],
        "description": "bitDPテンプレ"
    },

    "class Doubling:": {
        "prefix": "class Doubling:",
        "body": [
            "class Doubling:",
            "",
            "",
            "    # 要素数nと遷移回数の上限k(10**18なら2**60未満なのでk=60)を入力",
            "    # 10**9ならk=30,10**12ならk=40,10**15ならk=50",
            "    def __init__(self,n,k=60):",
            "        self.dp=[[-1 for _ in range(n)]for _ in range(k+1)]",
            "        self.n=n",
            "        self.k=k",
            "",
            "    # 初期遷移を入力してDPテーブル前計算を行う",
            "    def build(self):",
            "        ",
            "        # 初期遷移を入力する",
            "        for i in range(self.n):",
            "            self.dp[0][i]=",
            "",
            "",
            "        for k in range(self.k):",
            "            for i in range(self.n):",
            "                self.dp[k+1][i]=self.dp[k][self.dp[k][i]]",
            "",
            "    # i項目をm回遷移させたときの値を取得",
            "    def get(self,i,m):",
            "",
            "        ret=i",
            "",
            "        for j in range(self.k):",
            "            if m&(1<<j):",
            "                ret=self.dp[j][ret]",
            "",
            "        return ret",
        ],
        "description": "ダブリング"
    },

}
