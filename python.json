{
	// Place your snippets for python here. Each snippet is defined under a snippet name and has a prefix, body and 
	// description. The prefix is what is used to trigger the snippet and the body will be expanded and inserted. Possible variables are:
	// $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. Placeholders with the 
	// same ids are connected.
	// Example:
	// "Print to console": {
	// 	"prefix": "log",
	// 	"body": [
	// 		"console.log('$1');",
	// 		"$2"
	// 	],
	// 	"description": "Log output to console"
	// }


	"整数入力高速化": {
		"prefix": "import sys input",
		"body": [		
			"import sys",
			"input = sys.stdin.buffer.readline",
		],
		"description": "整数入力高速化"
	},

	"入力高速化": {
		"prefix": "import sys input",
		"body": [		
			"import sys",
			"input = lambda: sys.stdin.readline().rstrip()",
		],
		"description": "入力高速化"
	},
    
	"整数入力": {
		"prefix": "int(input())",
		"body": [
			"int(input())",
		],
		"description": "整数入力"
	},

	"空白区切り整数入力": {
		"prefix": "map(int,input().split())",
		"body": [
			"map(int,input().split())",
		],
		"description": "空白区切り整数入力"
	},

	"空白区切り文字列→リスト": {
		"prefix": "list(input().split())",
		"body": [
			"list(input().split())",
		],
		"description": "空白区切り文字列→リスト"
	},

	"空白区切り整数入力→リスト": {
		"prefix": "list(map(int, input().split()))",
		"body": [
			"list(map(int, input().split()))",
		],
		"description": "空白区切り整数入力→リスト"
	},

	"文字列→一字ずつリスト化": {
		"prefix": "list(input())",
		"body": [
			"list(input())",
		],
		"description": "文字列→一字ずつリスト化"
	},

	"数字列→一字ずつリスト化": {
		"prefix": "list(map(int,input()))",
		"body": [
			"list(map(int,input()))",
		],
		"description": "数字列→一字ずつリスト化"
	},

	"N行1列の文字列入力": {
		"prefix": "[input() for _ in range($1N)",
		"body": [
			"[input() for _ in range($1N)",
		],
		"description": "N行1列の文字列入力"
	},

	"N行1列の整数入力": {
		"prefix": "[int(input()) for _ in range($1N)",
		"body": [
			"[int(input()) for _ in range($1N)",
		],
		"description": "N行1列の整数入力"
	},

	"N行N列の文字列入力": {
		"prefix": "[input().split()",
		"body": [
			"[input().split() for l in range($1N)",
		],
		"description": "N行N列の文字列入力"
	},

	"N行N列の整数入力": {
		"prefix": "[list(map(int, input().split()))",
		"body": [
			"[list(map(int, input().split()))  for _ in range($1N)",
		],
		"description": "N行N列の整数入力"
	},

    "def makevec(a,*n):": {
        "prefix": "def makevec(a,*n):",
        "body": [
            "def makevec(a,*n):",
            "    if len(n)==1:",
            "        return [a for _ in range(n[0])]",
            "    else:",
            "        return [makevec(a,*n[1:]) for _ in range(n[0])]",
        ],
        "description": "初期値aの多次元行列を生成"
    },	

    "cf": {
        "prefix": "cf",
        "body": [
            "def solve():",
            "    res=0",
            "",
            "",
            "    print(res)",
            "    return",
            "",
            "T=int(input())",
            "for _ in range(T):solve()",
        ],
        "description": "codeforces"
    },



	"GCJtemplate": {
		"prefix": "GCJ",
		"body": [
			"def solve($1):",
			"	ans=0",
			"",
			"	return ans",
			"",
			"T=int(input())",
			"for i in range(1,T+1):",
			"",	
			"	ans=solve($1)",
			"	print(\"Case #\"+str(i)+\":\",ans)",
		],
		"description": "GCJtemplate"
	},

	"文字リスト→出力": {
		"prefix": "print(''.join(S))",
		"body": [
			"print(''.join($1S))",
		],
		"description": "文字リスト→出力"
	},

	"整数リスト→出力": {
		"prefix": "print(''.join(map(str,A)))",
		"body": [
			"print(''.join(map(str,$1A)))",
		],
		"description": "整数リスト→出力"
	},

	"整数リスト→空白出力": {
		"prefix": "print(' '.join(map(str,A))",
		"body": [
			"print(' '.join(map(str,$1A)))",
		],
		"description": "整数リスト→空白出力"
	},


	"整数リスト→改行出力": {
		"prefix": "print('\n'.join(map(str,S)))",
		"body": [
			"print('\n'.join(map(str,$1S)))",
		],
		"description": "整数リスト→改行出力"
	},


	"for i in range(N):": {
		"prefix": "for i in range(N)",
		"body": [
			"for i in range($1N)",
		],
		"description": "0からN-1までのfor文"
	},

	"defaultdict as dd": {
		"prefix": "from collections import defaultdict as dd",
		"body": [
			"from collections import defaultdict as dd",
		],
		"description": "defaultdict"
	},	
	
	"入れ子dd": {
		"prefix": "dd(lambda:dd(int))",
		"body": [
			"dd(lambda:dd(int))",
		],
		"description": "入れ子dd"
	},	

    "無限dd": {
        "prefix": "recdd",
        "body": [
            "from collections import defaultdict as dd",
            "def recdd():",
            "    return dd(recdd)",
        ],
        "description": "無限defaultdict"
    },


	"dd初期値指定": {
		"prefix": "dd(lambda:-1)",
		"body": [
			"dd(lambda:-1)",
		],
		"description": "dd初期値指定"
	},	

	"itertools as itr": {
		"prefix": "import itertools as itr",
		"body": [
			"import itertools as itr",
		],
		"description": "itertools"
	},	

	"from copy import copy,deepcopy": {
		"prefix": "from copy import copy,deepcopy",
		"body": [
			"from copy import copy,deepcopy",
		],
		"description": "copy"
	},	


	"collections as col ": {
		"prefix": "import collections as col",
		"body": [
			"import collections as col",
		],
		"description": "collections"
	},	
	
	"functools": {
		"prefix": "import functools",
		"body": [
			"import functools",
		],
		"description": "functools"
	},	

	"from decimal import Decimal": {
		"prefix": "from decimal import Decimal",
		"body": [
			"from decimal import Decimal",
		],
		"description": "decimal"
	},	

	" from fractions import Fraction as F": {
        "prefix": " from fractions import Fraction as F",
        "body": [
            "from fractions import Fraction as F",
        ],
        "description": "分数モジュール"
    },


	"setrecursionlimit": {
		"prefix": "import sys",
		"body": [
			"import sys",
			"sys.setrecursionlimit(10**8)",
		],
		"description": "setrecursionlimit"
	},	

	"deque": {
		"prefix": "from collections import deque",
		"body": [
			"from collections import deque",
		],
		"description": "deque"
	},	

	"bisect": {
		"prefix": "from bisect import bisect",
		"body": [
			"from bisect import bisect",
		],
		"description": "bisect"
	},	
	
	"heapq": {
		"prefix": "from heapq import heapify,heappop as hpop,heappush as hpush",
		"body": [
			"from heapq import heapify,heappop as hpop,heappush as hpush",
		],
		"description": "heapq"
	},	


	"numpy": {
		"prefix": "import numpy as np",
		"body": [
			"import numpy as np",
		],
		"description": "numpy"
	},	


	"numba": {
		"prefix": "from numba import njit,i8",
		"body": [
			"from numba import njit,i8",
		],
		"description": "numba"
	},	

	"njit": {
		"prefix": "@njit((),cache=True)",
		"body": [
			"@njit(($1),cache=True)",
		],
		"description": "njit"
	},
    "SortedSet": {
        "prefix": "SortedSet",
        "body": [
            "# https://github.com/tatyam-prime/SortedSet/blob/main/SortedSet.py",
            "import math",
            "from bisect import bisect_left, bisect_right",
            "from typing import Generic, Iterable, Iterator, TypeVar, Union, List",
            "T = TypeVar('T')",
            "",
            "class SortedSet(Generic[T]):",
            "    BUCKET_RATIO = 50",
            "    REBUILD_RATIO = 170",
            "",
            "    def _build(self, a=None) -> None:",
            "        \"Evenly divide `a` into buckets.\"",
            "        if a is None: a = list(self)",
            "        size = self.size = len(a)",
            "        bucket_size = int(math.ceil(math.sqrt(size / self.BUCKET_RATIO)))",
            "        self.a = [a[size * i // bucket_size : size * (i + 1) // bucket_size] for i in range(bucket_size)]",
            "    ",
            "    def __init__(self, a: Iterable[T] = []) -> None:",
            "        \"Make a new SortedSet from iterable. / O(N) if sorted and unique / O(N log N)\"",
            "        a = list(a)",
            "        if not all(a[i] < a[i + 1] for i in range(len(a) - 1)):",
            "            a = sorted(set(a))",
            "        self._build(a)",
            "",
            "    def __iter__(self) -> Iterator[T]:",
            "        for i in self.a:",
            "            for j in i: yield j",
            "",
            "    def __reversed__(self) -> Iterator[T]:",
            "        for i in reversed(self.a):",
            "            for j in reversed(i): yield j",
            "    ",
            "    def __len__(self) -> int:",
            "        return self.size",
            "    ",
            "    def __repr__(self) -> str:",
            "        return \"SortedSet\" + str(self.a)",
            "    ",
            "    def __str__(self) -> str:",
            "        s = str(list(self))",
            "        return \"{\" + s[1 : len(s) - 1] + \"}\"",
            "",
            "    def _find_bucket(self, x: T) -> List[T]:",
            "        \"Find the bucket which should contain x. self must not be empty.\"",
            "        for a in self.a:",
            "            if x <= a[-1]: return a",
            "        return a",
            "",
            "    def __contains__(self, x: T) -> bool:",
            "        if self.size == 0: return False",
            "        a = self._find_bucket(x)",
            "        i = bisect_left(a, x)",
            "        return i != len(a) and a[i] == x",
            "",
            "    def add(self, x: T) -> bool:",
            "        \"Add an element and return True if added. / O(√N)\"",
            "        if self.size == 0:",
            "            self.a = [[x]]",
            "            self.size = 1",
            "            return True",
            "        a = self._find_bucket(x)",
            "        i = bisect_left(a, x)",
            "        if i != len(a) and a[i] == x: return False",
            "        a.insert(i, x)",
            "        self.size += 1",
            "        if len(a) > len(self.a) * self.REBUILD_RATIO:",
            "            self._build()",
            "        return True",
            "",
            "    def discard(self, x: T) -> bool:",
            "        \"Remove an element and return True if removed. / O(√N)\"",
            "        if self.size == 0: return False",
            "        a = self._find_bucket(x)",
            "        i = bisect_left(a, x)",
            "        if i == len(a) or a[i] != x: return False",
            "        a.pop(i)",
            "        self.size -= 1",
            "        if len(a) == 0: self._build()",
            "        return True",
            "    ",
            "    def lt(self, x: T) -> Union[T, None]:",
            "        \"Find the largest element < x, or None if it doesn't exist.\"",
            "        for a in reversed(self.a):",
            "            if a[0] < x:",
            "                return a[bisect_left(a, x) - 1]",
            "",
            "    def le(self, x: T) -> Union[T, None]:",
            "        \"Find the largest element <= x, or None if it doesn't exist.\"",
            "        for a in reversed(self.a):",
            "            if a[0] <= x:",
            "                return a[bisect_right(a, x) - 1]",
            "",
            "    def gt(self, x: T) -> Union[T, None]:",
            "        \"Find the smallest element > x, or None if it doesn't exist.\"",
            "        for a in self.a:",
            "            if a[-1] > x:",
            "                return a[bisect_right(a, x)]",
            "",
            "    def ge(self, x: T) -> Union[T, None]:",
            "        \"Find the smallest element >= x, or None if it doesn't exist.\"",
            "        for a in self.a:",
            "            if a[-1] >= x:",
            "                return a[bisect_left(a, x)]",
            "    ",
            "    def __getitem__(self, x: int) -> T:",
            "        \"Return the x-th element, or IndexError if it doesn't exist.\"",
            "        if x < 0: x += self.size",
            "        if x < 0: raise IndexError",
            "        for a in self.a:",
            "            if x < len(a): return a[x]",
            "            x -= len(a)",
            "        raise IndexError",
            "    ",
            "    def index(self, x: T) -> int:",
            "        \"Count the number of elements < x.\"",
            "        ans = 0",
            "        for a in self.a:",
            "            if a[-1] >= x:",
            "                return ans + bisect_left(a, x)",
            "            ans += len(a)",
            "        return ans",
            "",
            "    def index_right(self, x: T) -> int:",
            "        \"Count the number of elements <= x.\"",
            "        ans = 0",
            "        for a in self.a:",
            "            if a[-1] > x:",
            "                return ans + bisect_right(a, x)",
            "            ans += len(a)",
            "        return ans",
        ],
        "description": ""
    },

    "SortedMultiset": {
        "prefix": "SortedMultiset",
        "body": [
            "# https://github.com/tatyam-prime/SortedSet/blob/main/SortedMultiset.py",
            "import math",
            "from bisect import bisect_left, bisect_right, insort",
            "from typing import Generic, Iterable, Iterator, TypeVar, Union, List",
            "T = TypeVar('T')",
            "",
            "class SortedMultiset(Generic[T]):",
            "    BUCKET_RATIO = 50",
            "    REBUILD_RATIO = 170",
            "",
            "    def _build(self, a=None) -> None:",
            "        \"Evenly divide `a` into buckets.\"",
            "        if a is None: a = list(self)",
            "        size = self.size = len(a)",
            "        bucket_size = int(math.ceil(math.sqrt(size / self.BUCKET_RATIO)))",
            "        self.a = [a[size * i // bucket_size : size * (i + 1) // bucket_size] for i in range(bucket_size)]",
            "    ",
            "    def __init__(self, a: Iterable[T] = []) -> None:",
            "        \"Make a new SortedMultiset from iterable. / O(N) if sorted / O(N log N)\"",
            "        a = list(a)",
            "        if not all(a[i] <= a[i + 1] for i in range(len(a) - 1)):",
            "            a = sorted(a)",
            "        self._build(a)",
            "",
            "    def __iter__(self) -> Iterator[T]:",
            "        for i in self.a:",
            "            for j in i: yield j",
            "",
            "    def __reversed__(self) -> Iterator[T]:",
            "        for i in reversed(self.a):",
            "            for j in reversed(i): yield j",
            "    ",
            "    def __len__(self) -> int:",
            "        return self.size",
            "    ",
            "    def __repr__(self) -> str:",
            "        return \"SortedMultiset\" + str(self.a)",
            "    ",
            "    def __str__(self) -> str:",
            "        s = str(list(self))",
            "        return \"{\" + s[1 : len(s) - 1] + \"}\"",
            "",
            "    def _find_bucket(self, x: T) -> List[T]:",
            "        \"Find the bucket which should contain x. self must not be empty.\"",
            "        for a in self.a:",
            "            if x <= a[-1]: return a",
            "        return a",
            "",
            "    def __contains__(self, x: T) -> bool:",
            "        if self.size == 0: return False",
            "        a = self._find_bucket(x)",
            "        i = bisect_left(a, x)",
            "        return i != len(a) and a[i] == x",
            "",
            "    def count(self, x: T) -> int:",
            "        \"Count the number of x.\"",
            "        return self.index_right(x) - self.index(x)",
            "",
            "    def add(self, x: T) -> None:",
            "        \"Add an element. / O(√N)\"",
            "        if self.size == 0:",
            "            self.a = [[x]]",
            "            self.size = 1",
            "            return",
            "        a = self._find_bucket(x)",
            "        insort(a, x)",
            "        self.size += 1",
            "        if len(a) > len(self.a) * self.REBUILD_RATIO:",
            "            self._build()",
            "",
            "    def discard(self, x: T) -> bool:",
            "        \"Remove an element and return True if removed. / O(√N)\"",
            "        if self.size == 0: return False",
            "        a = self._find_bucket(x)",
            "        i = bisect_left(a, x)",
            "        if i == len(a) or a[i] != x: return False",
            "        a.pop(i)",
            "        self.size -= 1",
            "        if len(a) == 0: self._build()",
            "        return True",
            "",
            "    def lt(self, x: T) -> Union[T, None]:",
            "        \"Find the largest element < x, or None if it doesn't exist.\"",
            "        for a in reversed(self.a):",
            "            if a[0] < x:",
            "                return a[bisect_left(a, x) - 1]",
            "",
            "    def le(self, x: T) -> Union[T, None]:",
            "        \"Find the largest element <= x, or None if it doesn't exist.\"",
            "        for a in reversed(self.a):",
            "            if a[0] <= x:",
            "                return a[bisect_right(a, x) - 1]",
            "",
            "    def gt(self, x: T) -> Union[T, None]:",
            "        \"Find the smallest element > x, or None if it doesn't exist.\"",
            "        for a in self.a:",
            "            if a[-1] > x:",
            "                return a[bisect_right(a, x)]",
            "",
            "    def ge(self, x: T) -> Union[T, None]:",
            "        \"Find the smallest element >= x, or None if it doesn't exist.\"",
            "        for a in self.a:",
            "            if a[-1] >= x:",
            "                return a[bisect_left(a, x)]",
            "    ",
            "    def __getitem__(self, x: int) -> T:",
            "        \"Return the x-th element, or IndexError if it doesn't exist.\"",
            "        if x < 0: x += self.size",
            "        if x < 0: raise IndexError",
            "        for a in self.a:",
            "            if x < len(a): return a[x]",
            "            x -= len(a)",
            "        raise IndexError",
            "",
            "    def index(self, x: T) -> int:",
            "        \"Count the number of elements < x.\"",
            "        ans = 0",
            "        for a in self.a:",
            "            if a[-1] >= x:",
            "                return ans + bisect_left(a, x)",
            "            ans += len(a)",
            "        return ans",
            "",
            "    def index_right(self, x: T) -> int:",
            "        \"Count the number of elements <= x.\"",
            "        ans = 0",
            "        for a in self.a:",
            "            if a[-1] > x:",
            "                return ans + bisect_right(a, x)",
            "            ans += len(a)",
            "        return ans",
        ],
        "description": "SortedMultiset"
    },



    "sys.stdin.buffer.read": {
        "prefix": "sys.stdin.buffer.read",
        "body": [
            "read = sys.stdin.buffer.read",
            "readline = sys.stdin.buffer.readline",
            "readlines = sys.stdin.buffer.readlines",
        ],
        "description": "buffer系読み込み"
    },


	"標準入力": {
		"prefix": "stdinput",
		"body": [
			"################################################",
			"################################################",
			"import io",
			"import sys",
			"",
			"_INPUT = \"\"\"\\",
			"$1",
			"\"\"\"",
			"sys.stdin = io.StringIO(_INPUT)",
			"sys.stdin.buffer = io.BytesIO(_INPUT.encode('ascii'))",
			"################################################",
			"################################################",
			"",
			"import sys",
			"input = lambda: sys.stdin.readline().rstrip()",
			"",
			"",
			"$2",
		],
		"description": "標準入力"
	},	

	"INF": {
		"prefix": "INF",
		"body": [
			"float('INF')",
		],
		"description": "INF"
	},

	"MOD=998244353": {
		"prefix": "MOD=998244353",
		"body": [
			"MOD=998244353",
		],
		"description": "MOD=998244353"
	},

	"MOD=10**9+7": {
		"prefix": "MOD=10**9+7",
		"body": [
			"MOD=10**9+7",
		],
		"description": "MOD=10**9+7"
	},

	"round": {
		"prefix": "round=lambda x:(x*2+1)//2",
		"body": [
			"round=lambda x:int((x*2+1)//2)",
		],
		"description": "roundを四捨五入にする"
	},	

	
	"popcount": {
		"prefix": "def popcount(N)",
		"body": [
			"def popcount(N):",
    		"return bin(N).count('1')",
		],
		"description": "2進数に直したときのon-bitを数える"
	},	

	"4方向カーソル": {
		"prefix": "cur=((1,0),(0,1),(-1,0),(0,-1))",
		"body": [
			"cur=((1,0),(0,1),(-1,0),(0,-1))",
		],
		"description": "4方向カーソル"
	},

	"8方向カーソル": {
		"prefix": "cur=((1,0),(1,1),(0,1),(-1,1),(-1,0),(-1,-1),(0,-1),(1,-1))",
		"body": [
			"cur=((1,0),(1,1),(0,1),(-1,1),(-1,0),(-1,-1),(0,-1),(1,-1))",
		],
		"description": "8方向カーソル"
	},

	"N行N列空リスト": {
		"prefix": "[[None] * N for i in range(N)]",
		"body": [
			"[[None] * N for i in range($1N)]",
			"$2",
		],
		"description": "N行N列空リスト"
	},	

	"降順sort": {
		"prefix": "sorted()",
		"body": [
			"sorted($1)",
		],
		"description": "降順sort"
	},

	"昇順sort": {
		"prefix": "sorted(,reverse=True)",
		"body": [
			"sorted($1,reverse=True)",
		],
		"description": "昇順sort"
	},

	"多次元sort": {
		"prefix": "sorted(A, reverse=True, key=lambda x: x[$11])",
		"body": [
			"sorted($1A, reverse=$2True, key=lambda x: x[$3])",
		],
		"description": "多次元sort"
	},

	"exit(0)": {
		"prefix": "exit(0)",
		"body": [
			"exit(0)",
		],
		"description": "exit(0)"
	},

	"unionfind": {
		"prefix": "unionfind",
		"body": [
			"import sys",
			"sys.setrecursionlimit(10**8)",
			"",
			"def find(x):",
			"	if par[x]!=x:",
			"		par[x]=find(par[x])" ,
			"	return par[x]",
			"",
			"def union(a,b):",
			"	a=find(a)",
			"	b=find(b)",
			"	if a==b:",
			"		return",
			"	if rank[a]<rank[b]:",
			"		a,b=b,a",
			"",
			"	par[b]=a",
			"	rank[a]+=rank[b]",
			"	rank[b]=rank[a]",
			"",
			"	return",
			"",
			"",
			"par=(list(range(N+1)))",
			"rank=[1 for _ in range(N+1)]",
		],
		"description": "unionfind"
	},
	"lcm(a,b)": {
		"prefix": "lcm(a,b)",
		"body": [
			"import math",
			"def lcm(a,b):",
			"	return (a*b)//math.gcd(a,b)",
		],
		"description": "lcm"
	},
	"comb(a,b)": {
		"prefix": "comb(a,b)",
		"body": [
			"from math import factorial",
			"def comb(n,r):",
			"	return factorial(n)//(factorial(n-r)*factorial(r))",
		],
		"description": "組合せ"
	},
	"extgcd(*n)": {
		"prefix": "extgcd(*n)",
		"body": [
			"from functools import reduce",
			"from math import gcd",
			"def extgcd(*n):",
			"	return reduce(gcd,n)",
		],
		"description": "3引数以上のGCD"
	},

	"list(map(lambda))": {
		"prefix": "list(map(lambda x:x-1",
		"body": [
			"$1=list(map(lambda x:x-1,$1))",
		],
		"description": "リストの各要素を-1する"
	},

	"ビット全探索": {
		"prefix": "itr.product(range(2),repeat=N)",
		"body": [
			"itr.product(range(2),repeat=N)",
		],
		"description": "ビット全探索用イテレータ"
	},


	"めぐる式二分探索": {
		"prefix": "def meguru_bisearch",
		"body": [
			"def judge(a):",
			"",
			"##ここに判定条件を書く",
			"	if :",
			"		return 1",
			"	else:",
			"		return 0",
			"",
			"##ng,okの条件に気をつける",
			"def meguru_bisearch(ng, ok):",
			"	while abs(ok-ng)>1:",
			"		mid=(ok+ng)//2",
			"		if judge(mid):",
			"			ok=mid",
			"		else:",
			"			ng=mid",
			"	return ok",
		],
		"description": "めぐる式二分探索"
	},

	"三分探索": {
		"prefix": "def trisearch",
		"body": [
			"def judge(c1,c2):",
			"",
			"##ここに判定条件を書く",
			"	if :",
			"		return 1",
			"	else:",
			"		return 0",
			"",
			"def trisearch(low, high,N):",
			"",
			"	##許容誤差をepsとする",
			"	eps=",
			"",
			"	while abs(high-low)>eps:",
			"		c1=(high+2*low)/3",
			"		c2=(2*high+low)/3",
			"		if judge(c1,c2):",
			"			low=c1",
			"		else:",
			"			high=c2",
			"	return low",
		],
		"description": "三分探索"
	},


	"lru_cache自動メモ化": {
		"prefix": "from functools import lru_cache",
		"body": [
			"from functools import lru_cache",
			"",
			"@lru_cache(maxsize=None)",
		],
		"description": "自動メモ化"
	},

	"深さ優先探索(再帰)": {
		"prefix": "def dfs(edge,k)",
		"body": [
			"from collections import defaultdict as dd",
			"",
			"##再帰を使ったDFS",
			"##行きがけの順番を配列d、帰りがけの順番を配列fに記録",
			"",
			"",
			"def dfs(edge,k):",
			"",
			"##行きがけで処理するときはこの辺でやる",
			"",
			"	global cnt",
			"	cnt+=1",
			"	d[k]=cnt",
			"	for i in edge[k]:",
			"		if d[i]!=-1:",
			"			continue",
			"		dfs(edge,i)",
			"",
			"",
			"##帰りがけで処理するときはこの辺でやる",
			"",
			"	cnt+=1",
			"	f[k]=cnt",
			"",
			"",
			"##有向グラフを辞書edgeに記録する",
			"n=int(input())",
			"edge=dd(list)",
			"",
			"for i in range(n):",
			"	u,k,*v=map(int,input().split())",
			"	for j in v:",
			"		edge[u].append(j)",
			"",
			"",
			"d=[-1 for _ in range(n+1)]",
			"f=[-1 for _ in range(n+1)]",
			"",
			"cnt=0",
			"for i in range(1,n+1):",
			"if d[i]==-1:",
			"	dfs(edge,i)",
			"",
			"",
		],
		"description": "深さ優先探索(再帰)"
	},


	"0-1 BFS": {
		"prefix": "def BFS(i,j)",
		"body": [
			"import sys",
			"sys.setrecursionlimit(10**8)",
			"",
			"",
			"def BFS(i,j):",
			"	cur=((1,0),(0,1),(-1,0),(0,-1))",
			"",
			"	for di,dj in cur:",
			"		if A[i][j]<=1 and A[i+di][j+dj]=='o':",
			"			A[i+di][j+dj]=A[i][j]",
			"			q.append((i+di,j+dj))",
			"",
			"		elif A[i+di][j+dj]=='x':",
			"			if A[i][j]<=1:",
			"				A[i+di][j+dj]=A[i][j]+1",
			"				q.appendleft((i+di,j+dj))",
			"",			
			"	if len(q)>0:",
			"		i,j=q.pop()",
			"		BFS(i,j)",
			"	else:",
			"		return",
		],
		"description": "0-1 BFS"
	},

	"繰り返し二乗法": {
		"prefix": "def reppow(x,n,mod)",
		"body": [
			"def reppow(x,n,mod):",
			"##(x**n)%modを繰り返し二乗法によって算出",
			"##pow(x,n,mod)と同じ",
			"",
			"	n=str(format(n,'b'))[::-1]",
			"	r=1",
			"	for i in n:",
			"		if i=='1':",
			"			r=(r*x)%mod",
			"		x=(x*x)%mod",
			"	return r",
		],
		"description": "繰り返し二乗法"
	},

	"floorsum": {
		"prefix": "def floorsum(n,m,a,b):",
		"body": [
			
			"import sys",
			"sys.setrecursionlimit(10**8)",
			"", 
			"##y=(ax+b)/M　(0<x<=n)以下の格子点の数を求める",
			"def floorsum(n,m,a,b):",
			"	ans=0",
			"	if a>=m:",
			"		ans+=(n-1)*n*(a//m)//2",
			"		a%=m",
			"	if b>=m:",
			"		ans+=n*(b//m)",
			"		b%=m",
			"", 
			"	y_max=(a*n+b)//m",
			"	x_max=(y_max*m-b)",
			"	if y_max==0:",
			"		return ans",
			"",	
			"	ans+=(n-(x_max+a-1)//a)*y_max",
			"	ans+=floorsum(y_max,a,m,(a-x_max%a)%a)",
			"	return ans",
		],
		"description": "floorsum"
	},
	
	"def Miller_Rabin": {
        "prefix": "def Miller_Rabin",
        "body": [
            "##ミラーラビン素数判定法",
            "##素数ならTrue,非素数ならFalseを返す",
            "def Miller_Rabin(N):",
            "",
            "    ##1は非素数",
            "    if N==1:",
            "        return False",
            "",
            "    ##2は素数その他2の倍数は合成数",
            "    if N%2==0:",
            "        if N==2:",
            "            return True",
            "        else:",
            "            return False",
            "",
            "    ##偶数は篩落としたのでNは奇数でありN-1は偶数となる",
            "    ##ここでN-1を2^s*dと表すこととする",
            "    temp=N-1",
            "    s=0",
            "    while temp%2==0:",
            "        temp//=2",
            "        s+=1",
            "    d=(N-1)//(2**s)",
            "",
            "    ##比較対象リスト",
            "    ##2^32未満なら2,7,61",
            "    ##2^64未満なら37までの素数を使う",
            "    ##それ以上は2以上N未満の乱数50個を使う",
            "",
            "    if N<2**32:",
            "        complist=(2,7,61)",
            "    elif N<2**64:",
            "        complist=(2,3,5,7,11,13,17,19,23,29,31,37)",
			"        ##(2, 325, 9375, 28178, 450775, 9780504, 1795265022)",
			"        ##でもいいっぽい",
            "    else:",
            "        from random import randint",
            "        complist=set()",
            "        while len(complist)<50:",
            "            complist.add(randint(2,N-1))",
            "",
            "    ##aをcomplist中の数字でそれぞれ試してみる",
            "    for a in complist:",
            "        if N<=a:break",
            "",
            "        ##(a^d)%N=1ならこのaについてはミラーラビンテスト合格",
            "        if pow(a,d,N)==1:",
            "            continue",
            "",
            "        ##0<=r<sを満たす(a^(d*(2^r)))%Nを見ていき",
            "        ##-1≡N-1を満たすものが1つでもあればこのaについてミラーラビンテスト合格",
            "        ##1つもなければその時点で不合格(非素数)",
            "        for r in range(s):",
            "            temp=pow(a,d*(2**r),N)",
            "            if temp==N-1:",
            "                break",
            "        else:",
            "            return False",
            "",
            "    ##すべてのaについてミラーラビンテストが合格したならおそらく素数と判定できる",
            "    return True",
        ],
        "description": "ミラーラビン素数判定法"
    },


	"線形篩": {
		"prefix": "def prime(N):",
		"body": [
			"def prime(N):",
			"	##Pをsetに変えたらアカン",
			"	P=[]",
			"	f=[0 for _ in range(N+1)]",
			"",
			"	for i in range(2,N+1):",
			"	    if f[i]==0:",
			"			P.append(i)",
			"			f[i]=i",
			"",
			"    	for j in P:",
			"       	if i*j>N  or j>f[i] :",
			"           	break",
			"       	f[i*j]=j",
			"",
			"	return P",

		],
		"description": "線形篩"
	},

	"素因数分解": {
		"prefix": "def fact(N):",
		"body": [
			"from collections import defaultdict as dd",
			"",
			"def fact(N):",
			"	P=[]",
			"	temp = N",
			"",
			"	for i in range(2, int(N**0.5)+1):",
			"		if temp%i==0:",
			"			cnt=0",
			"			while temp%i==0:",
			"				cnt+=1",
			"				temp //= i",
			"			P.append([i, cnt])",
			"",
			"	if temp!=1:",
			"		P.append([temp, 1])",
			"",
			"	if P==[]:",
			"		P.append([N, 1])",
			"",
			"	return P",

		],
		"description": "素因数分解"
	},

    "def divenum": {
        "prefix": "def divenum",
        "body": [
            "##約数列挙",
            "def divenum(N):",
            "    D=[]",
            "    for i in range(1, int(N**0.5)+1):",
            "        if N%i==0:",
            "            D.append(i)",
            "            if N//i!=i:",
            "                D.append(N//i)",
            "",
            "    D=sorted(D)",
            "    return D",
        ],
        "description": "約数列挙"
    },



    "def rot2d90deg(rootx,rooty,x,y)": {
        "prefix": "def rot2d90deg(rootx,rooty,x,y)",
        "body": [
            "##二次元座標回転",
            "##座標x,yをrootx,rootyに対して90[deg]回転する",
            "def rot2d90deg(rootx,rooty,x,y):",
            "    x-=rootx",
            "    y-=rooty",
            "",
            "    x=-y",
            "    y=x",
            "",
            "    x+=rootx",
            "    y+=rooty",
            "",
            "    return x,y",
        ],
        "description": "2次元座標90度回転"
    },

    "def rot2d(rootx,rooty,x,y,th):": {
        "prefix": "def rot2d(rootx,rooty,x,y,th):",
        "body": [
            "from math import sin,cos,pi",
            "",
            "##2次元座標回転",
            "##座標x,yをrootx,rootyに対してth[rad]回転する",
            "def rot2d(rootx,rooty,x,y,th):",
            "",
            "    x-=rootx",
            "    y-=rooty",
            "",
            "    x=x*cos(th)-y*sin(th)",
            "    y=x*sin(th)+y*cos(th)",
            "",
            "    x+=rootx",
            "    y+=rooty",
            "",
            "    return x,y",
        ],
        "description": "2次元座標回転"
    },

    "def grid_r_rot(A)": {
        "prefix": "def grid_r_rot(A)",
        "body": [
            "##2次元行列Aを時計回りに回転する",
            "##zip版",
            "def grid_r_rot(A):",
            "    return list(zip(*A[::-1]))",
            "",
            "##普通に行列操作する(少し速い?)",
            "def grid_r_rot1(A):",
            "    N=len(A)",
            "    M=len(A[0])",
            "    retA=[[None for _ in range(N)]for _ in range(M)]",
            "",
            "    for i in range(N):",
            "        for j in range(M):",
            "            retA[j][N-i-1]=A[i][j]",
            "",
            "    return retA",
        ],
        "description": "座標右回転"
    },


    "def grid_l_rot(A)": {
        "prefix": "def grid_l_rot(A)",
        "body": [
            "##2次元行列Aを反時計回りに回転する",
            "##zip版",
            "def grid_l_rot(A):",
            "    return list(zip(*A))[::-1]",
            "",
            "##普通に行列操作する(少し速い?)",
            "def grid_l_rot1(A):",
            "    N=len(A)",
            "    M=len(A[0])",
            "    retA=[[None for _ in range(N)]for _ in range(M)]",
            "",
            "    for i in range(N):",
            "        for j in range(M):",
            "            retA[N-j-1][i]=A[i][j]",
            "",
            "    return retA",
        ],
        "description": "座標左回転"
    },



    "def prdmat(A,B):": {
        "prefix": "def prdmat(A,B):",
        "body": [
            "##N行M列の行列AとM行K列の行列Bの行列積Cを計算する",
            "def prdmat(A,B):",
            "",
            "    global MOD",
            "",
            "    N=len(A)",
            "    M=len(A[0])",
            "    M1=len(B)",
            "    K=len(B[0])",
            "",
            "    assert M==M1",
            "",
            "    ##Bを転置する",
            "    tB=transmat(B)",
            "",
            "    ##行列積CはN行K列となる",
            "    C=[[0 for _ in range(K)] for _ in range(N)]",
            "",
            "    for i in range(N):",
            "        a=A[i]",
            "        for j in range(K):",
            "            b=tB[j]",
            "            temp=0",
            "            for k in range(M):",
            "                temp+=(a[k]*b[k])%MOD",
            "                temp%=MOD",
            "            C[i][j]=temp",
            "    return C",
        ],
        "description": "行列積"
    },

    "def reppowmat(A,n):": {
        "prefix": "def reppowmat(A,n):",
        "body": [
            "##繰り返し二乗法によって行列累乗を求める",
            "def reppowmat(A,n):",
            "",
            "    n=str(format(n,'b'))[::-1]",
            "    ",
            "    ##単位行列を作る",
            "    l=len(A)",
            "    ret=[[0 for _ in range(l)] for _ in range(l)]",
            "    for i in range(l):",
            "        ret[i][i]=1",
            "",
            "    for i in n:",
            "        if i=='1':",
            "            ret=prdmat(ret,A)",
            "        A=prdmat(A,A)",
            "",
            "    return ret",
        ],
        "description": "行列累乗"
    },

    "def closs(px,py,ax,ay,bx,by)": {
        "prefix": "def cross(px,py,ax,ay,bx,by)",
        "body": [
            "##P=(px,py),A=(ax,ay),B=(bx,by)に対して",
            "##ベクトルPA,PBの外積PA×PBを計算する",
            "def cross(px,py,ax,ay,bx,by):",
            "    PA=(ax-px,ay-py)",
            "    PB=(bx-px,by-py)",
            "    return PA[0]*PB[1]-PA[1]*PB[0]",
        ],
        "description": "3点に対する外積"
    },


    "def calc_rank(A):": {
        "prefix": "def calc_rank(A):",
        "body": [
            "def calc_rank(A):",
            "    N=len(A)",
            "    A=progress_elimination(A)",
            "",
            "    res=0",
            "    for i in range(N):    ",
            "        if A[i][i]!=0:",
            "            res+=1",
            "",
            "    return res",
        ],
        "description": "行列ランク計算"
    },

    "def progress_elimination(A):": {
        "prefix": "def progress_elimination(A):",
        "body": [
            "##前進消去",
            "def progress_elimination(A):",
            "    global MOD",
            "",
            "    N=len(A)",
            "    assert N==len(A[0])",
            "    res=1",
            "    rank=N",
            "    for i in range(N):",
            "        ##A[i][i]=0なら同じ行で非ゼロの",
            "        ##他の列と入れ替えができないか探す",
            "        if A[i][i]==0:",
            "            for j in range(i+1,N):",
            "                if A[i][j]!=0:",
            "                    ##非ゼロの列があればj列とi列入れ替え",
            "                    ##置換に伴う符号反転-1を行列式の外にかけておく",
            "                    for k in range(N):",
            "                        A[k][j],A[k][i]=A[k][i]%MOD,A[k][j]%MOD",
            "                        res*=-1",
            "                    break",
            "            else:",
            "                ##無ければ仕方ないのでcontinue",
            "                ##rankを1減らして行列式の値も0とする",
            "                res*=0",
            "                rank-=1",
            "                continue",
            "",
            "",
            "        ##A[i][i]のMOD逆元を求めてA[i][i]=1とするため",
            "        ##Aのi行目の各要素をA[i][i]で割る=revAiをかける",
            "        ##この時行列式の外に出すA[i][i]をresにかける",
            "",
            "        revAi=pow(A[i][i],MOD-2,MOD)",
            "        res=(res*A[i][i])%MOD",
            "        for k in range(i,N):",
            "            A[i][k]=A[i][k]*revAi%MOD",
            "        ",
            "        ##A[j]行の各要素から(A[i]の各要素*A[j][i])を引いていき",
            "        ##Aのi+1行目以降j列を0にしていく",
            "        for j in range(i+1,N):",
            "            if A[j][i]==0:",
            "                continue",
            "",
            "            jmul=A[j][i]",
            "            ##Aのj(i<j<N)行目の各要素A[j][k]からA[i][k]*jmul倍したものを引いていく",
            "            for k in range(i,N):",
            "                A[j][k]=(A[j][k]-jmul*A[i][k])%MOD",
            "                ",
            "        #for a in A:",
            "        #    print(a)",
            "",
            "    return A,res",
        ],
        "description": "行列式,前進消去"
    },

    "def invmat(A):": {
        "prefix": "def invmat(A):",
        "body": [
            "MOD=998244353",
            "##N行N列の正方行列Aに対してAB=Eとなる行列Bを掃き出し法にて求める",
            "def invmat(A):",
            "",
            "    ",
            "    N=len(A)",
            "    assert N==len(A[0])",
            "",
            "    ##単位行列Bを用意する",
            "    B=[[0 for _ in range(N)] for _ in range(N)]",
            "    for i in range(N):",
            "        B[i][i]=1",
            "",
            "",
            "    for i in range(N):",
            "        ##A[i][i]=0ならi列が非ゼロの",
            "        ##他の行を足せないか探す",
            "        if A[i][i]==0:",
            "            for j in range(i+1,N):",
            "                if A[j][i]!=0:",
            "                    ##i列が非ゼロの行があればその行の値を足す",
            "                    for k in range(N):",
            "                        A[i][k]=(A[j][k]+A[i][k])%MOD",
            "                        B[i][k]=(B[j][k]+B[i][k])%MOD",
            "                    break",
            "            else:",
            "                ##無ければrank!=Nであり逆行列は存在しない",
            "                return -1",
            "",
            "        ##前進消去を行う",
            "        ##A[i][i]=1とするためA[i][i]のMOD逆元revAiを求めて",
            "        ##Aのi行目の各要素をA[i][i]で割る=revAiをかける",
            "        ##Bのi行目も同様に操作する",
            "        revAi=pow(A[i][i],MOD-2,MOD)",
            "        for k in range(N):",
            "            A[i][k]=A[i][k]*revAi%MOD",
            "            B[i][k]=B[i][k]*revAi%MOD",
            "",
            "        ##A[j]行の各要素から(A[i]の各要素*A[j][i])を引いていき",
            "        ##i行目以外のj列を0にしていく",
            "        for j in range(N):",
            "            if j==i or A[j][i]==0:",
            "                continue",
            "",
            "            jmul=A[j][i]",
            "            ##Aのj行目の各要素A[j][k]からA[i][k]*jmul倍したものを引いていく",
            "            ##Bの方も同様に操作する",
            "            for k in range(N):",
            "                A[j][k]=(A[j][k]-jmul*A[i][k])%MOD",
            "                B[j][k]=(B[j][k]-jmul*B[i][k])%MOD",
            "",
            "    return B",
        ],
        "description": "逆行列"
    },

    "def transmat(A):": {
        "prefix": "def transmat(A):",
        "body": [
            "##N行M列の行列AをM行N列の行列transAに転置する",
			"##return list(zip(*A))と同じ",
            "def transmat(A):",
            "",
            "    N=len(A)",
            "    M=len(A[0])",
            "",
            "    transA=[[0 for _ in range(N) ] for _ in range(M)]",
            "    for i in range(N):",
            "        for j in range(M):",
            "            transA[j][i]=A[i][j]",
            "",
            "    return transA",
        ],
        "description": "行列転置"
    },


    "def LUdecomp(mat):": {
        "prefix": "def LUdecomp(mat)",
        "body": [
            "##LU分解する",
            "##逆元としてMOD逆元を使う",
            "##下三角行列の対角成分を1とするドゥーリトル法",
            "##判定は入れていないが首座行列式が0となるものがあれば分解不能",
            "def LUdecomp(mat):",
            "    global MOD",
            "",
            "    N=len(mat)",
            "    assert N==len(mat[0])",
            "",
            "    L=[[0 for _ in range(N)] for _ in range(N)]",
            "    U=[[0 for _ in range(N)] for _ in range(N)]",
            "",
            "    ##横⇒縦⇒横⇒縦⇒…で埋めていく",
            "    for i in range(N):",
            "        #Lの対角成分は1",
            "        L[i][i]=1",
            "",
            "        ##i行目の横を見ていく",
            "        for j in range(i,N):",
            "            temp=0",
            "            for k in range(i):",
            "                temp+=U[k][j]*L[i][k]",
            "                temp%=MOD",
            "            #print(\"U\",i,j)",
            "            U[i][j]=(mat[i][j]-temp)%MOD",
            "",
            "        ##i列目の縦を見ていく",
            "        ##U[i][i]のMOD逆元を求める",
            "        revU=pow(U[i][i],MOD-2,MOD)",
            "        for j in range(i+1,N):",
            "            temp=0",
            "            for k in range(i):",
            "                temp+=U[k][i]*L[j][k]",
            "                temp%=MOD",
            "",
            "            #print(\"L\",j,i)",
            "            L[j][i]=((mat[j][i]-temp)*revU)%MOD",
            "",
            "    return L,U",
        ],
        "description": "LU分解"
    },

    "def BFS(i)": {
        "prefix": "def BFS(i)",
        "body": [
            "import sys",
            "sys.setrecursionlimit(10**8)",
            "from collections import defaultdict as dd,deque",
            "",
            "##N頂点,M本の辺に対する幅優先探索",
            "##chkに始点1からの距離を入れていく",
            "def BFS(i):",
            "    for s,t in edge[i]:",
            "        q.append((s,t))",
            "",
            "    while len(q):",
            "        s,t,iii=q.popleft()",
            "        if chk[t]==INF :",
            "            chk[t]=chk[s]+1",
            "    return",
            "",
            "",
            "N,M=map(int,input().split())",
            "",
            "edge=dd(list)",
            "for i in range():",
            "    s,t=map(int,input().split())",
            "    edge[s].append((s,t))",
            "",
            "INF=float('INF')",
            "chk=[INF for _ in range(N+1)]",
            "chk[1]=0",
            "q=deque()",
            "",
            "BFS(1)",
        ],
        "description": "シンプルなBFS"
    },


	"クラスカル法": {
		"prefix": "def kruskal(edge):",
		"body": [
			"##Union-Findと一緒に使う##"
			"##辺a,bを結ぶ重みwの辺を##"
			"##edge[i]=[a,b,w]の形で持っておく##"
			"##重みの総和ansを返す##"
			"##選ばれた辺をTに書き留める##"
			"",
			"def kruskal(edge):",
			"",
			"	edge=sorted(edge, reverse=False, key=lambda x: x[2])",
			"	ans=0",
			"	T=[]",
			"",
			"	for a,b,w in edge:",
			"		par[a]=find(a)",
			"		par[b]=find(b)",
			"		if par[a]==par[b]:",
			"			continue",
			"		else:",
			"			T.append([a,b,w])",
			"			ans+=w",
			"			union(a,b)",
			"",
			"	return ans",
			"",
			"",
		],
		"description": "クラスカル法"
	},

	"プリム法": {
		"prefix": "def prim(edge):",
		"body": [
			"##辺a,bを結ぶ重みwの辺を##",
			"##dict型edge[a]=[b,w],edge[b]=[a,w]の形で持っておく##",
			"##適当な点からスタートし確定している点から##",
			"##コストが最小の辺を調べ次の点を確定させる##",
			"##確定した点は配列chkに1を書き込む##",
			"##コストが最小となる辺はheapqによって管理する##",
			"",	
			"",	
			"from collections import defaultdict as dd",
			"from heapq import heappop as hpop,heappush as hpush",
			"",	
			"q=[]",
			"for k,w in edge[0]:",
			"	hpush(q,(w,k))",
			"",
			"chk=[0 for _ in range(N+1)]",
			"chk[0]=1",
			"ans=0",
			"",
			"while len(q):",
			"	w,k=hpop(q)",
			"	if chk[k]==0:",
			"		chk[k]=1",
			"		d+=1",
			"		ans+=w",
			"		for m,w in edge[k]:",
			"			hpush(q,(w,m))",
			"",
			"print(ans)",
			"",
		],
		"description": "プリム法"
	},


    "ダイクストラ法": {
        "prefix": "dijkstra",
        "body": [
            "",
            "##dijkstra法",
            "",
            "def dijkstra(start):",
            "    ##costに始点から見た高さを記録する",
            "    ##最初はINFで初期化しておく",
            "    cost=[INF for _ in range(N+1)]",
            "    cost[start]=0",
            "    chk=[False for _ in range(N+1)]",
            "    res=0",
            "    ##qをheapqとして使う",
            "    q=[]",
            "",
            "    hpush(q,(0,start))",
            "",
            "    ##heapqで近い順に値を決定していく",
            "    while len(q):",
            "        c,s=hpop(q)",
            "        if chk[s]==True:continue",
            "        chk[s]=True",
            "        for nowc,t in edge[s]:",
            "            if c+nowc<cost[t]:",
            "                cost[t]=c+nowc",
            "                hpush(q,(c+nowc,t))",
            "",
            "    return res",
            "",
            "##edgeに重さw、終点tをタプルで記録する",
            "edge=dd(list)",
            "for _ in range(#クエリの数):",
            "    w,u,v=map(int,input().split())",
            "    edge[u].append((w,v))",
            "    edge[v].append((w,u))",
            "",
            "dijkstra(1)",
        ],
        "description": "ダイクストラ法"
    },

    "Bellman-Ford": {
        "prefix": "Bellman-Ford",
        "body": [
            "from collections import defaultdict as dd",
            "INF=float('INF')",
            "neg=\"NEGATIVE CYCLE\"",
            "",
            "",
            "##入力",
            "V,E,r=map(int,input().split())",
            "",
            "##辺情報入力",
            "edge=dd(list)",
            "for _ in range(E):",
            "    s,t,d=map(int,input().split())",
            "    edge[s].append((t,d))",
            "",
            "##始点からの距離情報初期化",
            "dist=[INF for _ in range(V)]",
            "dist[r]=0",
            "",
            "",
            "##ベルマンフォード本体",
            "for loop in range(V):",
            "    ",
            "    ##loop回目の確認中に更新が行われるかフラグで管理",
            "    f=False",
            "",
            "    for i in range(V):",
            "",
            "        ##まだ到達していない頂点ならば確認しない",
            "        if dist[i]==INF:continue",
            "",
            "        ##頂点iから接続される点の距離更新確認",
            "        ##更新がある場合はfをTrueとする",
            "        for j,c in edge[i]:",
            "            if dist[j]>dist[i]+c:",
            "                dist[j]=dist[i]+c",
            "                f=True",
            "",
            "",
            "    ##更新がなければ終了",
            "    if not f:break",
            "",
            "",
            "",
            "else:",
            "    ##V回の確認後に更新が行われるならば負閉路が存在している",
            "    if f:",
            "        print(neg)",
            "        exit(0)",
            "",
            "##出力",
            "for a in dist:",
            "    if a==INF:print(\"INF\")",
            "    else:print(a)",
        ],
        "description": "ベルマンフォード法"
    },


    "Warshall-Floyd": {
        "prefix": "Warshall-Floyd",
        "body": [
            "##Warshall-Floyd法:O(N^3:Nは頂点の数)",
            "##DP[k][i][j]をiからjへ行くためにkを経由する場合のコストとする",
            "##kはインラインでできるのでDP[i][j]としてよい",
            "",
            "##DPテーブル初期化",
            "DP=[[INF for _ in range(N)]for _ in range(N)]",
            "##始点終点が同じならコスト0",
            "for i in range(N):",
            "    DP[i][i]=0",
            "",
            "##与えられたedgeのコストを入力",
            "for _ in range(M):",
            "",
            "##ワ―シャルフロイド本体の3重ループ",
            "for k in range(N):",
            "    for i in range(N):",
            "        for j in range(N):",
            "            ##点iから点jへ直接移動するか",
            "            ##点kを経由するかコストの小さい方を採用",
            "            DP[i][j]=min(DP[i][j],DP[i][k]+DP[k][j])",
        ],
        "description": "ワ―シャルフロイド法"
    },



    "fenwicktree": {
        "prefix": "class fenwick",
        "body": [
            "##1-indexedのFenwickTree",
            "##区間和とxorに対応",
            "class fenwick:",
            "    ##配列fwを要素数nで初期化する",
            "    def __init__(self, n):",
            "        self.size = n",
            "        self.tree = [0] * (n+1)",
            "",
            "    ##iにxを加算する",
            "    def add(self, i, x):",
            "        assert 1<=i<=self.size",
            "        while i <= self.size:",
            "            self.tree[i] += x",
            "            ##LSBを加算して次のインデックスを求める",
            "            i += i & -i",
            "",
            "    ##iにxをxorする",
            "    def xoradd(self, i, x):",
            "        assert 1 <= i <= self.size",
            "        while i <= self.size:",
            "            self.tree[i] ^= x",
            "            i += i & -i",
            "",
            "    ##[l,r]の区間和を取得する",
            "    ##[0,r]から[0,l]を引く",
            "    def sum(self, l, r):",
            "        assert 0 <= l <= r <= self.size",
            "        return self.sum0(r) - self.sum0(l)",
            "",
            "    ##[0,r]の総和を取得する",
            "    def sum0(self, r):",
            "        s = 0",
            "        while r > 0:",
            "            s += self.tree[r]",
            "            r -= r & -r",
            "        return s",
            "",
            "    ##[l,r]のxorを取得する",
            "    ##[0,r]と[0,l]のxorを取る",
            "    def xorsum(self, l, r):",
            "        assert 0 <= l <= r <= self.size",
            "        return self.xorsum0(r)^self._xorsum0(l-1)",
            "",
            "    ##[0,r]のxorを取得する",
            "    def xorsum0(self, r):",
            "        s = 0",
            "        while r > 0:",
            "            s ^= self.tree[r]",
            "            r -= r & -r",
            "        return s",
        ],
        "description": "フェニック木"
    },

    "segtree": {
        "prefix": "segtree",
        "body": [
            "n2=1",
            "while (n2<=N+2): n2*=2",
            "segtree=[set() for _ in range(2*n2-1)]",
        ],
        "description": "セグメント木初期化"
    },


    "def get_range_pos(s,e):": {
        "prefix": "def get_range_pos(s,e):",
        "body": [
            "##[s,e]の区間を取得する",
            "def get_range_pos(s,e):",
            "    s+=n2",
            "    e+=n2",
            "    poslist=[]",
            "    while s<e:",
            "        if s%2!=0:",
            "            poslist.append(s)",
            "            s+=1 ",
            "        s//=2",
            "        if e%2!=0:",
            "            e-=1",
            "            poslist.append(e)",
            "        e//=2",
            "",
            "    return poslist",
        ],
        "description": "セグメント木区間取得"
    },



	"根付き木作成": {
		"prefix": "edge=dd(list)",
		"body": [
			"from collections import defaultdict as dd,deque",
			"",
			"",
			"##各頂点とつながる辺を辞書edgeに記録する",
			"edge=dd(list)",
			"for _ in range(N-1):",
			"	a,b=map(int,input().split())",
			"	edge[a].append(b)",
			"	edge[b].append(a)",
			"",
			"##根を1として根からの深さを配列depthで管理する",
			"depth=[-1]*(N+1)",
			"depth[1]=0",
			"",
			"##dequeを使い根からBFSによってdepthを埋めていく",
			"q=deque()",
			"q.append(1)",
			"",
			"##あとでimos法の値を伝搬させるために子を配列sonに記録しておく",
			"son=dd(list)",
			"",
			"while len(q)>0:",
			"	temp=q.pop()",
			"	for i in edge[temp]:",
			"		if depth[i]==-1: ",
			"			depth[i]=depth[temp]+1",
			"			son[temp].append(i)",
			"			q.append(i)",
			"",
			"",

		],
		"description": "根付き木作成"
	},

	"トポロジカルソート": {
		"prefix": "def topsort(edge,v)",
		"body": [
			"import sys",
			"sys.setrecursionlimit(10**8)",
			"from collections import defaultdict as dd",
			"",
			"def topsort(edge,v):",
			"	seen[v]=True",
			"	for i in edge[v]:",
			"		if seen[i]==True:",
			"			continue",
			"		topsort(edge,i)",
			"",
			"	order.append(v)",
			"",
			"edge=dd(list)",
			"V,E=map(int,input().split())",
			"",
			"for _ in range(E):",
			"	s,t=map(int,input().split())",
			"	edge[s].append(t)",
			"",
			"seen=[False]*(V)",
			"order=[]",
			"",
			"for i in range(V):",
			"	if seen[i]==True:",
			"		continue",
			"	topsort(edge,i)",
			"",
			"order=order[::-1]",
			"",
			"for ans in order:",
			"	print(ans)",
			"",
			"",
		],
		"description": "トポロジカルソート"
	},

    "topsort": {
        "prefix": "topsort",
        "body": [
            "N,M=map(int,input().split())",
            "",
            "##後に来るものをsonに記録",
            "##入り次数をindに記録",
            "son=dd(list)",
            "ind=[0 for _ in range(N+1)]",
            "for _ in range(M):",
            "    a,b=map(int,input().split())",
            "    son[a].append(b)",
            "    ind[b]+=1",
            "",
            "q=[]",
            "##indが0になっていればqに追加する",
            "for i in range(1,N+1):",
            "    if ind[i]==0:hpush(q,i)",
            "",
            "",
            "seen=[False]*(N+1)",
            "ans=[]",
            "while(len(q)):",
            "    ##qの最小要素を取り出しansに追加する",
            "    i=hpop(q)",
            "    ans.append(i)",
            "",
            "    ##iの子を確認し入り次数を減らす",
            "    ##入り次数が0になればqに追加する",
            "    for j in son[i]:",
            "        ind[j]-=1",
            "        if ind[j]==0:",
            "            hpush(q,j)",
			"",
            "##解の文字列長さがNで無ければ閉路ができている",
            "if len(ans)==N:print(*ans)",
            "else:print(-1)",
        ],
        "description": "強いトポロジカルソート"
    },

    "SCC": {
        "prefix": "SCC",
        "body": [
            "from collections import defaultdict as dd",
            "sys.setrecursionlimit(10**8)",
            "",
            "##再帰を使ったDFS",
            "##行きがけの順番を配列d、帰りがけの順番を配列fに記録",
            "def dfs(edge,k):",
            "",
            "##行きがけで処理するときはこの辺でやる",
            "    global dcnt,fcnt",
            "    dcnt+=1",
            "    d[k]=dcnt",
            "",
            "    for i in edge[k]:",
            "        if d[i]!=-1:",
            "            continue",
            "        dfs(edge,i)",
            "",
            "",
            "##帰りがけで処理するときはこの辺でやる",
            "    fcnt+=1",
            "    f[k]=[k,fcnt]",
            "",
            "def rdfs(edge,k):",
            "",
            "##行きがけで処理するときはこの辺でやる",
            "    global cnt",
            "    chk[k]=cnt",
            "    SCC[cnt].add(k)",
            "    for i in edge[k]:",
            "        if chk[i]!=-1:",
            "            continue",
            "        rdfs(edge,i)",
            "",
            "##有向グラフを辞書edgeに記録する",
            "##強連結成分分解用に逆向き矢印も辞書redgeに記録",
            "N,M=map(int,input().split())",
            "edge,redge=dd(list),dd(list)",
            "",
            "for i in range(M):",
            "    A,B=map(int,input().split())",
            "    edge[A].append(B)",
            "    redge[B].append(A)",
            "",
            "d=[-1 for _ in range(N+1)]",
            "f=[None for _ in range(N+1)]",
            "",
            "##とりあえずDFSで探索順を記録",
            "dcnt,fcnt=0,0",
            "for i in range(1,N+1):",
            "    if d[i]==-1:",
            "        dfs(edge,i)",
            "",
            "##帰りがけで遅かった順に逆向きDFSを行い",
            "##行き止まりになるまでの範囲を",
            "##一つの強連結成分(SCC)とする",
            "f=f[1:]",
            "f=sorted(f, reverse=True, key=lambda x: x[1])",
            "chk=[-1 for _ in range(N+1)]",
            "cnt=0",
            "SCC=dd(set)",
            "",
            "for k,v in f:",
            "    if chk[k]==-1:",
            "        rdfs(redge,k)",
            "        cnt+=1",
        ],
        "description": "強連結成分分解(SCC)"
    },

    "def Ford_Fulkerson(s,t):": {
        "prefix": "def Ford_Fulkerson(s,t):",
        "body": [
            "from collections import defaultdict as dd",
            "sys.setrecursionlimit(10**8)",
            "INF=float('INF')",
            "",
            "def FFdfs(s,t,F):",
            "",
            "    ##tに到達したら流量を戻す",
            "    if s==t:return F",
            "",
            "    chk[s]=True",
            "    ##パスを全探索",
            "    for k in edge[s].keys():",
            "",
            "        ##ループを形成していないか確認",
            "        if chk[k]:continue",
            "",
            "        ##まだ流す容量が存在するか確認",
            "        if edge[s][k]<=0:continue",
            "",
            "        ##tまでのパスを見つけたら流せるだけ流す",
            "        flow=FFdfs(k,t,min(F,edge[s][k]))",
            "",
            "        ##流せなければ次を見る",
            "        if flow==0:continue",
            "",
            "        ##流せるなら再帰的に流量を戻していく",
            "        edge[s][k]-=flow",
            "        edge[k][s]+=flow",
            "        return flow",
            "",
            "    ##流せるパスが無ければ無し",
            "    return 0",
            "",
            "",
            "def Ford_Fulkerson(s,t):",
            "    ret=0",
            "    while 1:",
            "        for i in range(E+1):chk[i]=False",
            "        F=FFdfs(s,t,INF)",
            "        if F==0: return ret",
            "        ret+=F",
            "",
            "",
            "V,E=map(int,input().split())",
            "",
            "edge=dd(lambda:dd(lambda:-1))",
            "for i in range(E):",
            "    u,v,c=map(int,input().split())",
            "    edge[u][v]=c",
            "    edge[v][u]=0",
            "",
            "chk=[False]*(E+1)",
            "res=Ford_Fulkerson(0,V-1)",
            "",
            "print(res)",
        ],
        "description": "フォード-ファルカーソン法(最大流)"
    },

    "def Dinic": {
        "prefix": "def Dinic",
        "body": [
            "sys.setrecursionlimit(10**8)",
            "from collections import defaultdict as dd,deque",
            "INF=float('INF')",
            "",
            "##辺の追加",
            "##sからtヘ容量fの辺を張る",
            "def add_edge(s,t,f):",
            "    ssize=len(edge[s])",
            "    tsize=len(edge[t])",
            "",
            "    edge[s].append([t,f,tsize])",
            "    edge[t].append([s,0,ssize])",
            "",
            "    return ",
            "",
            "##始点からの深さを調べる",
            "def D_BFS(s):",
            "",
            "    for i in range(V+1):depth[i]=INF",
            "    depth[s]=0",
            "",
            "    q=deque()",
            "    q.append(s)",
            "    while len(q):",
            "        s=q.popleft()",
            "        for i,a  in enumerate(edge[s]):",
            "            to,cost=a[0],a[1]",
            "            if cost and depth[to]==INF:",
            "                depth[to]=depth[s]+1",
            "                q.append(to)",
            "",
            "    return",
            "",
            "##流量チェック",
            "def D_DFS(s,t,F):",
            "",
            "    if s==t:return F",
            "    ",
            "    itr=chk[s]",
            "    for i in range(itr,len(edge[s])):",
            "",
            "        to,cost,rev=edge[s][i]",
            "",
            "        ##まだ流す容量が存在するか確認",
            "        if cost==0:continue",
            "",
            "        ##より深い点か確認",
            "        if depth[s]>=depth[to]:continue",
            "",
            "        ##tまでのパスを見つけたら流せるだけ流す",
            "        flow=D_DFS(to,t,min(F,cost))",
            "",
            "        ##流せるなら再帰的に流量を戻していく",
            "        if flow>0:",
            "",
            "            edge[s][i][1]-=flow",
            "            edge[to][rev][1]+=flow",
            "",
            "            chk[s]=i",
            "            return flow",
            "",
            "    chk[s]=len(edge[s])",
            "    return 0",
            "",
            "def Dinic(s,t):",
            "",
            "    Flow=0",
            "    while 1:",
            "        D_BFS(s)",
            "        if depth[t]==INF:return Flow",
            "",
            "        for i in range(V+1):chk[i]=0",
            "",
            "        F=INF",
            "        while F>0:",
            "            F=D_DFS(s,t,INF)",
            "            Flow+=F",
            "            ",
            "V,E=map(int,input().split())",
            "",
            "##辞書に[行き先,コスト,対応する辺の位置]を記録する",
            "edge=dd(list)",
            "for i in range(E):",
            "    u,v,c=map(int,input().split())",
            "",
            "    usize=len(edge[u])",
            "    vsize=len(edge[v])",
            "",
            "    edge[u].append([v,c,vsize])",
            "    edge[v].append([u,0,usize])",
            "",
            "depth=[INF]*(V+1)",
            "chk=[0]*(V+1)",
            "",
            "res=Dinic(0,V-1)",
            "print(res)",
        ],
        "description": "ダイニック法(最大流)"
    },

    "def Bipartile_Matching():": {
        "prefix": "def Bipartile_Matching():",
        "body": [
            "##二部マッチング",
            "##参考:https://snuke.hatenablog.com/entry/2019/05/07/013609",
            "",
            "def Bipartile_Matching():",
            "",
            "    global root,backpath",
            "",
            "    res=0",
            "    f=True",
            "    while f:",
            "        f=False",
            "        q=deque()",
            "        for i in range(L):",
            "            ##まだマッチング対象が見つかっていなければ",
            "            ##iを始点としてキューに追加",
            "            if L2R[i]==-1:",
            "                root[i]=i",
            "                q.append(i)",
            "",
            "        while q:",
            "            s=q.pop()",
            "",
            "            ##逆辺を辿った先のrootが-1になっていればcontinue",
            "            if ~L2R[root[s]]: continue",
            "            ",
            "            ##始点から接続されている辺を全探索する",
            "            for t in edge[s]:",
            "",
            "                if R2L[t]==-1:",
            "                    ##逆辺が存在する場合は辿っていく",
            "                    while ~t:",
            "                        R2L[t]=s",
            "                        L2R[s],t=t,L2R[s]",
            "                        s=backpath[s]",
            "",
            "                    f=True",
            "                    res+=1",
            "                    break",
            "",
            "                ##仮のtに対するマッチング候補の情報を更新しキューに追加する",
            "                temps=R2L[t]",
            "                if ~backpath[temps]:continue",
            "",
            "                backpath[temps]=s",
            "                root[temps]=root[s]",
            "                q.append(temps)",
            "",
            "",
            "        ##更新があれば逆辺・始点情報を初期化する",
            "        if f:",
            "            backpath=[-1]*L",
            "            root=[-1]*L",
            "",
            "    return res",
            "",
            "",
            "L,R,E=map(int,input().split())",
            "",
            "##辞書にを記録する",
            "edge=dd(list)",
            "for i in range(E):",
            "    a,b=map(int,input().split())",
            "    edge[a].append(b)",
            "    ",
            "##L2R:Lから見たRのマッチングを記録",
            "##R2L:Rから見たLのマッチングを記録",
            "##backpath:L側に逆辺が張られている場合の辿る先",
            "##root:逆辺を考慮したLの始点を記録",
            "",
            "L2R=[-1]*L",
            "R2L=[-1]*R",
            "backpath=[-1]*L",
            "root=[-1]*L",
            "",
            "res=Bipartile_Matching()",
            "print(res)",
        ],
        "description": "二部マッチング"
    },


}
