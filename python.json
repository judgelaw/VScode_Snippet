{
	// Place your snippets for python here. Each snippet is defined under a snippet name and has a prefix, body and 
	// description. The prefix is what is used to trigger the snippet and the body will be expanded and inserted. Possible variables are:
	// $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. Placeholders with the 
	// same ids are connected.
	// Example:
	// "Print to console": {
	// 	"prefix": "log",
	// 	"body": [
	// 		"console.log('$1');",
	// 		"$2"
	// 	],
	// 	"description": "Log output to console"
	// }


	"入力高速化": {
		"prefix": "import sys input",
		"body": [		
			"import sys",
			"input = lambda: sys.stdin.readline().rstrip()",
		],
		"description": "入力高速化"
	},

	"整数入力": {
		"prefix": "int(input())",
		"body": [
			"int(input())",
		],
		"description": "整数入力"
	},

	"空白区切り整数入力": {
		"prefix": "map(int,input().split())",
		"body": [
			"map(int,input().split())",
		],
		"description": "空白区切り整数入力"
	},

	"空白区切り文字列→リスト": {
		"prefix": "list(input().split())",
		"body": [
			"list(input().split())",
		],
		"description": "空白区切り文字列→リスト"
	},

	"空白区切り整数入力→リスト": {
		"prefix": "list(map(int, input().split()))",
		"body": [
			"list(map(int, input().split()))",
		],
		"description": "空白区切り整数入力→リスト"
	},

	"文字列→一字ずつリスト化": {
		"prefix": "list(input())",
		"body": [
			"list(input())",
		],
		"description": "文字列→一字ずつリスト化"
	},

	"数字列→一字ずつリスト化": {
		"prefix": "list(map(int,input()))",
		"body": [
			"list(map(int,input()))",
		],
		"description": "数字列→一字ずつリスト化"
	},

	"N行1列の文字列入力": {
		"prefix": "[input() for _ in range($1N)",
		"body": [
			"[input() for _ in range($1N)",
		],
		"description": "N行1列の文字列入力"
	},

	"N行1列の整数入力": {
		"prefix": "[int(input()) for _ in range($1N)",
		"body": [
			"[int(input()) for _ in range($1N)",
		],
		"description": "N行1列の整数入力"
	},

	"N行N列の文字列入力": {
		"prefix": "[input().split()",
		"body": [
			"[input().split() for l in range($1N)",
		],
		"description": "N行N列の文字列入力"
	},

	"N行N列の整数入力": {
		"prefix": "[list(map(int, input().split()))",
		"body": [
			"[list(map(int, input().split()))  for _ in range($1N)",
		],
		"description": "N行N列の整数入力"
	},

    "def makevec(a,*n):": {
        "prefix": "def makevec(a,*n):",
        "body": [
            "def makevec(a,*n):",
            "    if len(n)==1:",
            "        return [a for _ in range(n[0])]",
            "    else:",
            "        return [makevec(a,*n[1:]) for _ in range(n[0])]",
        ],
        "description": "初期値aの多次元行列を生成"
    },	

    "cf": {
        "prefix": "cf",
        "body": [
            "def solve():",
            "    res=0",
            "",
            "",
            "    print(res)",
            "    return",
            "",
            "T=int(input())",
            "for _ in range(T):solve()",
        ],
        "description": "codeforces"
    },



	"GCJtemplate": {
		"prefix": "GCJ",
		"body": [
			"def solve($1):",
			"	ans=0",
			"",
			"	return ans",
			"",
			"T=int(input())",
			"for i in range(1,T+1):",
			"",	
			"	ans=solve($1)",
			"	print(\"Case #\"+str(i)+\":\",ans)",
		],
		"description": "GCJtemplate"
	},

	"文字リスト→出力": {
		"prefix": "print(''.join(S))",
		"body": [
			"print(''.join($1S))",
		],
		"description": "文字リスト→出力"
	},

	"整数リスト→出力": {
		"prefix": "print(''.join(map(str,A)))",
		"body": [
			"print(''.join(map(str,$1A)))",
		],
		"description": "整数リスト→出力"
	},

	"整数リスト→空白出力": {
		"prefix": "print(' '.join(map(str,A))",
		"body": [
			"print(' '.join(map(str,$1A)))",
		],
		"description": "整数リスト→空白出力"
	},


	"整数リスト→改行出力": {
		"prefix": "print('\n'.join(map(str,S)))",
		"body": [
			"print('\n'.join(map(str,$1S)))",
		],
		"description": "整数リスト→改行出力"
	},


	"for i in range(N):": {
		"prefix": "for i in range(N)",
		"body": [
			"for i in range($1N)",
		],
		"description": "0からN-1までのfor文"
	},

	"defaultdict as dd": {
		"prefix": "from collections import defaultdict as dd",
		"body": [
			"from collections import defaultdict as dd",
		],
		"description": "defaultdict"
	},	
	
	"入れ子dd": {
		"prefix": "dd(lambda:dd(int))",
		"body": [
			"dd(lambda:dd(int))",
		],
		"description": "入れ子dd"
	},	

    "無限dd": {
        "prefix": "recdd",
        "body": [
            "from collections import defaultdict as dd",
            "def recdd():",
            "    return dd(recdd)",
        ],
        "description": "無限defaultdict"
    },


	"dd初期値指定": {
		"prefix": "dd(lambda:-1)",
		"body": [
			"dd(lambda:-1)",
		],
		"description": "dd初期値指定"
	},	

	"itertools as itr": {
		"prefix": "import itertools as itr",
		"body": [
			"import itertools as itr",
		],
		"description": "itertools"
	},	

	"from copy import copy,deepcopy": {
		"prefix": "from copy import copy,deepcopy",
		"body": [
			"from copy import copy,deepcopy",
		],
		"description": "copy"
	},	


	"collections as col ": {
		"prefix": "import collections as col",
		"body": [
			"import collections as col",
		],
		"description": "collections"
	},	
	
	"functools": {
		"prefix": "import functools",
		"body": [
			"import functools",
		],
		"description": "functools"
	},	

	"from decimal import Decimal": {
		"prefix": "from decimal import Decimal",
		"body": [
			"from decimal import Decimal",
		],
		"description": "decimal"
	},	

	" from fractions import Fraction as F": {
        "prefix": " from fractions import Fraction as F",
        "body": [
            "from fractions import Fraction as F",
        ],
        "description": "分数モジュール"
    },


	"setrecursionlimit": {
		"prefix": "import sys",
		"body": [
			"import sys",
			"sys.setrecursionlimit(10**8)",
		],
		"description": "setrecursionlimit"
	},	

	"deque": {
		"prefix": "from collections import deque",
		"body": [
			"from collections import deque",
		],
		"description": "deque"
	},	

	"bisect": {
		"prefix": "from bisect import bisect",
		"body": [
			"from bisect import bisect",
		],
		"description": "bisect"
	},	
	
	"heapq": {
		"prefix": "from heapq import heapify,heappop as hpop,heappush as hpush",
		"body": [
			"from heapq import heapify,heappop as hpop,heappush as hpush",
		],
		"description": "heapq"
	},	


	"numpy": {
		"prefix": "import numpy as np",
		"body": [
			"import numpy as np",
		],
		"description": "numpy"
	},	


	"numba": {
		"prefix": "from numba import njit,i8",
		"body": [
			"from numba import njit,i8",
		],
		"description": "numba"
	},	

	"njit": {
		"prefix": "@njit((),cache=True)",
		"body": [
			"@njit(($1),cache=True)",
		],
		"description": "njit"
	},

	"標準入力": {
		"prefix": "import io",
		"body": [
			"################################################",
			"################################################",
			"import io",
			"import sys",
			"",
			"_INPUT = \"\"\"\\",
			"$1",
			"\"\"\"",
			"sys.stdin = io.StringIO(_INPUT)",
			"################################################",
			"################################################",
			"",
			"import sys",
			"input = lambda: sys.stdin.readline().rstrip()",
			"",
			"",
			"$2",
		],
		"description": "標準入力"
	},	

	"INF": {
		"prefix": "INF",
		"body": [
			"float('INF')",
		],
		"description": "INF"
	},

	"MOD=998244353": {
		"prefix": "MOD=998244353",
		"body": [
			"MOD=998244353",
		],
		"description": "MOD=998244353"
	},

	"MOD=10**9+7": {
		"prefix": "MOD=10**9+7",
		"body": [
			"MOD=10**9+7",
		],
		"description": "MOD=10**9+7"
	},

	"round": {
		"prefix": "round=lambda x:(x*2+1)//2",
		"body": [
			"round=lambda x:int((x*2+1)//2)",
		],
		"description": "roundを四捨五入にする"
	},	

	
	"popcount": {
		"prefix": "def popcount(N)",
		"body": [
			"def popcount(N):",
    		"return bin(N).count('1')",
		],
		"description": "2進数に直したときのon-bitを数える"
	},	

	"4方向カーソル": {
		"prefix": "cur=((1,0),(0,1),(-1,0),(0,-1))",
		"body": [
			"cur=((1,0),(0,1),(-1,0),(0,-1))",
		],
		"description": "4方向カーソル"
	},

	"8方向カーソル": {
		"prefix": "cur=((1,0),(1,1),(0,1),(-1,1),(-1,0),(-1,-1),(0,-1),(1,-1))",
		"body": [
			"cur=((1,0),(1,1),(0,1),(-1,1),(-1,0),(-1,-1),(0,-1),(1,-1))",
		],
		"description": "8方向カーソル"
	},

	"N行N列空リスト": {
		"prefix": "[[None] * N for i in range(N)]",
		"body": [
			"[[None] * N for i in range($1N)]",
			"$2",
		],
		"description": "N行N列空リスト"
	},	

	"降順sort": {
		"prefix": "sorted()",
		"body": [
			"sorted($1)",
		],
		"description": "降順sort"
	},

	"昇順sort": {
		"prefix": "sorted(,reverse=True)",
		"body": [
			"sorted($1,reverse=True)",
		],
		"description": "昇順sort"
	},

	"多次元sort": {
		"prefix": "sorted(A, reverse=True, key=lambda x: x[$11])",
		"body": [
			"sorted($1A, reverse=$2True, key=lambda x: x[$3])",
		],
		"description": "多次元sort"
	},

	"exit(0)": {
		"prefix": "exit(0)",
		"body": [
			"exit(0)",
		],
		"description": "exit(0)"
	},

	"unionfind": {
		"prefix": "unionfind",
		"body": [
			"import sys",
			"sys.setrecursionlimit(10**8)",
			"",
			"def find(x):",
			"	if par[x]!=x:",
			"		par[x]=find(par[x])" ,
			"	return par[x]",
			"",
			"def union(a,b):",
			"	a=find(a)",
			"	b=find(b)",
			"	if a==b:",
			"		return",
			"	if rank[a]<rank[b]:",
			"		a,b=b,a",
			"",
			"	par[b]=a",
			"	rank[a]+=rank[b]",
			"	rank[b]=rank[a]",
			"",
			"	return",
			"",
			"",
			"par=(list(range(N+1)))",
			"rank=[1 for _ in range(N+1)]",
		],
		"description": "unionfind"
	},
	"lcm(a,b)": {
		"prefix": "lcm(a,b)",
		"body": [
			"import math",
			"def lcm(a,b):",
			"	return (a*b)//math.gcd(a,b)",
		],
		"description": "lcm"
	},
	"comb(a,b)": {
		"prefix": "comb(a,b)",
		"body": [
			"from math import factorial",
			"def comb(n,r):",
			"	return factorial(n)//(factorial(n-r)*factorial(r))",
		],
		"description": "組合せ"
	},
	"extgcd(*n)": {
		"prefix": "extgcd(*n)",
		"body": [
			"from functools import reduce",
			"from math import gcd",
			"def extgcd(*n):",
			"	return reduce(gcd,n)",
		],
		"description": "3引数以上のGCD"
	},

	"list(map(lambda))": {
		"prefix": "list(map(lambda x:x-1",
		"body": [
			"$1=list(map(lambda x:x-1,$1))",
		],
		"description": "リストの各要素を-1する"
	},

	"ビット全探索": {
		"prefix": "itr.product(range(2),repeat=N)",
		"body": [
			"itr.product(range(2),repeat=N)",
		],
		"description": "ビット全探索用イテレータ"
	},


	"めぐる式二分探索": {
		"prefix": "def meguru_bisearch",
		"body": [
			"def judge(a):",
			"",
			"##ここに判定条件を書く",
			"	if :",
			"		return 1",
			"	else:",
			"		return 0",
			"",
			"##ng,okの条件に気をつける",
			"def meguru_bisearch(ng, ok):",
			"	while abs(ok-ng)>1:",
			"		mid=(ok+ng)//2",
			"		if judge(mid):",
			"			ok=mid",
			"		else:",
			"			ng=mid",
			"	return ok",
		],
		"description": "めぐる式二分探索"
	},

	"三分探索": {
		"prefix": "def trisearch",
		"body": [
			"def judge(c1,c2):",
			"",
			"##ここに判定条件を書く",
			"	if :",
			"		return 1",
			"	else:",
			"		return 0",
			"",
			"def trisearch(low, high,N):",
			"",
			"	##許容誤差をepsとする",
			"	eps=",
			"",
			"	while abs(high-low)>eps:",
			"		c1=(high+2*low)/3",
			"		c2=(2*high+low)/3",
			"		if judge(c1,c2):",
			"			low=c1",
			"		else:",
			"			high=c2",
			"	return low",
		],
		"description": "三分探索"
	},


	"lru_cache自動メモ化": {
		"prefix": "from functools import lru_cache",
		"body": [
			"from functools import lru_cache",
			"",
			"@lru_cache(maxsize=None)",
		],
		"description": "自動メモ化"
	},

	"深さ優先探索(再帰)": {
		"prefix": "def dfs(edge,k)",
		"body": [
			"from collections import defaultdict as dd",
			"",
			"##再帰を使ったDFS",
			"##行きがけの順番を配列d、帰りがけの順番を配列fに記録",
			"",
			"",
			"def dfs(edge,k):",
			"",
			"##行きがけで処理するときはこの辺でやる",
			"",
			"	global cnt",
			"	cnt+=1",
			"	d[k]=cnt",
			"	for i in edge[k]:",
			"		if d[i]!=-1:",
			"			continue",
			"		dfs(edge,i)",
			"",
			"",
			"##帰りがけで処理するときはこの辺でやる",
			"",
			"	cnt+=1",
			"	f[k]=cnt",
			"",
			"",
			"##有向グラフを辞書edgeに記録する",
			"n=int(input())",
			"edge=dd(list)",
			"",
			"for i in range(n):",
			"	u,k,*v=map(int,input().split())",
			"	for j in v:",
			"		edge[u].append(j)",
			"",
			"",
			"d=[-1 for _ in range(n+1)]",
			"f=[-1 for _ in range(n+1)]",
			"",
			"cnt=0",
			"for i in range(1,n+1):",
			"if d[i]==-1:",
			"	dfs(edge,i)",
			"",
			"",
		],
		"description": "深さ優先探索(再帰)"
	},


	"0-1 BFS": {
		"prefix": "def BFS(i,j)",
		"body": [
			"import sys",
			"sys.setrecursionlimit(10**8)",
			"",
			"",
			"def BFS(i,j):",
			"	cur=((1,0),(0,1),(-1,0),(0,-1))",
			"",
			"	for di,dj in cur:",
			"		if A[i][j]<=1 and A[i+di][j+dj]=='o':",
			"			A[i+di][j+dj]=A[i][j]",
			"			q.append((i+di,j+dj))",
			"",
			"		elif A[i+di][j+dj]=='x':",
			"			if A[i][j]<=1:",
			"				A[i+di][j+dj]=A[i][j]+1",
			"				q.appendleft((i+di,j+dj))",
			"",			
			"	if len(q)>0:",
			"		i,j=q.pop()",
			"		BFS(i,j)",
			"	else:",
			"		return",
		],
		"description": "0-1 BFS"
	},

	"繰り返し二乗法": {
		"prefix": "def reppow(x,n,mod)",
		"body": [
			"def reppow(x,n,mod):",
			"##(x**n)%modを繰り返し二乗法によって算出",
			"##pow(x,n,mod)と同じ",
			"",
			"	n=str(format(n,'b'))[::-1]",
			"	r=1",
			"	for i in n:",
			"		if i=='1':",
			"			r=(r*x)%mod",
			"		x=(x*x)%mod",
			"	return r",
		],
		"description": "繰り返し二乗法"
	},

	"floorsum": {
		"prefix": "def floorsum(n,m,a,b):",
		"body": [
			
			"import sys",
			"sys.setrecursionlimit(10**8)",
			"", 
			"##y=(ax+b)/M　(0<x<=n)以下の格子点の数を求める",
			"def floorsum(n,m,a,b):",
			"	ans=0",
			"	if a>=m:",
			"		ans+=(n-1)*n*(a//m)//2",
			"		a%=m",
			"	if b>=m:",
			"		ans+=n*(b//m)",
			"		b%=m",
			"", 
			"	y_max=(a*n+b)//m",
			"	x_max=(y_max*m-b)",
			"	if y_max==0:",
			"		return ans",
			"",	
			"	ans+=(n-(x_max+a-1)//a)*y_max",
			"	ans+=floorsum(y_max,a,m,(a-x_max%a)%a)",
			"	return ans",
		],
		"description": "floorsum"
	},
	
	"def Miller_Rabin": {
        "prefix": "def Miller_Rabin",
        "body": [
            "##ミラーラビン素数判定法",
            "##素数ならTrue,非素数ならFalseを返す",
            "def Miller_Rabin(N):",
            "",
            "    ##1は非素数",
            "    if N==1:",
            "        return False",
            "",
            "    ##2は素数その他2の倍数は合成数",
            "    if N%2==0:",
            "        if N==2:",
            "            return True",
            "        else:",
            "            return False",
            "",
            "    ##偶数は篩落としたのでNは奇数でありN-1は偶数となる",
            "    ##ここでN-1を2^s*dと表すこととする",
            "    temp=N-1",
            "    s=0",
            "    while temp%2==0:",
            "        temp//=2",
            "        s+=1",
            "    d=(N-1)//(2**s)",
            "",
            "    ##比較対象リスト",
            "    ##2^32未満なら2,7,61",
            "    ##2^64未満なら37までの素数を使う",
            "    ##それ以上は2以上N未満の乱数50個を使う",
            "",
            "    if N<2**32:",
            "        complist=(2,7,61)",
            "    elif N<2**64:",
            "        complist=(2,3,5,7,11,13,17,19,23,29,31,37)",
			"        ##(2, 325, 9375, 28178, 450775, 9780504, 1795265022)",
			"        ##でもいいっぽい",
            "    else:",
            "        from random import randint",
            "        complist=set()",
            "        while len(complist)<50:",
            "            complist.add(randint(2,N-1))",
            "",
            "    ##aをcomplist中の数字でそれぞれ試してみる",
            "    for a in complist:",
            "        if N<=a:break",
            "",
            "        ##(a^d)%N=1ならこのaについてはミラーラビンテスト合格",
            "        if pow(a,d,N)==1:",
            "            continue",
            "",
            "        ##0<=r<sを満たす(a^(d*(2^r)))%Nを見ていき",
            "        ##-1≡N-1を満たすものが1つでもあればこのaについてミラーラビンテスト合格",
            "        ##1つもなければその時点で不合格(非素数)",
            "        for r in range(s):",
            "            temp=pow(a,d*(2**r),N)",
            "            if temp==N-1:",
            "                break",
            "        else:",
            "            return False",
            "",
            "    ##すべてのaについてミラーラビンテストが合格したならおそらく素数と判定できる",
            "    return True",
        ],
        "description": "ミラーラビン素数判定法"
    },


	"線形篩": {
		"prefix": "def prime(N):",
		"body": [
			"def prime(N):",
			"	##Pをsetに変えたらアカン",
			"	P=[]",
			"	f=[0 for _ in range(N+1)]",
			"",
			"	for i in range(2,N+1):",
			"	    if f[i]==0:",
			"			P.append(i)",
			"			f[i]=i",
			"",
			"    	for j in P:",
			"       	if i*j>N  or j>f[i] :",
			"           	break",
			"       	f[i*j]=j",
			"",
			"	return P",

		],
		"description": "線形篩"
	},

	"素因数分解": {
		"prefix": "def fact(N):",
		"body": [
			"from collections import defaultdict as dd",
			"",
			"def fact(N):",
			"	P=[]",
			"	temp = N",
			"",
			"	for i in range(2, int(N**0.5)+1):",
			"		if temp%i==0:",
			"			cnt=0",
			"			while temp%i==0:",
			"				cnt+=1",
			"				temp //= i",
			"			P.append([i, cnt])",
			"",
			"	if temp!=1:",
			"		P.append([temp, 1])",
			"",
			"	if P==[]:",
			"		P.append([N, 1])",
			"",
			"	return P",

		],
		"description": "素因数分解"
	},

	"約数列挙": {
		"prefix": "def divenum(N):",
		"body": [
			"##約数列挙",
			"def divenum(N):
			"	D=[N]",
			"	for i in range(2, int(N**0.5)+1):",
			"		if N%i==0:",
			"			D.append(i)",
			"			D.append(N//i)",
			"",
			"	D=sorted(D)",
			"	return D",

		],
		"description": "約数列挙"
	},



    "def rot2d90deg(rootx,rooty,x,y)": {
        "prefix": "def rot2d90deg(rootx,rooty,x,y)",
        "body": [
            "##二次元座標回転",
            "##座標x,yをrootx,rootyに対して90[deg]回転する",
            "def rot2d90deg(rootx,rooty,x,y):",
            "    x-=rootx",
            "    y-=rooty",
            "",
            "    x=-y",
            "    y=x",
            "",
            "    x+=rootx",
            "    y+=rooty",
            "",
            "    return x,y",
        ],
        "description": "2次元座標90度回転"
    },

    "def rot2d(rootx,rooty,x,y,th):": {
        "prefix": "def rot2d(rootx,rooty,x,y,th):",
        "body": [
            "from math import sin,cos,pi",
            "",
            "##2次元座標回転",
            "##座標x,yをrootx,rootyに対してth[rad]回転する",
            "def rot2d(rootx,rooty,x,y,th):",
            "",
            "    x-=rootx",
            "    y-=rooty",
            "",
            "    x=x*cos(th)-y*sin(th)",
            "    y=x*sin(th)+y*cos(th)",
            "",
            "    x+=rootx",
            "    y+=rooty",
            "",
            "    return x,y",
        ],
        "description": "2次元座標回転"
    },

    "def grid_r_rot(A)": {
        "prefix": "def grid_r_rot(A)",
        "body": [
            "##2次元行列Aを時計回りに回転する",
            "##zip版",
            "def grid_r_rot(A):",
            "    return list(zip(*A[::-1]))",
            "",
            "##普通に行列操作する(少し速い?)",
            "def grid_r_rot1(A):",
            "    N=len(A)",
            "    M=len(A[0])",
            "    retA=[[None for _ in range(N)]for _ in range(M)]",
            "",
            "    for i in range(N):",
            "        for j in range(M):",
            "            retA[j][N-i-1]=A[i][j]",
            "",
            "    return retA",
        ],
        "description": "座標右回転"
    },


    "def grid_l_rot(A)": {
        "prefix": "def grid_l_rot(A)",
        "body": [
            "##2次元行列Aを反時計回りに回転する",
            "##zip版",
            "def grid_l_rot(A):",
            "    return list(zip(*A))[::-1]",
            "",
            "##普通に行列操作する(少し速い?)",
            "def grid_l_rot1(A):",
            "    N=len(A)",
            "    M=len(A[0])",
            "    retA=[[None for _ in range(N)]for _ in range(M)]",
            "",
            "    for i in range(N):",
            "        for j in range(M):",
            "            retA[N-j-1][i]=A[i][j]",
            "",
            "    return retA",
        ],
        "description": "座標左回転"
    },



    "def prdmat(A,B):": {
        "prefix": "def prdmat(A,B):",
        "body": [
            "##N行M列の行列AとM行K列の行列Bの行列積Cを計算する",
            "def prdmat(A,B):",
            "",
            "    global MOD",
            "",
            "    N=len(A)",
            "    M=len(A[0])",
            "    M1=len(B)",
            "    K=len(B[0])",
            "",
            "    assert M==M1",
            "",
            "    ##Bを転置する",
            "    tB=transmat(B)",
            "",
            "    ##行列積CはN行K列となる",
            "    C=[[0 for _ in range(K)] for _ in range(N)]",
            "",
            "    for i in range(N):",
            "        a=A[i]",
            "        for j in range(K):",
            "            b=tB[j]",
            "            temp=0",
            "            for k in range(M):",
            "                temp+=(a[k]*b[k])%MOD",
            "                temp%=MOD",
            "            C[i][j]=temp",
            "    return C",
        ],
        "description": "行列積"
    },

    "def reppowmat(A,n):": {
        "prefix": "def reppowmat(A,n):",
        "body": [
            "##繰り返し二乗法によって行列累乗を求める",
            "def reppowmat(A,n):",
            "",
            "    n=str(format(n,'b'))[::-1]",
            "    ",
            "    ##単位行列を作る",
            "    l=len(A)",
            "    ret=[[0 for _ in range(l)] for _ in range(l)]",
            "    for i in range(l):",
            "        ret[i][i]=1",
            "",
            "    for i in n:",
            "        if i=='1':",
            "            ret=prdmat(ret,A)",
            "        A=prdmat(A,A)",
            "",
            "    return ret",
        ],
        "description": "行列累乗"
    },

    "def closs(px,py,ax,ay,bx,by)": {
        "prefix": "def cross(px,py,ax,ay,bx,by)",
        "body": [
            "##P=(px,py),A=(ax,ay),B=(bx,by)に対して",
            "##ベクトルPA,PBの外積PA×PBを計算する",
            "def cross(px,py,ax,ay,bx,by):",
            "    PA=(ax-px,ay-py)",
            "    PB=(bx-px,by-py)",
            "    return PA[0]*PB[1]-PA[1]*PB[0]",
        ],
        "description": "3点に対する外積"
    },


    "def calc_rank(A):": {
        "prefix": "def calc_rank(A):",
        "body": [
            "def calc_rank(A):",
            "    N=len(A)",
            "    A=progress_elimination(A)",
            "",
            "    res=0",
            "    for i in range(N):    ",
            "        if A[i][i]!=0:",
            "            res+=1",
            "",
            "    return res",
        ],
        "description": "行列ランク計算"
    },

    "def progress_elimination(A):": {
        "prefix": "def progress_elimination(A):",
        "body": [
            "##前進消去",
            "def progress_elimination(A):",
            "    global MOD",
            "",
            "    N=len(A)",
            "    assert N==len(A[0])",
            "    res=1",
            "    rank=N",
            "    for i in range(N):",
            "        ##A[i][i]=0なら同じ行で非ゼロの",
            "        ##他の列と入れ替えができないか探す",
            "        if A[i][i]==0:",
            "            for j in range(i+1,N):",
            "                if A[i][j]!=0:",
            "                    ##非ゼロの列があればj列とi列入れ替え",
            "                    ##置換に伴う符号反転-1を行列式の外にかけておく",
            "                    for k in range(N):",
            "                        A[k][j],A[k][i]=A[k][i]%MOD,A[k][j]%MOD",
            "                        res*=-1",
            "                    break",
            "            else:",
            "                ##無ければ仕方ないのでcontinue",
            "                ##rankを1減らして行列式の値も0とする",
            "                res*=0",
            "                rank-=1",
            "                continue",
            "",
            "",
            "        ##A[i][i]のMOD逆元を求めてA[i][i]=1とするため",
            "        ##Aのi行目の各要素をA[i][i]で割る=revAiをかける",
            "        ##この時行列式の外に出すA[i][i]をresにかける",
            "",
            "        revAi=pow(A[i][i],MOD-2,MOD)",
            "        res=(res*A[i][i])%MOD",
            "        for k in range(i,N):",
            "            A[i][k]=A[i][k]*revAi%MOD",
            "        ",
            "        ##A[j]行の各要素から(A[i]の各要素*A[j][i])を引いていき",
            "        ##Aのi+1行目以降j列を0にしていく",
            "        for j in range(i+1,N):",
            "            if A[j][i]==0:",
            "                continue",
            "",
            "            jmul=A[j][i]",
            "            ##Aのj(i<j<N)行目の各要素A[j][k]からA[i][k]*jmul倍したものを引いていく",
            "            for k in range(i,N):",
            "                A[j][k]=(A[j][k]-jmul*A[i][k])%MOD",
            "                ",
            "        #for a in A:",
            "        #    print(a)",
            "",
            "    return A,res",
        ],
        "description": "行列式,前進消去"
    },

    "def invmat(A):": {
        "prefix": "def invmat(A):",
        "body": [
            "MOD=998244353",
            "##N行N列の正方行列Aに対してAB=Eとなる行列Bを掃き出し法にて求める",
            "def invmat(A):",
            "",
            "    ",
            "    N=len(A)",
            "    assert N==len(A[0])",
            "",
            "    ##単位行列Bを用意する",
            "    B=[[0 for _ in range(N)] for _ in range(N)]",
            "    for i in range(N):",
            "        B[i][i]=1",
            "",
            "",
            "    for i in range(N):",
            "        ##A[i][i]=0ならi列が非ゼロの",
            "        ##他の行を足せないか探す",
            "        if A[i][i]==0:",
            "            for j in range(i+1,N):",
            "                if A[j][i]!=0:",
            "                    ##i列が非ゼロの行があればその行の値を足す",
            "                    for k in range(N):",
            "                        A[i][k]=(A[j][k]+A[i][k])%MOD",
            "                        B[i][k]=(B[j][k]+B[i][k])%MOD",
            "                    break",
            "            else:",
            "                ##無ければrank!=Nであり逆行列は存在しない",
            "                return -1",
            "",
            "        ##前進消去を行う",
            "        ##A[i][i]=1とするためA[i][i]のMOD逆元revAiを求めて",
            "        ##Aのi行目の各要素をA[i][i]で割る=revAiをかける",
            "        ##Bのi行目も同様に操作する",
            "        revAi=pow(A[i][i],MOD-2,MOD)",
            "        for k in range(N):",
            "            A[i][k]=A[i][k]*revAi%MOD",
            "            B[i][k]=B[i][k]*revAi%MOD",
            "",
            "        ##A[j]行の各要素から(A[i]の各要素*A[j][i])を引いていき",
            "        ##i行目以外のj列を0にしていく",
            "        for j in range(N):",
            "            if j==i or A[j][i]==0:",
            "                continue",
            "",
            "            jmul=A[j][i]",
            "            ##Aのj行目の各要素A[j][k]からA[i][k]*jmul倍したものを引いていく",
            "            ##Bの方も同様に操作する",
            "            for k in range(N):",
            "                A[j][k]=(A[j][k]-jmul*A[i][k])%MOD",
            "                B[j][k]=(B[j][k]-jmul*B[i][k])%MOD",
            "",
            "    return B",
        ],
        "description": "逆行列"
    },

    "def transmat(A):": {
        "prefix": "def transmat(A):",
        "body": [
            "##N行M列の行列AをM行N列の行列transAに転置する",
			"##return list(zip(*A))と同じ",
            "def transmat(A):",
            "",
            "    N=len(A)",
            "    M=len(A[0])",
            "",
            "    transA=[[0 for _ in range(N) ] for _ in range(M)]",
            "    for i in range(N):",
            "        for j in range(M):",
            "            transA[j][i]=A[i][j]",
            "",
            "    return transA",
        ],
        "description": "行列転置"
    },


    "def LUdecomp(mat):": {
        "prefix": "def LUdecomp(mat)",
        "body": [
            "##LU分解する",
            "##逆元としてMOD逆元を使う",
            "##下三角行列の対角成分を1とするドゥーリトル法",
            "##判定は入れていないが首座行列式が0となるものがあれば分解不能",
            "def LUdecomp(mat):",
            "    global MOD",
            "",
            "    N=len(mat)",
            "    assert N==len(mat[0])",
            "",
            "    L=[[0 for _ in range(N)] for _ in range(N)]",
            "    U=[[0 for _ in range(N)] for _ in range(N)]",
            "",
            "    ##横⇒縦⇒横⇒縦⇒…で埋めていく",
            "    for i in range(N):",
            "        #Lの対角成分は1",
            "        L[i][i]=1",
            "",
            "        ##i行目の横を見ていく",
            "        for j in range(i,N):",
            "            temp=0",
            "            for k in range(i):",
            "                temp+=U[k][j]*L[i][k]",
            "                temp%=MOD",
            "            #print(\"U\",i,j)",
            "            U[i][j]=(mat[i][j]-temp)%MOD",
            "",
            "        ##i列目の縦を見ていく",
            "        ##U[i][i]のMOD逆元を求める",
            "        revU=pow(U[i][i],MOD-2,MOD)",
            "        for j in range(i+1,N):",
            "            temp=0",
            "            for k in range(i):",
            "                temp+=U[k][i]*L[j][k]",
            "                temp%=MOD",
            "",
            "            #print(\"L\",j,i)",
            "            L[j][i]=((mat[j][i]-temp)*revU)%MOD",
            "",
            "    return L,U",
        ],
        "description": "LU分解"
    },

    "def BFS(i)": {
        "prefix": "def BFS(i)",
        "body": [
            "import sys",
            "sys.setrecursionlimit(10**8)",
            "from collections import defaultdict as dd,deque",
            "",
            "##N頂点,M本の辺に対する幅優先探索",
            "##chkに始点1からの距離を入れていく",
            "def BFS(i):",
            "    for s,t in edge[i]:",
            "        q.append((s,t))",
            "",
            "    while len(q):",
            "        s,t,iii=q.popleft()",
            "        if chk[t]==INF :",
            "            chk[t]=chk[s]+1",
            "    return",
            "",
            "",
            "N,M=map(int,input().split())",
            "",
            "edge=dd(list)",
            "for i in range():",
            "    s,t=map(int,input().split())",
            "    edge[s].append((s,t))",
            "",
            "INF=float('INF')",
            "chk=[INF for _ in range(N+1)]",
            "chk[1]=0",
            "q=deque()",
            "",
            "BFS(1)",
        ],
        "description": "シンプルなBFS"
    },


	"クラスカル法": {
		"prefix": "def kruskal(edge):",
		"body": [
			"##Union-Findと一緒に使う##"
			"##辺a,bを結ぶ重みwの辺を##"
			"##edge[i]=[a,b,w]の形で持っておく##"
			"##重みの総和ansを返す##"
			"##選ばれた辺をTに書き留める##"
			"",
			"def kruskal(edge):",
			"",
			"	edge=sorted(edge, reverse=False, key=lambda x: x[2])",
			"	ans=0",
			"	T=[]",
			"",
			"	for a,b,w in edge:",
			"		par[a]=find(a)",
			"		par[b]=find(b)",
			"		if par[a]==par[b]:",
			"			continue",
			"		else:",
			"			T.append([a,b,w])",
			"			ans+=w",
			"			union(a,b)",
			"",
			"	return ans",
			"",
			"",
		],
		"description": "クラスカル法"
	},

	"プリム法": {
		"prefix": "def prim(edge):",
		"body": [
			"##辺a,bを結ぶ重みwの辺を##",
			"##dict型edge[a]=[b,w],edge[b]=[a,w]の形で持っておく##",
			"##適当な点からスタートし確定している点から##",
			"##コストが最小の辺を調べ次の点を確定させる##",
			"##確定した点は配列chkに1を書き込む##",
			"##コストが最小となる辺はheapqによって管理する##",
			"",	
			"",	
			"from collections import defaultdict as dd",
			"from heapq import heappop as hpop,heappush as hpush",
			"",	
			"q=[]",
			"for k,w in edge[0]:",
			"	hpush(q,(w,k))",
			"",
			"chk=[0 for _ in range(N+1)]",
			"chk[0]=1",
			"ans=0",
			"",
			"while len(q):",
			"	w,k=hpop(q)",
			"	if chk[k]==0:",
			"		chk[k]=1",
			"		d+=1",
			"		ans+=w",
			"		for m,w in edge[k]:",
			"			hpush(q,(w,m))",
			"",
			"print(ans)",
			"",
		],
		"description": "プリム法"
	},


    "ダイクストラ法": {
        "prefix": "dijkstra",
        "body": [
            "",
            "##dijkstra法",
            "",
            "def dijkstra(start):",
            "    ##costに始点から見た高さを記録する",
            "    ##最初はINFで初期化しておく",
            "    cost=[INF for _ in range(N+1)]",
            "    cost[start]=0",
            "    chk=[False for _ in range(N+1)]",
            "    res=0",
            "    ##qをheapqとして使う",
            "    q=[]",
            "",
            "    hpush(q,(0,start))",
            "",
            "    ##heapqで近い順に値を決定していく",
            "    while len(q):",
            "        c,s=hpop(q)",
            "        if chk[s]==True:continue",
            "        chk[s]=True",
            "        for nowc,t in edge[s]:",
            "            if c+nowc<cost[t]:",
            "                cost[t]=c+nowc",
            "                hpush(q,(c+nowc,t))",
            "",
            "    return res",
            "",
            "##edgeに重さw、終点tをタプルで記録する",
            "edge=dd(list)",
            "for _ in range(#クエリの数):",
            "    w,u,v=map(int,input().split())",
            "    edge[u].append((w,v))",
            "    edge[v].append((w,u))",
            "",
            "dijkstra(1)",
        ],
        "description": "ダイクストラ法"
    },


    "fenwicktree": {
        "prefix": "class fenwick",
        "body": [
            "##1-indexedのFenwickTree",
            "##区間和とxorに対応",
            "class fenwick:",
            "    ##配列fwを要素数nで初期化する",
            "    def __init__(self, n):",
            "        self.size = n",
            "        self.tree = [0] * (n+1)",
            "",
            "    ##iにxを加算する",
            "    def add(self, i, x):",
            "        assert 1<=i<=self.size",
            "        while i <= self.size:",
            "            self.tree[i] += x",
            "            ##LSBを加算して次のインデックスを求める",
            "            i += i & -i",
            "",
            "    ##iにxをxorする",
            "    def xoradd(self, i, x):",
            "        assert 1 <= i <= self.size",
            "        while i <= self.size:",
            "            self.tree[i] ^= x",
            "            i += i & -i",
            "",
            "    ##[l,r]の区間和を取得する",
            "    ##[0,r]から[0,l]を引く",
            "    def sum(self, l, r):",
            "        assert 0 <= l <= r <= self.size",
            "        return self.sum0(r) - self.sum0(l)",
            "",
            "    ##[0,r]の総和を取得する",
            "    def sum0(self, r):",
            "        s = 0",
            "        while r > 0:",
            "            s += self.tree[r]",
            "            r -= r & -r",
            "        return s",
            "",
            "    ##[l,r]のxorを取得する",
            "    ##[0,r]と[0,l]のxorを取る",
            "    def xorsum(self, l, r):",
            "        assert 0 <= l <= r <= self.size",
            "        return self.xorsum0(r)^self._xorsum0(l-1)",
            "",
            "    ##[0,r]のxorを取得する",
            "    def xorsum0(self, r):",
            "        s = 0",
            "        while r > 0:",
            "            s ^= self.tree[r]",
            "            r -= r & -r",
            "        return s",
        ],
        "description": "フェニック木"
    },

    "segtree": {
        "prefix": "segtree",
        "body": [
            "n2=1",
            "while (n2<=N+2): n2*=2",
            "segtree=[set() for _ in range(2*n2-1)]",
        ],
        "description": "セグメント木初期化"
    },


    "def get_range_pos(s,e):": {
        "prefix": "def get_range_pos(s,e):",
        "body": [
            "##[s,e]の区間を取得する",
            "def get_range_pos(s,e):",
            "    s+=n2",
            "    e+=n2",
            "    poslist=[]",
            "    while s<e:",
            "        if s%2!=0:",
            "            poslist.append(s)",
            "            s+=1 ",
            "        s//=2",
            "        if e%2!=0:",
            "            e-=1",
            "            poslist.append(e)",
            "        e//=2",
            "",
            "    return poslist",
        ],
        "description": "セグメント木区間取得"
    },



	"根付き木作成": {
		"prefix": "edge=dd(list)",
		"body": [
			"from collections import defaultdict as dd,deque",
			"",
			"",
			"##各頂点とつながる辺を辞書edgeに記録する",
			"edge=dd(list)",
			"for _ in range(N-1):",
			"	a,b=map(int,input().split())",
			"	edge[a].append(b)",
			"	edge[b].append(a)",
			"",
			"##根を1として根からの深さを配列depthで管理する",
			"depth=[-1]*(N+1)",
			"depth[1]=0",
			"",
			"##dequeを使い根からBFSによってdepthを埋めていく",
			"q=deque()",
			"q.append(1)",
			"",
			"##あとでimos法の値を伝搬させるために子を配列sonに記録しておく",
			"son=dd(list)",
			"",
			"while len(q)>0:",
			"	temp=q.pop()",
			"	for i in edge[temp]:",
			"		if depth[i]==-1: ",
			"			depth[i]=depth[temp]+1",
			"			son[temp].append(i)",
			"			q.append(i)",
			"",
			"",

		],
		"description": "根付き木作成"
	},

	"トポロジカルソート": {
		"prefix": "def topsort(edge,v)",
		"body": [
			"import sys",
			"sys.setrecursionlimit(10**8)",
			"from collections import defaultdict as dd",
			"",
			"def topsort(edge,v):",
			"	seen[v]=True",
			"	for i in edge[v]:",
			"		if seen[i]==True:",
			"			continue",
			"		topsort(edge,i)",
			"",
			"	order.append(v)",
			"",
			"edge=dd(list)",
			"V,E=map(int,input().split())",
			"",
			"for _ in range(E):",
			"	s,t=map(int,input().split())",
			"	edge[s].append(t)",
			"",
			"seen=[False]*(V)",
			"order=[]",
			"",
			"for i in range(V):",
			"	if seen[i]==True:",
			"		continue",
			"	topsort(edge,i)",
			"",
			"order=order[::-1]",
			"",
			"for ans in order:",
			"	print(ans)",
			"",
			"",
		],
		"description": "トポロジカルソート"
	},

}
