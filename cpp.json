{
	// Place your snippets for cpp here. Each snippet is defined under a snippet name and has a prefix, body and 
	// description. The prefix is what is used to trigger the snippet and the body will be expanded and inserted. Possible variables are:
	// $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. Placeholders with the 
	// same ids are connected.
	// Example:
	// "Print to console": {
	// 	"prefix": "log",
	// 	"body": [
	// 		"console.log('$1');",
	// 		"$2"
	// 	],
	// 	"description": "Log output to console"
	// }
	"#include std": {
	"prefix": "#include std",
	"body": [
		"#include <bits/stdc++.h>",	
		"using namespace std;",
		"#define rep(i, n) for (int i = 0; i < int(n); i++)",
		"",
		"int main() {",
		"    ios::sync_with_stdio(false);",
		"    cin.tie(nullptr);",
        "",
		"    $1",
        "",
		"}",
	],
	"description": "#include std"
	},

	"#include atcoder": {
		"prefix": "#include atcoder",
		"body": [
			"#include <atcoder/all>",
			"using namespace atcoder;",
		],
		"description": "#include atcoder"
		},

	"#include SRM": {
		"prefix": "#include SRM",
		"body": [
			"#include <bits/stdc++.h>",
			"using namespace std;",
			"",
			"class classname{",
			"   public:",
			"   int methodname(int inputchar){",
			"       int ans;",
			"       return  ans;",
			"   }",
			"};",
		],
		"description": "#include SRM"
		},

	"cf": {
		"prefix": "cf",
		"body": [
			"#include <bits/stdc++.h>",
			"using namespace std;",
			"#define rep(i, n) for (int i = 0; i < int(n); i++)",
			"",
			"void solve(){",
			"",
			"    return;",
			"}",
			"",
			"int main() {",
			"    ios::sync_with_stdio(false);",
			"    cin.tie(nullptr);",
			"",
			"    int t;",
			"    cin >> t;",
			"",
			"    rep(_,t) solve();",
			"}",
		],
		"description": "CF用テンプレート"
	},

    "GCJ": {
        "prefix": "GCJ",
        "body": [
            "#include <bits/stdc++.h>",
            "using namespace std;",
            "#define rep(i, n) for (int i = 0; i < int(n); i++)",
            "",
            "void solve(int casenum){",
            "",
            "    ",
            "",
            "    int res=0;",
            "",
            "    cout << \"Case #\"<< casenum+1 << \":\" << res << \"\\n\";",
            "    return;",
            "}",
            "",
            "int main() {",
            "    ios::sync_with_stdio(false);",
            "    cin.tie(nullptr);",
            "",
            "    int t;",
            "    cin >> t;",
            "",
            "    rep(i,t) solve(i);",
        ],
        "description": "GCJ用テンプレート"
    },
	
	"longlong型定義": {
		"prefix": "using i64 = long long",
		"body": [
			"using i64 = long long;",
		],
		"description": "longlong型定義"
	},

    "int128型定義": {
        "prefix": "using i128 = __int128",
        "body": [
            "using i128 = __int128;",
        ],
        "description": "int128型定義"
    },


    "#define elif": {
        "prefix": "#define elif",
        "body": [
            "#define elif else if",
        ],
        "description": "elif定義"
    },

    "constexpr int INF": {
        "prefix": "constexpr int INF",
        "body": [
            "constexpr int INF=1234567890;",
        ],
        "description": "INF宣言"
    },

    "constexpr i64 INF": {
        "prefix": "constexpr i64 INF",
        "body": [
            "constexpr i64 INF=1234567890987654321;",
            "",
        ],
        "description": "i64のINF"
    },


    "constexpr double eps": {
        "prefix": "constexpr double eps",
        "body": [
            "constexpr double eps=0.000001;",
        ],
        "description": "eps宣言"
    },

    "constexpr int MOD=998244353;": {
        "prefix": "constexpr int MOD=998244353;",
        "body": [
            "constexpr int MOD=998244353;",
        ],
        "description": "MOD=998244353"
    },

    "constexpr int MOD=1000000007;": {
        "prefix": "constexpr int MOD=1000000007;",
        "body": [
            "constexpr int MOD=1000000007;",
        ],
        "description": "MOD=1000000007"
    },

	"using str": {
		"prefix": "using str",
		"body": [
			"using str = string;",
		],
		"description": "using str"
	},

    "using P=pair<int,int>": {
        "prefix": "using P=pair<int,int>",
        "body": [
            "using P=pair<int,int>",
        ],
        "description": "using pair"
    },

    "ACLのmint": {
        "prefix": "using mint",
        "body": [
            "using mint = modint998244353;",
        ],
        "description": "ACLのmint"
    },


    "ビット長さ": {
        "prefix": "bit_length",
        "body": [
            "template <typename T>",
            "int bit_length(T i){return (1<<6)-__builtin_clzll(i);}",
        ],
        "description": "ビット長さを求める"
    },


	"#define rep(i,n)": {
		"prefix": "#define rep(i,n)",
		"body": [
			"#define rep(i,n) for (int i = 0; i < int(n); i++)",
		],
		"description": "rep"
	},
			
	"#define rrep(i,n)": {
		"prefix": "#define rrep(i,n)",
		"body": [
			"#define rrep(i,n) for (int i = int(n)-1; 0<=i; i--)",
		],
		"description": "逆順rep"
	},
	

	"#define repst(i,s,t)": {
		"prefix": "#define repst(i,s,t)",
		"body": [
			"#define repst(i, s, t) for (int i = int(s); i < int(t); i++)",
		],
		"description": "3引数rep"
		},
    
    "入力基本": {
        "prefix": "cin",
        "body": [
            "cin >> $1 ;",
        ],
        "description": "cin"
    },
        

    "出力基本": {
        "prefix": "cout",
        "body": [
            "cout << $1 << \"\\n\";",
        ],
        "description": "cout"
    },


    "setprecision": {
        "prefix": "setprecision",
        "body": [
            "cout << fixed << setprecision(8);",
        ],
        "description": "小数以下出力桁数指定"
    },

    "f=trueならYesを出力": {
        "prefix": "(f?\"Yes\":\"No\")",
        "body": [
            "(f?\"Yes\":\"No\")",
        ],
        "description": "f=trueならYesを出力"
    },

    "aを0に変換": {
        "prefix": "a20",
        "body": [
            "int a20(char a){return a-'a';}",
        ],
        "description": "aを0に変換"
    },

    "回文判定": {
        "prefix": "bool Palindrome_chk",
        "body": [
            "// 回文判定",
            "bool Palindrome_chk(string S){",
            "",
            "    int N=size(S);",
            "    rep(i,N>>1) if (S[i]!=S[N-i-1])return false;",
            "    return true;",
            "",
            "}",
        ],
        "description": "回文判定"
    },



    "print": {
        "prefix": "print",
        "body": [

            "// python風print関数",
            "",
            "// プロトタイプ宣言",
            "template <typename H, typename ... T> void print(ostream &os, H&& h, T&&... t);",
            "template <typename... T> void print(T&&... t);",
            "",
            "// 末尾の改行",
            "void print(ostream &os) {os << \"\\n\";}",
            "",
            "// 先頭にcout,cerrなどをつける",
            "template <typename H, typename ... T>",
            "void print(ostream &os, H&& h, T&&... t)",
            "{",
            "    os << h;",
            "    if constexpr (sizeof...(t) > 0) os << \" \";",
            "    print(forward<T> (t)...);",
            "}",
            "",
            "// 先頭に何もつけない場合はcout",
            "template <typename... T>",
            "void print(T&&... t) {",
            "    print(cout, forward<T>(t)...);",
            "}",
            "",
        ],
        "description": "可変引数print"
    },

    "printvec": {
        "prefix": "printvec",
        "body": [
            "template <typename H>",
            "void printvec(H&& h){",
            "    for (auto a:h) cout << a << \" \";",
            "    cout <<\"\\n\";",
            "}",
        ],
        "description": "vector print"
    },

    "デバッグ用出力": {
        "prefix": "debug",
        "body": [
            "// デバッグ出力用関数",
            "",
            "// プロトタイプ宣言",
            "template<typename T> ostream &operator<<(ostream &os, const vector<T> &V);",
            "template<typename T> ostream &operator<<(ostream &os, const vector<vector<T>> &VV);",
            "template<typename T, int sz> typename enable_if<!is_same<T, char>::value, ostream&>::type operator<<(ostream &os, const T (&A)[sz]);",
            "template<typename T1, typename T2>ostream &operator<<(ostream &os, const pair<T1, T2> &p);",
            "template<typename... Types> ostream &operator<<(ostream &os, const tuple<Types...> &tup);",
            "template<typename T>ostream &operator<<(ostream &os, const set<T> &s);",
            "template<typename T>ostream &operator<<(ostream &os, const multiset<T> &s);",
            "template<typename T>ostream &operator<<(ostream &os, const unordered_set<T> &s);",
            "template<typename T>ostream &operator<<(ostream &os, const unordered_multiset<T> &s);",
            "template<typename K, typename V>ostream &operator<<(ostream &os, const map<K, V> &m);",
            "template<typename K, typename V>ostream &operator<<(ostream &os, const unordered_map<K, V> &m);",
            "template<typename T>ostream &operator<<(ostream &os, queue<T> q);",
            "template<typename T>ostream &operator<<(ostream &os, stack<T> s);",
            "template<typename T>ostream &operator<<(ostream &os, const deque<T> &q);",
            "template<typename T,typename Tc1,typename Tc2>ostream &operator<<(ostream &os, priority_queue<T,Tc1,Tc2> q);",
            "",
            "// vector",
            "template <typename T>",
            "ostream &operator<<(ostream &os, const vector<T> &V){",
            "    int l=size(V);",
            "    os << \"[\";",
            "    rep(i,l)os << V[i] << (i<l-1?\" \":\"]\\n\");  ",
            "",
            "    return os;",
            "}",
            "",
            "// 2次元vector",
            "template<typename T>",
            "ostream &operator<<(ostream &os, const vector<vector<T>> &VV) {",
            "    for (const auto &V: VV) os << V ;",
            "    return os;",
            "}",
            "",
            "// Cスタイル配列(char配列はおかしくなるので除く)",
            "template<typename T, int sz>",
            "typename enable_if<!is_same<T, char>::value, ostream&>::type",
            "operator<<(ostream &os, const T (&A)[sz]) {",
            "    os << \"[\";",
            "    rep(i,sz) {",
            "        os << A[i] << (i<sz-1?\" \":\"]\\n\");",
            "    }",
            "    return os;",
            "}",
            "// pair",
            "template<typename T1, typename T2>",
            "ostream &operator<<(ostream &os, const pair<T1, T2> &p) {",
            "    os << \"(\" << p.first << \", \" << p.second << \")\";",
            "    return os;",
            "}",
            "",
            "// tuple",
            "template<typename... Types>",
            "ostream &operator<<(ostream &os, const tuple<Types...> &tup) {",
            "    os << \"(\";",
            "    apply([&os](const Types&... args) {",
            "        size_t i = 0;",
            "        ((os << (i++ ? \", \" : \"\") << args), ...);",
            "    }, tup);",
            "    os << \")\";",
            "    return os;",
            "}",
            "",
            "// set",
            "template<typename T>",
            "ostream &operator<<(ostream &os, const set<T> &s) {",
            "    os << \"{\";",
            "    for (auto it = s.begin(); it != s.end(); ++it) {",
            "        os << *it;",
            "        if (next(it) != s.end()) os << \", \";",
            "    }",
            "    os << \"}\";",
            "    return os;",
            "}",
            "",
            "// multiset",
            "template<typename T>",
            "ostream &operator<<(ostream &os, const multiset<T> &s) {",
            "    os << \"{\";",
            "    for (auto it = s.begin(); it != s.end(); ++it) {",
            "        os << *it;",
            "        if (next(it) != s.end()) os << \", \";",
            "    }",
            "    os << \"}\";",
            "    return os;",
            "}",
            "",
            "// unordered_set",
            "template<typename T>",
            "ostream &operator<<(ostream &os, const unordered_set<T> &s) {",
            "    os << \"{\";",
            "    for (auto it = s.begin(); it != s.end(); ++it) {",
            "        os << *it;",
            "        if (next(it) != s.end()) os << \", \";",
            "    }",
            "    os << \"}\";",
            "    return os;",
            "}",
            "",
            "// unordered_multiset",
            "template<typename T>",
            "ostream &operator<<(ostream &os, const unordered_multiset<T> &s) {",
            "    os << \"{\";",
            "    for (auto it = s.begin(); it != s.end(); ++it) {",
            "        os << *it;",
            "        if (next(it) != s.end()) os << \", \";",
            "    }",
            "    os << \"}\";",
            "    return os;",
            "}",
            "",
            "// map",
            "template<typename K, typename V>",
            "ostream &operator<<(ostream &os, const map<K, V> &m) {",
            "    os << \"{\";",
            "    for (auto it = m.begin(); it != m.end(); ++it) {",
            "        os << it->first << \": \" << it->second;",
            "        if (next(it) != m.end()) os << \", \";",
            "    }",
            "    os << \"}\";",
            "    return os;",
            "}",
            "",
            "// unordered_map",
            "template<typename K, typename V>",
            "ostream &operator<<(ostream &os, const unordered_map<K, V> &m) {",
            "    os << \"{\";",
            "    for (auto it = m.begin(); it != m.end(); ++it) {",
            "        os << it->first << \": \" << it->second;",
            "        if (next(it) != m.end()) os << \", \";",
            "    }",
            "    os << \"}\";",
            "    return os;",
            "}",
            "",
            "// queue(コピーする)",
            "template<typename T>",
            "ostream &operator<<(ostream &os, queue<T> q) {",
            "    os << \"(queue) front-> {\";",
            "    while(!q.empty()){",
            "        os << q.front() << (size(q)>1?\", \":\"\");",
            "        q.pop();",
            "    }",
            "    os << \"} <-back\";",
            "    return os;",
            "}",
            "",
            "// stack(コピーする)",
            "template<typename T>",
            "ostream &operator<<(ostream &os, stack<T> s) {",
            "    os << \"(stack) top-> {\";",
            "    while(!s.empty()){",
            "        os << s.top() << (size(s)>1?\", \":\"\");",
            "        s.pop();",
            "    }",
            "    os << \"} <-bottom\";",
            "    return os;",
            "}",
            "",
            "// deque",
            "template<typename T>",
            "ostream &operator<<(ostream &os, const deque<T> &q) {",
            "    os << \"(deque) front-> {\";",
            "    for (auto it = q.begin(); it != q.end(); ++it) {",
            "        os << *it;",
            "        if (next(it) != q.end()) os << \", \";",
            "    }",
            "    os << \"} <-back\";",
            "    return os;",
            "}",
            "",
            "// priority_queue(コピーする)",
            "template<typename T,typename Tc1,typename Tc2>",
            "ostream &operator<<(ostream &os, priority_queue<T,Tc1,Tc2> q) {",
            "    os << \"(priority_queue) top-> {\";",
            "    while(!q.empty()){",
            "        os << q.top() << (size(q)>1?\", \":\"\");",
            "        q.pop();",
            "    }",
            "    os << \"} <-bottom\";",
            "    return os;",
            "}",
            "",
            "// 複数引数出力（debug用）",
            "inline void dbg_out() { cerr << \"\\n\"; }",
            "template <typename T, typename... Ts>",
            "void dbg_out(const T& a, const Ts&... b) {",
            "    cerr << a;",
            "    if constexpr (sizeof...(b)) cerr << \"\\n\";",
            "    dbg_out(b...);",
            "}",
            "",
            "#ifdef JUDGE_LOCAL",
            "#define dbg(...) \\",
            "    cerr << \"\\e[36;47;1m\" << #__VA_ARGS__ << \"\\e[35;1m \\n\"; \\",
            "    dbg_out(__VA_ARGS__); \\",
            "    cerr << \"\\e[m\";",
            "#else",
            "#define dbg(...) void()",
            "#endif",
        ],
        "description": "ローカルデバッグ用出力"
    },


    "iota": {
        "prefix": "iota",
        "body": [
            "iota($1.begin(),$1.end(),0);",
        ],
        "description": "よく使うiota"
    },

    "再帰するラムダ式": {
        "prefix": "auto rec",
        "body": [
            "auto func = [&](auto &&self,int i){",
            "",
            "    self(self,i);",
            "};",
        ],
        "description": "再帰するラムダ式(C++26で変更予定)"
    },

    "clock": {
        "prefix": "clock",
        "body": [
            "    double st= (double)clock()/ CLOCKS_PER_SEC;",
            "",
            "    while (((double)clock()/ CLOCKS_PER_SEC)-st <=1.98){",
            "",
            "",
            "    }",
        ],
        "description": "時間計測,timer"
    },


    "random": {
        "prefix": "random",
        "body": [
            "random_device rd;",
            "mt19937 mt(rd());",
            "uniform_int_distribution<int> rand0N(0,N);",
            "",
            "int v=rand0N(mt);",
        ],
        "description": "整数[0,N]の乱数を作る、rand0N(mt)として使う"
    },


    "繰り返し二乗法": {
        "prefix": "reppow",
        "body": [
            "//桁が足りない場合はi128を使う",
            "i64 reppow(i64 a,i64 x,int mod){",
            "",
            "    if (x==-1) return reppow(a,mod-2,mod);",
            "",
            "    i64 ret=1;",
            "    while (x>0){",
            "        if (x&1) ret=(ret*a)%mod;",
            "        x>>=1;",
            "        a=(a*a)%mod;",
            "    }",
            "",
            "    return ret;",
            "}",
        ],
        "description": "繰り返し二乗法"
    },
	
    "struct Point": {
        "prefix": "struct Point",
        "body": [
            "// Geminiと作ったポイント型ライブラリ(2026/02/01作成)",
            "",
            "template <typename T>",
            "struct Point {",
            "    T x, y;",
            "",
            "    // コンストラクタ",
            "    Point(T _x = 0, T _y = 0) : x(_x), y(_y) {}",
            "",
            "    // ---------------------------------------------------------",
            "    //  1. 複合代入演算子 (自分自身を書き換える: +=, -=, *=, /=)",
            "    //  これらをベースに通常の演算子を定義すると実装が綺麗になります",
            "    // ---------------------------------------------------------",
            "    ",
            "    Point& operator+=(const Point& other) {",
            "        x += other.x;",
            "        y += other.y;",
            "        return *this;",
            "    }",
            "",
            "    Point& operator-=(const Point& other) {",
            "        x -= other.x;",
            "        y -= other.y;",
            "        return *this;",
            "    }",
            "",
            "    Point& operator*=(T k) { // スカラー倍",
            "        x *= k;",
            "        y *= k;",
            "        return *this;",
            "    }",
            "",
            "    Point& operator/=(T k) { // スカラー除算",
            "        x /= k;",
            "        y /= k;",
            "        return *this;",
            "    }",
            "",
            "    // ---------------------------------------------------------",
            "    //  2. 四則演算子 (+, -, *, /)",
            "    //  元のオブジェクトは変更せず、新しい Point を返します",
            "    // ---------------------------------------------------------",
            "",
            "    // ベクトル加算: p1 + p2",
            "    Point operator+(const Point& other) const {return Point(*this) += other;}",
            "",
            "    // ベクトル減算: p1 - p2",
            "    Point operator-(const Point& other) const {return Point(*this) -= other;}",
            "",
            "    // スカラー倍: p * k",
            "    Point operator*(T k) const {return Point(*this) *= k;}",
            "",
            "    // スカラー除算: p / k",
            "    Point operator/(T k) const {return Point(*this) /= k;}",
            "    ",
            "    // 単項マイナス: -p (ベクトルの反転)",
            "    Point operator-() const {return Point(-x, -y);}",
            "",
            "    // ---------------------------------------------------------",
            "    //  3. 比較演算子",
            "    // ---------------------------------------------------------",
            "    bool operator==(const Point& other) const {return x == other.x && y == other.y;}",
            "    bool operator!=(const Point& other) const {return !(*this == other);}",
            "",
            "    // =========================================================",
            "    //  比較用ファンクタ（入れ子クラスとして定義）",
            "    //  比較関数として利用する際には",
            "    //      ",
            "    //      Point<i64>::SortByX()",
            "    //  ",
            "    //  のように利用する",
            "    // =========================================================",
            "",
            "    // 1. X座標優先 (Xが同じならYで判定) -> 一般的な辞書順",
            "    struct SortByX {",
            "        bool operator()(const Point& a, const Point& b) const {",
            "            if (a.x != b.x) return a.x < b.x;",
            "            return a.y < b.y;",
            "        }",
            "    };",
            "",
            "    // 2. Y座標優先 (Yが同じならXで判定) -> スキャンライン法などで便利",
            "    struct SortByY {",
            "        bool operator()(const Point& a, const Point& b) const {",
            "            if (a.y != b.y) return a.y < b.y;",
            "            return a.x < b.x;",
            "        }",
            "    };",
            "",
            "    // 3. 偏角順 (-PI ～ +PI の反時計回り)",
            "    struct SortByAngle {",
            "        // 象限判定: 上半分(含 正のX軸)か？",
            "        bool isUpper(const Point& p) const {return p.y > 0 || (p.y == 0 && p.x > 0);}",
            "",
            "        bool operator()(const Point& a, const Point& b) const {",
            "            bool upperA = isUpper(a);",
            "            bool upperB = isUpper(b);",
            "            if (upperA != upperB) return upperA < upperB; // 下半分が先",
            "        ",
            "            // a から見て b が「左側（反時計回り）」にあれば、a < b",
            "            // cross(a, b) > 0 なら a -> b は反時計回り",
            "            return a.cross(b) < 0; // 同じ領域なら外積で判定",
            "        }",
            "    };",
            "    ",
            "    // デフォルトの < 演算子は「X優先」にしておくと、std::set等で便利です",
            "    bool operator<(const Point& other) const {return SortByX()(*this, other);}",
            "",
            "    // ---------------------------------------------------------",
            "    //  4. 幾何学的関数 (内積・外積・ノルム)",
            "    // ---------------------------------------------------------",
            "    ",
            "    // 内積 (Dot Product)",
            "    T dot(const Point& other) const {return x * other.x + y * other.y;}",
            "",
            "    // 外積 (Cross Product)",
            "    T cross(const Point& other) const {return x * other.y - y * other.x;}",
            "",
            "    // ノルムの2乗 (距離の比較など、平方根を取りたくない時に便利)",
            "    T norm2() const {return x * x + y * y;}",
            "",
            "    // ノルム (ベクトルの長さ) ※浮動小数点数型でのみ有効",
            "    double norm() const {return sqrt(norm2());}",
            "",
            "    // ---------------------------------------------------------",
            "    //  フレンド関数 (クラスの外からアクセス可能にする)",
            "    // ---------------------------------------------------------",
            "",
            "    // スカラー倍の左右対称性: k * p (これがないと p * k しかできない)",
            "    friend Point operator*(T k, const Point& p) {return p * k;}",
            "",
            "    // 出力ストリーム: cout << p",
            "    friend std::ostream& operator<<(std::ostream& os, const Point& p) {",
            "        return os << \"(\" << p.x << \", \" << p.y << \")\";",
            "    }",
            "};",
            "",
            "",
            "// ---------------------------------------------------------",
            "//  幾何学ユーティリティ関数群",
            "// ---------------------------------------------------------",
            "",
            "// 3点の位置関係を判定する定数",
            "static const int CCW_COUNTER_CLOCKWISE = 1;",
            "static const int CCW_CLOCKWISE = -1;",
            "static const int CCW_ONLINE_BACK = 2;   // c--a--b",
            "static const int CCW_ONLINE_FRONT = -2; // a--b--c",
            "static const int CCW_ON_SEGMENT = 0;    // a--c--b",
            "",
            "// 3点 a -> b -> c の進行方向判定 (CCW)",
            "// 戻り値の意味は上記の定数参照",
            "template <typename T>",
            "int ccw(Point<T> a, Point<T> b, Point<T> c) {",
            "    Point<T> b_minus_a = b - a;",
            "    Point<T> c_minus_a = c - a;",
            "    ",
            "    if (b_minus_a.cross(c_minus_a) > 0) return CCW_COUNTER_CLOCKWISE; // 反時計回り",
            "    if (b_minus_a.cross(c_minus_a) < 0) return CCW_CLOCKWISE;         // 時計回り",
            "    ",
            "    if (b_minus_a.dot(c_minus_a) < 0) return CCW_ONLINE_BACK;         // c--a--b の順 (一直線上、aの後ろ)",
            "    ",
            "    // 以下、長さ比較（ノルムの2乗を使うと整数で扱える）",
            "    if (b_minus_a.norm2() < c_minus_a.norm2()) return CCW_ONLINE_FRONT; // a--b--c (一直線上、bより先)",
            "",
            "    return CCW_ON_SEGMENT; // a--c--b (線分ab上にcがある)",
            "}",
            "",
            "// ---------------------------------------------------------",
            "//  1. 線分の交差判定",
            "// ---------------------------------------------------------",
            "// 線分 p1-p2 と 線分 p3-p4 が交差しているか判定",
            "// strict=true にすると、端点が接している場合を「交差していない」とみなします",
            "template <typename T>",
            "bool isIntersect(Point<T> p1, Point<T> p2, Point<T> p3, Point<T> p4, bool strict = false) {",
            "    int c1 = ccw(p1, p2, p3);",
            "    int c2 = ccw(p1, p2, p4);",
            "    int c3 = ccw(p3, p4, p1);",
            "    int c4 = ccw(p3, p4, p2);",
            "",
            "    if (strict) {",
            "        // 厳密な交差（端点を含まない）: ccwの積が明確に負である必要がある",
            "        return (c1 * c2 < 0) && (c3 * c4 < 0);",
            "    } else {",
            "        // 通常の交差（端点を含む）: ccwの積が0以下ならOK",
            "        return (c1 * c2 <= 0) && (c3 * c4 <= 0);",
            "    }",
            "}",
            "",
            "// ---------------------------------------------------------",
            "//  2. 多角形の面積",
            "// ---------------------------------------------------------",
            "// 頂点が順番（時計回り or 反時計回り）に並んでいる必要があります",
            "// 戻り値は常に double です（整数座標でも面積は 0.5 になることがあるため）",
            "template <typename T>",
            "double polygonArea(const vector<Point<T>>& points) {",
            "    double area = 0;",
            "    int n = points.size();",
            "    for (int i = 0; i < n; ++i) {",
            "        // 外積の総和 / 2",
            "        area += points[i].cross(points[(i + 1) % n]); ",
            "    }",
            "    return abs(area) / 2.0;",
            "}",
            "",
            "// ---------------------------------------------------------",
            "//  3. 凸包 (Convex Hull) - Monotone Chain Algorithm",
            "// ---------------------------------------------------------",
            "// 点群を含む最小の凸多角形を返します",
            "// O(N log N) : ソートがボトルネック",
            "template <typename T>",
            "vector<Point<T>> convexHull(vector<Point<T>> points) {",
            "    int n = points.size();",
            "    if (n < 3) return points; // 2点以下ならそのまま返す",
            "",
            "    // X座標順（Xが同じならY順）にソート",
            "    // Point内で定義した SortByX を使用",
            "    sort(points.begin(), points.end(), Point<T>::SortByX());",
            "",
            "    vector<Point<T>> hull; ",
            "",
            "    // 下側凸包 (Lower Hull) の構築",
            "    for (int i = 0; i < n; ++i) {",
            "        // 右折（時計回り）する点は凸包の構成点ではないので削除",
            "        // ccw <= 0 で一直線上の点も含める (= 0 を外せば含めない設定も可)",
            "        while (hull.size() >= 2 && ccw(hull[hull.size() - 2], hull.back(), points[i]) <= 0) {",
            "            hull.pop_back();",
            "        }",
            "        hull.push_back(points[i]);",
            "    }",
            "",
            "    // 上側凸包 (Upper Hull) の構築",
            "    int lower_hull_size = hull.size();",
            "    for (int i = n - 2; i >= 0; --i) {",
            "        while (hull.size() > lower_hull_size && ccw(hull[hull.size() - 2], hull.back(), points[i]) <= 0) {",
            "            hull.pop_back();",
            "        }",
            "        hull.push_back(points[i]);",
            "    }",
            "",
            "    // 始点が重複して入るので最後の一つを削除",
            "    hull.pop_back();",
            "",
            "    return hull;",
            "}",
            "",
            "// ---------------------------------------------------------",
            "//  ピックの定理関連ユーティリティ",
            "// ---------------------------------------------------------",
            "",
            "// 1. 辺上の格子点数 (B) を求める",
            "// 多角形の各辺について、x差分とy差分の最大公約数が、その辺上の区間の数になります",
            "template <typename T>",
            "long long countBoundaryPoints(const vector<Point<T>>& points) {",
            "    long long B = 0;",
            "    int n = points.size();",
            "    for (int i = 0; i < n; ++i) {",
            "        Point<T> diff = points[(i + 1) % n] - points[i];",
            "        // 辺上の格子点の数は gcd(|dx|, |dy|)",
            "        B += gcd(abs(diff.x), abs(diff.y));",
            "    }",
            "    return B;",
            "}",
            "",
            "// 2. 内部の格子点数 (I) を求める",
            "// ピックの定理: S = I + B/2 - 1",
            "// 変形すると: I = S - B/2 + 1",
            "// 整数演算で完結させるため、2倍して計算: 2*I = 2*S - B + 2",
            "template <typename T>",
            "long long countInteriorPoints(const vector<Point<T>>& points) {",
            "    // まず 2*S (外積の総和の絶対値) を計算",
            "    long long twice_area = 0;",
            "    int n = points.size();",
            "    for (int i = 0; i < n; ++i) {",
            "        twice_area += points[i].cross(points[(i + 1) % n]);",
            "    }",
            "    twice_area = abs(twice_area); // 面積の2倍",
            "",
            "    // 辺上の格子点数 B を取得",
            "    long long B = countBoundaryPoints(points);",
            "",
            "    // I = (2S - B + 2) / 2",
            "    return (twice_area - B + 2) / 2;",
            "}",
        ],
        "description": "Geminiと作ったポイント型ライブラリ"
    },



    "struct Modint": {
        "prefix": "struct Modint",
        "body": [
            "///------------------------------------------",
            "/// Modint クラス",
            "/// ChatGPT先生に作ってもらったのをちょっと手直し",
            "///------------------------------------------",
            "template <int Tmd>",
            "struct Modint {",
            "    using mint = Modint<Tmd>;",
            "    i64 v;",
            "",
            "    // --- コンストラクタ ---",
            "    constexpr Modint(i64 _v = 0) noexcept {",
            "        if (_v >= Tmd || _v <= -Tmd) _v %= Tmd;",
            "        if (_v < 0) _v += Tmd;",
            "        v = int(_v);",
            "    }",
            "",
            "    // --- 基本演算 ---",
            "    constexpr mint operator+(const mint& o) const noexcept { return mint(v + o.v >= Tmd ? v + o.v - Tmd : v + o.v); }",
            "    constexpr mint operator-(const mint& o) const noexcept { return mint(v - o.v < 0 ? v - o.v + Tmd : v - o.v); }",
            "    constexpr mint operator*(const mint& o) const noexcept { return mint(1LL * v * o.v % Tmd); }",
            "    constexpr mint operator/(const mint& o) const noexcept { return *this * o.inv(); }",
            "",
            "    constexpr mint& operator+=(const mint& o) noexcept { v += o.v; if (v >= Tmd) v -= Tmd; return *this; }",
            "    constexpr mint& operator-=(const mint& o) noexcept { v -= o.v; if (v < 0) v += Tmd; return *this; }",
            "    constexpr mint& operator*=(const mint& o) noexcept { v = int(1LL * v * o.v % Tmd); return *this; }",
            "    constexpr mint& operator/=(const mint& o) noexcept { return *this *= o.inv(); }",
            "",
            "    // --- 単項マイナス ---",
            "    constexpr mint operator-() const noexcept { return mint(v ? Tmd - v : 0); }",
            "",
            "    // --- 比較 ---",
            "    constexpr bool operator==(const mint& o) const noexcept { return v == o.v; }",
            "    constexpr bool operator!=(const mint& o) const noexcept { return v != o.v; }",
            "",
            "    // --- インクリメント／デクリメント ---",
            "    constexpr mint& operator++() noexcept {  // 前置 ++x",
            "        v++;",
            "        if (v >= Tmd) v -= Tmd;",
            "        return *this;",
            "    }",
            "    constexpr mint operator++(int) noexcept { // 後置 x++",
            "        mint tmp = *this;",
            "        ++(*this);",
            "        return tmp;",
            "    }",
            "    constexpr mint& operator--() noexcept {  // 前置 --x",
            "        v--;",
            "        if (v < 0) v += Tmd;",
            "        return *this;",
            "    }",
            "    constexpr mint operator--(int) noexcept { // 後置 x--",
            "        mint tmp = *this;",
            "        --(*this);",
            "        return tmp;",
            "    }",
            "",
            "    // --- 逆元 ---",
            "    constexpr mint inv() const noexcept {",
            "        return pow(Tmd - 2);",
            "    }",
            "",
            "    // --- 累乗 ---",
            "    constexpr mint pow(i64 n) const noexcept {",
            "        mint res = 1, x = *this;",
            "        while (n > 0) {",
            "            if (n & 1) res *= x;",
            "            x *= x;",
            "            n >>= 1;",
            "        }",
            "        return res;",
            "    }",
            "",
            "    // --- 値の取得 (val) ---",
            "    constexpr int val() const noexcept { return v; }",
            "",
            "    // --- 出力 ---",
            "    friend ostream& operator<<(ostream& os, const mint& m) { return os << m.v; }",
            "    friend istream& operator>>(istream& is, mint& m) {i64 x; is >> x; m = mint(x); return is; }",
            "",
            "    static constexpr int mod() { return Tmd; }",
            "};",
        ],
        "description": "Modint構造体"
    },

    "mod組合せ": {
        "prefix": "modcomb",
        "body": [
            "///------------------------------------------",
            "/// 数学ライブラリ (階乗, 逆元, nCr, nPr)",
            "///------------------------------------------",
            "template <int Tmd>",
            "struct MathLib {",
            "    using mint = Modint<Tmd>;",
            "    vector<mint> fact, ifact, inv;",
            "",
            "    MathLib(int n = 0) { if (n) init(n); }",
            "",
            "    void init(int n) {",
            "        fact.resize(n + 1);",
            "        ifact.resize(n + 1);",
            "        inv.resize(n + 1);",
            "        fact[0] = ifact[0] = inv[1] = 1;",
            "        for (int i = 2; i <= n; i++) inv[i] = mint(Tmd - Tmd / i) * inv[Tmd % i];",
            "        for (int i = 1; i <= n; i++) fact[i] = fact[i - 1] * i;",
            "        ifact[n] = fact[n].inv();",
            "        for (int i = n; i >= 1; i--) ifact[i - 1] = ifact[i] * i;",
            "    }",
            "",
            "    mint nCr(int n, int r) const {",
            "        if (r < 0 || r > n) return 0;",
            "        return fact[n] * ifact[r] * ifact[n - r];",
            "    }",
            "",
            "    mint nPr(int n, int r) const {",
            "        if (r < 0 || r > n) return 0;",
            "        return fact[n] * ifact[n - r];",
            "    }",
            "};",
        ],
        "description": "mod組合せ"
    },


    "modcomb": {
        "prefix": "modcomb",
        "body": [
            "vector<i64> perm,invperm;",
            "",
            "//n以下の階乗とそのmod逆元を作る",
            "void modperm(int N){",
            "",
            "    perm.resize(N+1);",
            "    invperm.resize(N+1);",
            "",
            "    perm[0]=1;",
            "    invperm[0]=1;",
            "    ",
            "    rep(i,N){",
            "        perm[i+1]=((i+1)*perm[i])%MOD;",
            "        invperm[i+1]=reppow(perm[i+1],MOD-2,MOD);",
            "    }",
            "",
            "    return;",
            "}",
            "",
            "//modを取った組合せを計算する",
            "i64 modcomb(i64 n,i64 r){",
            "",
            "    i64 ret;",
            "    ret=(perm[n]*invperm[r])%MOD;",
            "    ret=(ret*invperm[n-r])%MOD;",
            "",
            "    return ret;",
            "",
            "}",
        ],
        "description": "modをとった組合せ"
    },


	"meguru_bisearch(int ng,int ok)": {
		"prefix": "meguru_bisearch(int ng,int ok)",
		"body": [
			"bool judge(int mid){",
			"    if ()return true;",
			"    else return false;",
			"}",
			"",
			"int meguru_bisearch(int ng,int ok){",
			"    while(abs(ok-ng)>1){",
			"        int mid=(ok+ng)/2;",
			"        (judge(mid))? ok=mid:ng=mid;",
			"    }",
			"    return ok;",
			"}",
		],
		"description": "めぐる式二分探索"
	},
	

    "組合せ": {
        "prefix": "comb",
        "body": [
            "i64 comb(int n, int r){",
            "    assert(0<=r&&r<=n);",
            "    if (r==0) return 1;",
            "",
            "    if (r>(n+3)/2){",
            "        r=n-r;",
            "    }",
            "    i64 ret;",
            "    ret=1;",
            "    rep(i,r){",
            "        ret*=n-i;",
            "        ret/=i+1;",
            "    }",
            "    return ret;",
            "}",
        ],
        "description": "組合せ"
    },

    "配列の総和": {
        "prefix": "sumA",
        "body": [
            "i64 sumA=reduce(A.begin(),A.end());",
        ],
        "description": "配列の総和"
    },


    "累積和配列": {
        "prefix": "sumA",
        "body": [
            "// 累積和を取る",
            "vector<i64> sumA(N+1);",
            "inclusive_scan(A.begin(),A.end(),sumA.begin()+1);",
        ],
        "description": "累積和配列"
    },

    "スライド最小値": {
        "prefix": "Slide_Minimum",
        "body": [
            "template <typename T>",
            "vector<T> Slide_Minimum(vector<T> A,int K){",
            "    vector<T> ret;",
            "    deque<T> q;",
            "    int N=size(A);",
            "",
            "    rep(i,N){",
            "        while(!q.empty()&&q.front()<=i-K)q.pop_front(); ",
            "        while(!q.empty()&&A[q.back()]>A[i])q.pop_back();",
            "        q.emplace_back(i);",
            "        ret.emplace_back(A[q.front()]);    ",
            "    }",
            "",
            "    return ret;",
            "}",
        ],
        "description": "配列Aの連続K個中の最小値を求める"
    },

    "スライド最大値": {
        "prefix": "Slide_Maximum",
        "body": [
            "template <typename T>",
            "vector<T> Slide_Maximum(vector<T> A,int K){",
            "    vector<T> ret;",
            "    deque<T> q;",
            "    int N=size(A);",
            "",
            "    rep(i,N){",
            "        while(!q.empty()&&q.front()<=i-K)q.pop_front(); ",
            "        while(!q.empty()&&A[q.back()]<A[i])q.pop_back();",
            "        q.emplace_back(i);",
            "        ret.emplace_back(A[q.front()]);    ",
            "    }",
            "",
            "    return ret;",
            "}",
        ],
        "description": "配列Aの連続K個中の最大値を求める"
    },


	"線形篩": {
        "prefix": "prime(int N)",
        "body": [
            "vector<int> prime(int N){",
            "    vector<int> P;",
            "    vector<int> f(N+1,0);",
            "    repst(i,2,N+1){",
            "        if (f[i]==0){",
            "            P.emplace_back(i);",
            "            f[i]=i;",
            "        }",
            "        for (auto j :P){",
            "            if (i*j>N||j>f[i]){",
            "                break;",
            "            }",
            "            f[i*j]=j;",
            "        }",
            "    }",
            "    return P;",
            "}",
        ],
        "description": "素数列挙(線形篩)"
    },

    "prime_judge": {
        "prefix": "prime_judge",
        "body": [
            "//素数判定(ミラーラビン使うほどでもないくらいの)",
            "i64 prime_judge(i64 a){",
            "",
            "    int sqrta=sqrt(a);",
            "    repst(i,2,sqrta) if (a%i==0) return false;",
            "    ",
            "    return true;",
            "",
            "}",
        ],
        "description": "素数判定"
    },


    "divenum": {
        "prefix": "divenum",
        "body": [
            "//約数列挙",
            "vector<i64> divenum(i64 N){",
            "    vector<i64> ret;",
            "    rep(i,sqrt(N)){",
            "        if (N%(i+1)==0){",
            "            ret.emplace_back(i+1);",
            "            if (N/(i+1)!=i+1) ret.emplace_back(N/(i+1));",
            "        }",
            "    }",
            "",
            "    sort(ret.begin(),ret.end());",
            "    return ret;",
            "}",
        ],
        "description": "約数列挙"
    },


    "素因数分解": {
        "prefix": "fact",
        "body": [
            "vector<pair<i64,i64>> fact(i64 N){",
            "",
            "    vector<pair<i64,i64>> P;",
            "    int rN=sqrt(N)+1;",
            "",
            "    repst(i,2,rN){",
            "        if (N%i==0){",
            "            int cnt=0;",
            "            while(N%i==0){",
            "                cnt++;",
            "                N/=i;",
            "            }",
            "            P.emplace_back(make_pair(i,cnt));",
            "        }",
            "    }",
            "",
            "    if (N!=1||P.empty()) P.emplace_back(make_pair(N,1));",
            "",
            "    return P;",
            "}",
        ],
        "description": "素因数分解"
    },


    "Millar_Rabin": {
        "prefix": "Millar_Rabin",
        "body": [
            "bool Millar_Rabin(i64 N){",
            "",
            "    //1と偶数を篩落とす",
            "    if (N==1) return false;",
            "    else if (N%2==0) return (N==2)?true:false;",
            "",
            "    //偶数は篩落としたので(Nは奇数)=(N-1は偶数)となっている",
            "    //N-1を2^s*dの形で表す",
            "    i64 temp,s,d;",
            "    temp=N-1;",
            "    s=0;",
            "    while (temp%2==0){",
            "        temp/=2;",
            "        s++;",
            "    }",
            "    d=(N-1)/(1LL<<s);",
            "",
            "    //比較対象リスト",
            "    //2^32未満なら2,7,61",
            "    //2^64未満なら37までの素数を使う",
            "    //それ以上は2以上N未満の乱数50個を使う",
            "",
            "    vector<int> complist;",
            "    if (N<(INT_MAX)) complist={2,7,61};",
            "    else if (N<INT64_MAX) complist={2, 325, 9375, 28178, 450775, 9780504, 1795265022};",
            "    //else {",
            "    //    while (complist.size()<50) {",
            "    //        temp=getrand();",
            "    //        if (2<=temp&&temp<N&&find(complist.begin(),complist.end(),temp)==complist.end()){",
            "    //            complist.emplace_back(temp);",
            "    //        }",
            "    //    }",
            "    //}",
            "",
            "    for (auto a:complist){",
            "        if (N<=a) break;",
            "        ",
            "        //(a^d)%N=1ならこのaについてはミラーラビンテスト合格",
            "        if (reppow(a,d,N)==1) continue;",
            "",
            "",
            "        //0<=r<sを満たす(a^(d*(2^r)))%Nを見ていき",
            "        //-1≡N-1を満たすものが1つでもあればこのaについてミラーラビンテスト合格",
            "        //1つもなければその時点で不合格(非素数)",
            "        bool f=true;",
            "        rep(r,s){",
            "            temp=reppow(a,d*(1LL<<r),N);",
            "            if (temp==N-1) {",
            "                f=false;",
            "                break;",
            "            }",
            "        }",
            "        if (f) return false;",
            "    }",
            "",
            "    //すべてのaについてミラーラビンテストが合格したならおそらく素数と判定できる",
            "    return true;",
            "",
            "}",
        ],
        "description": "ミラーラビン素数判定法"
    },



	"ctoi": {
		"prefix": "int ctoi",
		"body": [
			"///char型の数字からint型の数字へ変換する",
			"int ctoi(char c) {",
			"   switch (c) {",
			"       case '0': return 0;",
			"       case '1': return 1;",
			"       case '2': return 2;",
			"       case '3': return 3;",
			"       case '4': return 4;",
			"       case '5': return 5;",
			"       case '6': return 6;",
			"       case '7': return 7;",
			"       case '8': return 8;",
			"       case '9': return 9;",
			"       default: return 0;",
			"   }",
			"}",
		],
		"description": "int ctoi"
	},


    "10進法からn進法に変換": {
        "prefix": "string Conv_N_base",
        "body": [
            "// 10進法からn進法に変換",
            "string Conv_N_base(i64 i,int n){",
            "",
            "    string ret;",
            "    i64 d,m;",
            "",
            "    while (i){",
            "        d=i/n;",
            "        m=i%n;",
            "",
            "        ret.push_back('0'+m);",
            "        i=d;",
            "    }",
            "",
            "    reverse(ret.begin(),ret.end());",
            "    return ret;",
            "",
            "}",
        ],
        "description": "10進法からn進法に変換"
    },

	"pairの2つ目昇順": {
		"prefix": "bool comp_second_smaller",
		"body": [
            "auto comp_second_smaller = [](const auto& a, const auto& b) {",
            "    return tie(a.second, a.first) < tie(b.second, b.first);",
            "};",
		],
		"description": "pair_second小さい順の比較関数"
	},

    "pairの2つ目降順": {
        "prefix": "bool comp_second_larger",
        "body": [
            "auto comp_second_larger = [](const auto& a, const auto& b) {",
            "    return tie(a.second, a.first) > tie(b.second, b.first);",
            "};",
        ],
        "description": "pair_second大きい順の比較関数"
    },

	"unionfind": {
		"prefix": "unionfind",
		"body": [
            "struct DSU{",
            "    int _n;",
            "    vector<int> par,rank,par_list;",
            "    DSU(int N):_n(N+1),par(N+1),rank(N+1,1){",
            "        iota(par.begin(),par.end(),0);",
            "    }",
            "",
            "    int Find(int a){return (par[a]!=a?par[a]=Find(par[a]):a);}",
            "",
            "    void Union(int a,int b){",
            "",
            "        a=Find(a);",
            "        b=Find(b);",
            "        if (a==b) return;",
            "",
            "        if (rank[b]>rank[a]) swap(a,b);",
            "",
            "        rank[a]+=rank[b];",
            "        par[b]=a;",
            "        ",
            "        return;",
            "    }",
            "",
            "    bool is_par(int a){return Find(a)==a;}",
            "",
            "    bool same(int a,int b){return Find(a)==Find(b);} ",
            "",
            "    int size(int i){return rank[Find(i)];}",
            "",
            "    void make_par_list(){",
            "        par_list.clear();",
            "        rep(i,_n)if (Find(i)==i)par_list.emplace_back(i);",
            "        return;",
            "    }",
            "",
            "};",
		],
		"description": "Union-Find"
	},

    "非構造体unionfind": {
        "prefix": "unionfind",
        "body": [
            "vector<int> par,Rank;",
            "",
            "int Find(int a){",
            "    if (par[a]!=a) return par[a]=Find(par[a]);",
            "    return a;",
            "}",
            "",
            "void Union(int a,int b){",
            "",
            "    a=Find(a);",
            "    b=Find(b);",
            "    if (a==b) return;",
            "",
            "    if (Rank[b]>Rank[a]) swap(a,b);",
            "",
            "    Rank[a]+=Rank[b];",
            "    Rank[b]=Rank[a];   ",
            "    par[b]=a;",
            "    ",
            "    return;",
            "}",
            "",
            "",
            "int main() {",
            "    ios::sync_with_stdio(false);",
            "    cin.tie(nullptr);",
            "",
            "    int N,M;",
            "    cin >> N >> M ;",
            "",
            "    par.resize(N);",
            "    iota(par.begin(),par.end(),0);",
            "    Rank.assign(N,1);",
            "",
            "    int A,B;",
            "    rep(i,M){",
            "        cin >> A >> B ;",
            "        Union(A,B); ",
            "    }",
            "}",
        ],
        "description": "非構造体Union-Find"
    },

    "PotentialUnionFind": {
        "prefix": "PotentialUnionFind",
        "body": [
            "struct PotentialUnionFind {",
            "    vector<i64> par, rank, diffp;",
            "",
            "    PotentialUnionFind(int n) {",
            "        par.resize(n + 1);",
            "        rank.resize(n + 1, 1);",
            "        diffp.resize(n + 1, 0);",
            "        ",
            "        for (int i = 0; i <= n; ++i) par[i] = i;",
            "    }",
            "",
            "    i64 Find(int x) {",
            "        if (par[x] == x) return x;",
            "",
            "        int ret = Find(par[x]);",
            "        diffp[x] += diffp[par[x]];",
            "        par[x] = ret;",
            "        return ret;",
            "    }",
            "",
            "    bool Union(int a, int b, i64 p) {",
            "        if (same(a, b)) {",
            "            if (diff(a, b) == p) return true;",
            "            return false;",
            "        }",
            "",
            "        p += acm_pot(a) - acm_pot(b);",
            "        a = par[a];",
            "        b = par[b];",
            "",
            "        if (rank[a] < rank[b]) {",
            "            swap(a, b);",
            "            p *= -1;",
            "        }",
            "",
            "        par[b] = a;",
            "        diffp[b] = p;",
            "",
            "        rank[a] += rank[b];",
            "        rank[b] = rank[a];",
            "",
            "        return true;",
            "    }",
            "",
            "    bool same(int a, int b) {",
            "        return Find(a) == Find(b);",
            "    }",
            "",
            "    i64 diff(int a, int b) {",
            "        if (same(a, b)) {return acm_pot(b) - acm_pot(a);}",
            "    }",
            "",
            "    i64 acm_pot(int a) {",
            "        Find(a);",
            "        return diffp[a];",
            "    }",
            "};",
        ],
        "description": "重み付きUnionFind"
    },
    "ダブリング": {
        "prefix": "struct Doubling",
        "body": [
            "struct Doubling{",
            "",
            "    int n,k;",
            "    vector<vector<int>> dp;",
            "",
            "    Doubling(int N,int K=60):n(N),k(K),dp(K+1,vector<int>(N,-1)){}",
            "",
            "    void build(vector<int> &A){",
            "        rep(i,n) dp[0][i]=A[i];",
            "",
            "        rep(j,k)rep(i,n)dp[j+1][i]=dp[j][dp[j][i]];",
            "    }",
            "",
            "    int get(int i,i64 m){",
            "",
            "        int ret=i;",
            "        rep(j,k)if (m&((i64)1<<j))ret=dp[j][ret];",
            "",
            "        return ret;",
            "    }",
            "};",
        ],
        "description": "ダブリング"
    },


    "int cur[4][2]": {
        "prefix": "int cur[4][2]",
        "body": [
            "constexpr int cur[4][2]={{0,1},{-1,0},{0,-1},{1,0}};",
        ],
        "description": "4方向カーソル"
    },

    "int cur[8][2]": {
        "prefix": "int cur[8][2]",
        "body": [
            "constexpr int cur[8][2]={{0,1},{-1,1},{0,-1},{-1,-1},{0,-1},{1,-1},{0,1},{1,1}};",
        ],
        "description": "8方向カーソル"
    },

    "RLDUカーソル": {
        "prefix": "map<char,pair<int,int>> cur",
        "body": [
            "//(x,y)座標で使う",
            "//関数中で宣言する ",
            "map<char,pair<int,int>> cur;",
            "cur['R']={1,0};",
            "cur['L']={-1,0};",
            "cur['U']={0,1};",
            "cur['D']={0,-1};",
            "",
        ],
        "description": "RLDUカーソル"
    },


    "if not": {
        "prefix": "if not",
        "body": [
            "if (!(0<=i+di&&i+di<H&&0<=j+dj&&j+dj<W))continue;",
        ],
        "description": "範囲外チェック"
    },


    "edge": {
        "prefix": "edge",
        "body": [
            "    unordered_map<int,vector<int>> edge;",
            "    int u,v;",
            "",
            "    rep(i,n-1){",
            "        cin >> u >> v;",
            "        edge[u].emplace_back(v);",
            "        edge[v].emplace_back(u);",
            "    }",
            "",
            "    //根を1として深さをdepthに記録する",
            "    vector<int> depth(n+1,-1);",
            "    depth[1]=0;",
            "",
            "    queue<int> q;",
            "    q.push(1);",
            "",
            "    //子を配列sonに記録する",
            "    unordered_map<int ,vector<int>> son;",
            "",
            "    while (!q.empty()){",
            "        int temp=q.front();",
			"        q.pop();",
            "",
            "        for (auto i:edge[temp]){",
            "            if (depth[i]!=-1) continue;",
            "            depth[i]=depth[temp]+1;",
            "            son[temp].emplace_back(i);",
            "            q.push(i);",
            "        }",
            "    }",
        ],
        "description": "根付き木作成"
    },

    "Graph": {
        "prefix": "Graph",
        "body": [
            "template<typename T>",
            "struct Graph{",
            "",
            "    vector<vector<pair<int,T>>> edge;",
            "    vector<T> cost;",
            "    vector<bool> chk;",
            "",
            "    Graph(int N):edge(N+1),chk(N+1),cost(N+1){}",
            "",
            "    void add_edge(int &u,int &v,T &w){",
            "        edge[u].push_back({v,w});",
            "    }",
            "",
            "    T solve(int i){",
            "",
            "        T ret=INF;",
            "",
            "        queue<int> q;",
            "        q.push(i);",
            "        chk[i]=true;",
            "",
            "        while (!q.empty()){",
            "",
            "            auto s=q.front();",
            "            q.pop();",
            "            ",
            "            for (auto &[t,w]:edge[s]){",
            "                if (chk[t]) continue;",
            "",
            "                q.push(t);",
            "                chk[t]=true;",
            "            }",
            "        }",
            "",
            "        return ret;",
            "    }",
            "};",
        ],
        "description": "汎用BFS"
    },


    "DFS": {
        "prefix": "dfs",
        "body": [
            "//再帰を使ったDFS",
            "int cnt;",
            "vector<vector<int>> edge;",
            "vector<int> d,depth,son;",
            "",
            "void DFS(int s){",
            "    ",
            "    //行きがけ順の場合はこの辺で処理する",
            "    d[s]=cnt;",
            "    cnt++;",
            "",
            "    for (auto t:edge[s]) if(d[t]==-1){",
            "        depth[t]=depth[s]+1;",
            "        DFS(t);",
            "    } ",
            "",
            "    //帰りがけ順の場合はこの辺で処理する",
            "    for (auto t:edge[s]) son[s]+=son[t]+1;",
            "",
            "    return;",
            "}",
            "",
            "int main() {",
            "    ios::sync_with_stdio(false);",
            "    cin.tie(nullptr);",
            "",
            "    int N;",
            "    cin >> N;",
            "",
            "    edge.resize(N);",
            "    int p;",
            "    rep(i,N-1){",
            "        cin >> p ;",
            "        edge[p].emplace_back(i+1);",
            "    }",
            "",
            "",
            "    d.assign(N,-1);",
            "    depth.assign(N,-1);",
            "    d[0]=0;",
            "    depth[0]=0;",
            "    son.assign(N,0);",
            "    cnt=0;",
            "",
            "    DFS(0);",
            "",
            "}",
        ],
        "description": "再帰DFS"
    },

    "Tarjan_SCC": {
        "prefix": "Tarjan_SCC",
        "body": [
            "vector<int> IDs,LLV;",
            "vector<bool> onStack;",
            "vector<vector<int>> SCCset;",
            "stack<int> S;",
            "int NodeID=0,SCCcnt=0;",
            "",
            "void DFS(int s){",
            "    S.push(s);",
            "    onStack[s]=true;",
            "    IDs[s]=NodeID;",
            "    LLV[s]=NodeID;",
            "    NodeID++;",
            "",
            "    for (auto t:edge[s]){",
            "        if (IDs[t]==-1) DFS(t);",
            "        if (onStack[t]) LLV[s]=min(LLV[s],LLV[t]);",
            "    }",
            "",
            "    if (IDs[s]==LLV[s]){",
            "        vector<int> templist;",
            "        while (!S.empty()){",
            "            int node=S.top();",
            "            S.pop();",
            "            onStack[node]=false;",
            "            LLV[node]=IDs[s];",
            "            templist.emplace_back(node);",
            "            if (node==s) break;",
            "        }",
            "        SCCset.emplace_back(templist);",
            "        SCCcnt++;",
            "    }",
            "",
            "    return;",
            "}",
            "",
            "//Tarjan's SCC",
            "//参考:https://www.youtube.com/watch?v=wUgWX0nc4NY",
            "",
            "void Tarjan_SCC(int N){",
            "",
            "    IDs.resize(N,-1);",
            "    onStack.resize(N,false);",
            "    LLV.resize(N,0);",
            "",
            "    rep(i,N) if(IDs[i]==-1) DFS(i);",
            "    return;",
            "}",
        ],
        "description": "Tarjan's SCC"
    },


    "dijkstra": {
        "prefix": "dijkstra",
        "body": [
            "template<typename T>",
            "struct Graph{",
            "",
            "",
            "    // プライオリティーキューなどに格納する型を定義しておく",
            "    using P=pair<T,int>;",
            "    ",
            "    vector<vector<P>> edge;",
            "    vector<pair<int,int>> path;",
            "    vector<int> pre;",
            "    vector<T> cost;",
            "",
            "    priority_queue<P,vector<P>,greater<P>> q;",
            "",
            "    Graph(int N):edge(N+1),pre(N+1,-1),cost(N+1,INF){}",
            "",
            "    void add_edge(int &u,int &v,T &w){",
            "        edge[u].push_back({w,v});",
            "    }",
            "",
            "    T dijkstra(int start,int goal){",
            "        cost[start]=0;",
            "        q.push({0,start});",
            "",
            "        while(!q.empty()){",
            "            auto [c,s]=q.top();",
            "            q.pop();",
            "",
            "            if (c>cost[s])continue;",
            "",
            "            if (s==goal){",
            "                while (~pre[s]){",
            "                    path.push_back({pre[s],s});",
            "                    s=pre[s];",
            "                }",
            "                reverse(path.begin(),path.end());",
            "",
            "                return c;",
            "            }",
            "",
            "            for (auto &[nowc,t]:edge[s]){",
            "                if (c+nowc<cost[t]){",
            "                    cost[t]=c+nowc;",
            "                    pre[t]=s;",
            "                    q.push({c+nowc,t});",
            "                }",
            "            }",
            "        }",
            "",
            "        return -1;",
            "    }",
            "};",
        ],
        "description": "ダイクストラ法"
    },


    "Bellman-Ford": {
        "prefix": "Bellman-Ford",
        "body": [
            "    //Bellman-Ford",
            "    int V,E,r;",
            "    cin >> V >> E >> r;",
            "",
            "    vector<vector<int>> edgeto(V),edgecost(V);",
            "    int s,t,c;",
            "    rep(_,E){",
            "        cin >> s >> t >> c;",
            "",
            "        edgeto[s].emplace_back(t);",
            "        edgecost[s].emplace_back(c);",
            "",
            "    }",
            "",
            "    vector<int> dist(V,INF);",
            "    dist[r]=0;",
            "",
            "    bool f;",
            "    rep(loop,V){",
            "        f=false;",
            "        rep(i,V){",
            "            if (dist[i]==INF)continue;",
            "",
            "            rep(k,edgeto[i].size()){",
            "                int j=edgeto[i][k],c=edgecost[i][k];",
            "                if (dist[j]>dist[i]+c){",
            "                    dist[j]=dist[i]+c;",
            "                    f=true;",
            "                }",
            "            }",
            "        }",
            "",
            "        if (!f) break;",
            "    }",
            "",
            "    if (f){",
            "        cout << \"NEGATIVE CYCLE\\n\";",
            "        return 0;",
            "    }",
            "",
            "    for (auto a:dist){",
            "        if (a==INF) cout << \"INF\\n\" ;",
            "        else cout << a << \"\\n\";",
            "    } ",
            "",
        ],
        "description": "ベルマンフォード法"
    },




    "Warshall-Floyd": {
        "prefix": "Warshall-Floyd",
        "body": [
            "vector<vector<i64>> DP(N,vector<i64>(N,INF));",
            "rep(i,N)DP[i][i]=0;",
            "//与えられた辺のコストをDPテーブルに入力する",
            "",
            "rep(k,N)rep(i,N)rep(j,N) DP[i][j]=min(DP[i][j],DP[i][k]+DP[k][j]);",
        ],
        "description": "ワ―シャルフロイド法"
    },


    "フェニック木": {
        "prefix": "Fenwick",
        "body": [
            "// 1-indexedのFenwick Tree (Binary Indexed Tree)",
            "template <typename T = int>",
            "struct Fenwick {",
            "",
            "    int n;",
            "    vector<T> tree;",
            "    T initval;",
            "    function<T(T, T)> op;",
            "",
            "    /**",
            "     * @param n 要素数",
            "     * @param initval 初期値",
            "     * @param operation 適用する演算 (デフォルトは加算)",
            "     */",
            "",
            "    Fenwick(int n, T initval = 0, function<T(T, T)> operation = plus<T>())",
            "        : n(n+1), tree(n + 1, initval), initval(initval), op(operation) {}",
            "",
            "    // i番目にxを加算 (1 <= i <= n)",
            "    void add(int i, T x) {",
            "        assert(1 <= i && i <= n);",
            "        while (i <= n) {",
            "            tree[i] = op(tree[i], x);",
            "",
            "            // LSB を加算して次のインデックスへ",
            "            i += i & -i;",
            "        }",
            "    }",
            "",
            "    // [0, r] の総和を取得 ",
            "    T sum0(int r) const {",
            "        assert(0 <= r && r <= n);",
            "        T s = initval;",
            "        while (r > 0) {",
            "            s = op(s, tree[r]);",
            "            // LSB を減算して親のインデックスへ",
            "            r -= r & -r;",
            "        }",
            "        return s;",
            "    }",
            "",
            "    // [l, r] の区間和を取得",
            "    T sum(int l, int r) const {",
            "        assert(0 <= l && l <= r && r <= n);",
            "        return sum0(r) - sum0(l);",
            "    }",
            "",
            "    // __getitem__の代わり",
            "    // 元配列のi単体要素を出力",
            "    T operator[](int i) const {return sum(i-1,i);}",
            "};",
        ],
        "description": "フェニック木,BIT"
    },


    "vector<int> getpos(int s,int e){": {
        "prefix": "vector<int> getpos(int s,int e){",
        "body": [
            "vector<int> getpos(int s,int e){",
            "    vector<int> poslist;",
            "",
            "    while (s<e){",
            "        if (s%2!=0){",
            "            poslist.push_back(s);",
            "            s+=1;",
            "        }",
            "        s/=2;",
            "        if (e%2!=0){",
            "            e-=1;",
            "            poslist.push_back(e);",
            "        }",
            "        e/=2;",
            "    }",
            "",
            "    return poslist;",
            "}",
            "",
        ],
        "description": "セグメント木座標取得"
    },

    "segmenttree": {
        "prefix": "segmenttree",
        "body": [
            "    int n2=1;",
            "    while (n2<=N+2) n2*=2;",
            "    vector<i64> segtree(2*n2-1,INF);",
            " ",
            "    int k=n2;",
            "    while (k>=1){",
            "        segtree[k]=0;",
            "        k/=2;",
            "    }",
        ],
        "description": "セグメント木初期化"
    },

    "RLE": {
        "prefix": "RLE",
        "body": [
            "//RunLengthEncode:ランレングス圧縮",
            "vector<pair<char,int>> RLE(string &S){",
            "",
            "    vector<pair<char,int>> ret;",
            "    for (auto a:S){",
            "        if (ret.size()>0&&ret.back().first==a)ret.back().second++;",
            "        else ret.emplace_back(a,1);",
            "    }",
            "",
            "    return ret;",
            "",
            "}",
        ],
        "description": "ランレングス圧縮"
    },

    "Manacher": {
        "prefix": "Manacher",
        "body": [
            "// Manacher:文字列のインデックスに対して回文となっている範囲の半径を返す",
            "// 奇数長のみだがダミー文字を挟むことで偶数長にも対応できる",
            "vector<int> Manacher(string &S){",
            "",
            "    int N=size(S);",
            "    vector<int> ret(N,0);",
            "",
            "    int k=1;",
            "    for (int i=0,j=0;i<N;i+=k,j-=k){",
            "",
            "        while (i-j>=0&&i+j<N&&S[i-j]==S[i+j])j++;",
            "        ret[i]=j;",
            "",
            "        k=1;",
            "        for (;i>=k&&k+ret[i-k]<j;k++) ret[i+k]=ret[i-k];",
            "    }",
            "",
            "",
            "    return ret;",
            "}",
            "",
        ],
        "description": "Manacher"
    },


    "編集距離": {
        "prefix": "edit_dist",
        "body": [
            "int edit_dist(string S,string T){",
            "    int sl=size(S),tl=size(T);",
            "",
            "    int DP[sl+1][tl+1];",
            "    rep(i,sl+1)rep(j,tl+1){",
            "        if (i==0) DP[0][j]=j;",
            "        else if (j==0) DP[i][0]=i;",
            "        else DP[i][j]=INF;",
            "    }",
            "    rep(i,sl)rep(j,tl){",
            "        DP[i+1][j+1]=min(DP[i][j+1]+1,DP[i+1][j]+1);",
            "        DP[i+1][j+1]=min(DP[i+1][j+1],DP[i][j]+(S[i]==T[j]?0:1));",
            "    }",
            "",
            "    return DP[sl][tl];",
            "}",
            "",
        ],
        "description": "レーベンシュタイン距離、編集距離"
    },

    "K文字以下の編集距離": {
        "prefix": "edit_dist",
        "body": [
            "// 文字列S,Tの編集距離がK以下の場合の編集距離を求める",
            "int edit_dist(string &S,string &T,int &K){",
            "    int sl=size(S),tl=size(T);",
            "",
            "    // 文字数差がK以上ならINF",
            "    if (abs(sl-tl)>K) return INF;",
            "",
            "    vector<vector<int>> DP(sl+1,vector<int>(2*K+1,INF));",
            "",
            "    rep(j,K+1){",
            "        DP[0][K+j]=j;",
            "        DP[0][K-j]=j;",
            "    }",
            "    ",
            "    rep(i,sl+1)rep(j,2*K+1){",
            "",
            "        // 右",
            "        if (j<2*K)DP[i][j+1]=min(DP[i][j+1],DP[i][j]+1);",
            "",
            "        // 下",
            "        if (0<j&&i<sl)DP[i+1][j-1]=min(DP[i+1][j-1],DP[i][j]+1);",
            "",
            "        // 右下",
            "        int jpos=i-K+j;",
            "        if (!(0<=jpos&&jpos<tl)||i==sl)continue;",
            "",
            "        DP[i+1][j]=min(DP[i+1][j],DP[i][j]+(S[i]==T[jpos]?0:1));",
            "    }",
            "",
            "    return DP[sl][K+tl-sl];",
            "}",
        ],
        "description": "K文字以下の編集距離を求める"
    },

    "ACLを使ったRollingHash": {
        "prefix": "struct RollingHash",
        "body": [
            "// atcoderのmodintライブラリを使ったRollingHash",
            "// HMODが公式ドキュメントの範囲外だが多分動いてるっぽい",
            "",
            "// このrepはmainの先頭にでもコピペする",
            "rep(i,HASH_MAX_SIZE){",
            "    pow1[i+1]=pow1[i]*hbase1;",
            "    pow2[i+1]=pow2[i]*hbase2;",
            "}",
            "// ",
            "",
            "constexpr int HMOD=INT_MAX;",
            "constexpr int HASH_MAX_SIZE=1000005;",
            "using mint = static_modint<HMOD>;",
            "random_device rd;",
            "mt19937 mt(rd());",
            "uniform_int_distribution<int> rand0N(0,HMOD-1);",
            "",
            "mint hbase1=rand0N(mt);",
            "mint hbase2=rand0N(mt);",
            "",
            "vector<mint>pow1(HASH_MAX_SIZE,1),pow2(HASH_MAX_SIZE,1);",
            "",
            "struct RollingHash{",
            "    ",
            "    int sl;",
            "    vector<mint>hash1,hash2;",
            "",
            "    RollingHash (string &S){",
            "        sl=size(S);",
            "",
            "        hash1.resize(sl+1,0);",
            "        hash2.resize(sl+1,0);",
            "",
            "        rep(i,sl){",
            "            hash1[i+1]=hash1[i]*hbase1+mint(S[i]);",
            "            hash2[i+1]=hash2[i]*hbase2+mint(S[i]);",
            "        }",
            "",
            "    }",
            "",
            "    // [l,r]のハッシュ値を返す",
            "    i64 hashval(int l,int r){",
            "        mint ret1=hash1[r]-hash1[l]*pow1[r-l];",
            "        mint ret2=hash2[r]-hash2[l]*pow2[r-l];",
            "",
            "        i64 ret=ret1.val();",
            "        ret<<=32;",
            "        ret|=ret2.val();",
            "        return ret;",
            "    }",
            "",
            "    // [i1,j1]の後ろにotherの[i2,j2]を結合したハッシュ値を返す",
            "    i64 concat(int i1,int j1,RollingHash &other,int i2,int j2){",
            "        i64 pre=hashval(i1,j1);",
            "        mint pre1=pre>>32;",
            "        mint pre2=pre&HMOD;",
            "",
            "        pre1*=pow1[j2-i2];",
            "        pre2*=pow2[j2-i2];",
            "",
            "        i64 pos=other.hashval(i2,j2);",
            "        mint pos1=pos>>32;",
            "        mint pos2=pos&HMOD;",
            "",
            "        pre1+=pos1;",
            "        pre2+=pos2;",
            "",
            "        i64 ret=pre1.val();",
            "        ret<<=32;",
            "        ret|=pre2.val();",
            "",
            "        return ret;",
            "",
            "    }",
            "",
            "};",
        ],
        "description": "ACLを使ったRollingHash"
    },


    "二次元累積和": {
        "prefix": "sum2D",
        "body": [
            "// 二次元累積和",
            "template <typename T>",
            "struct sum2D{",
            "",
            "    vector<vector<T>> S;",
            "    int H,W;",
            "",
            "    // 二次元配列から累積和を作る",
            "    sum2D(vector<vector<T>> &A){",
            "        H=size(A);",
            "        W=size(A[0]);",
            "        S.resize(H+1,vector<T>(W+1));",
            "",
            "        rep(i,H)rep(j,W) S[i+1][j+1]=A[i][j]+S[i][j+1]+S[i+1][j]-S[i][j];",
            "    }",
            "",
            "    T get(int si,int sj,int ti,int tj) {return S[ti+1][tj+1]-S[si][tj+1]-S[ti+1][sj]+S[si][sj];}",
            "",
            "};",
            "",
        ],
        "description": "二次元累積和"
    },
    "二次元imos法": {
        "prefix": "imos2D",
        "body": [
            "// 二次元imos",
            "template <typename T>",
            "struct imos2D{",
            "",
            "    vector<vector<T>> S;",
            "    int H,W;",
            "",
            "    // 二次元配列から累積和を作る",
            "    imos2D(int h,int w){",
            "        H=h;",
            "        W=w;",
            "        S.resize(H+2,vector<T>(W+2));",
            "    }",
            "",
            "    // (si,sj)(ti,tj)の範囲の値をv増加させる",
            "    void add(int si,int sj,int ti,int tj,int v){",
            "        S[si][sj]+=v;",
            "        S[si][tj+1]-=v;",
            "        S[ti+1][sj]-=v;",
            "        S[ti+1][tj+1]+=v;",
            "    }",
            "",
            "    // 累積する",
            "    void sum() {",
            "        // 横方向",
            "        rep(i,H+1)rep(j,W)S[i][j+1]+=S[i][j];",
            "        ",
            "        // 縦方向",
            "        rep(i,H)rep(j,W+1)S[i+1][j]+=S[i][j];",
            "        ",
            "    }",
            "",
            "};",
            "",
        ],
        "description": "二次元imos法"
    },

    "数論変換FFT": {
        "prefix": "struct NTT",
        "body": [
            "// 数論変換を用いたFTT",
            "struct NTT{",
            "",
            "    int N,L,preN,ffs,MOD,la,lb;",
            "    i64 invN,w,r,t1,t2,temp;",
            "    vector<i64> op_order,z,invz,C,rot;",
            "    ",
            "    NTT (vector<i64> &A,vector<i64> &B,int ROOT=3,int mod=998244353){",
            "        MOD=mod;",
            "        int m1=MOD-1;",
            "        ffs=__builtin_ffs(m1);",
            "        int pw=m1>>(ffs-1);",
            "",
            "        // Cに必要な長さ",
            "        la=size(A);",
            "        lb=size(B);",
            "        preN=N=la+lb-1;",
            "        L=32-__builtin_clz(N);",
            "",
            "        // Nを2べきに合わせる",
            "        if (__builtin_popcount(N)>1)N=1<<L;",
            "        else L--;",
            "",
            "        invN=reppow(N,-1,MOD);",
            "        w=reppow(ROOT, pw, MOD);",
            "",
            "        // 類乗根を求める",
            "        z.resize(ffs+1);",
            "        z[0]=1;",
            "        z[1]=w;",
            "",
            "        repst(i,1,ffs) z[i+1]=(z[i]*z[i])%MOD;",
            "        reverse(z.begin(),z.end());",
            "",
            "",
            "        // 回転子を配列に格納しておく",
            "        r=z[L];",
            "        rot.resize((1<<L)+1);",
            "        temp=1;",
            "",
            "        rep(i,(1<<L)+1){",
            "            rot[i]=temp;",
            "            temp*=r;",
            "            temp%=MOD;",
            "        }",
            "",
            "        // ビット反転列を求める",
            "        op_order.resize(N);",
            "        rep(i,N>>1){",
            "            int temp=0;",
            "            rep(j,L) if ((i<<1)&(1<<j)) temp|=1<<(L-j-1);",
            "",
            "            op_order[i<<1]=temp;",
            "            op_order[(i<<1)|1]=temp|(N>>1);",
            "        }",
            "",
            "        // ゼロ埋め",
            "        A.resize(N);",
            "        B.resize(N);",
            "",
            "        // 周波数領域に変換",
            "        Cooley_Tukey_FFT(A);",
            "        Cooley_Tukey_FFT(B);",
            "",
            "",
            "        // 周波数領域で積を取る",
            "        C.resize(N);",
            "        rep(i,N)C[i]=(A[i]*B[i])%MOD;",
            "",
            "        // 逆変換で時間領域へ変換",
            "        Cooley_Tukey_FFT(C,true);",
            "        C.resize(preN);",
            "    }",
            "",
            "    void Cooley_Tukey_FFT(vector<i64> &sig,bool inv=false){",
            "",
            "        // バタフライ演算用の並び替え",
            "        rep(i,N){",
            "            int j=op_order[i];",
            "            if (i<j)swap(sig[i],sig[j]);",
            "        }",
            "",
            "        int g,hg,gn,p,q;",
            "",
            "        // L回バタフライ演算する",
            "        repst(l,1,L+1){",
            "",
            "            // グループ内の数",
            "            g=1<<l;",
            "            // グループ内の数の半分",
            "            hg=g>>1;",
            "            // グループの数",
            "            gn=N>>l;",
            "",
            "            rep(i,gn)rep(j,hg){",
            "                p=g*i+j;",
            "                q=p+hg;",
            "",
            "                // 回転子を掛ける",
            "                if (inv)sig[q]*=rot[(1<<L)-(j<<(L-l))];",
            "                else sig[q]*=rot[j<<(L-l)];",
            "                sig[q]%=MOD;",
            "",
            "                // バタフライ演算本体",
            "                t1=(sig[p]+sig[q])%MOD;",
            "                t2=(MOD+sig[p]-sig[q])%MOD;",
            "                sig[p]=t1;",
            "                sig[q]=t2;",
            "",
            "            }",
            "        }",
            "",
            "",
            "        if (inv)for (auto &s:sig){",
            "            s*=invN;",
            "            s%=MOD;",
            "        }",
            "    }",
            "};",
            "",
        ],
        "description": "数論変換FFT"
    },

    "二部マッチング": {
        "prefix": "Bipartile_Matching",
        "body": [
            "struct Bipartile_Matching{",
            "",
            "    int L,R;",
            "    vector<int>L2R,R2L,backpath,root;",
            "    vector<vector<int>> edge;",
            "",
            "    Bipartile_Matching(int &l,int &r):",
            "    L(l),",
            "    R(r),",
            "    L2R(l,-1),",
            "    R2L(r,-1),",
            "    backpath(l,-1),",
            "    root(l,-1),",
            "    edge(l){}",
            "",
            "    void add_edge(int s,int t){edge[s].emplace_back(t);}",
            "",
            "    int match(){",
            "        int ret=0;",
            "        bool f=true;",
            "",
            "        while (f){",
            "            f=false;",
            "            queue<int> q;",
            "",
            "            rep(i,L){",
            "                if (L2R[i]==-1){",
            "                    root[i]=i;",
            "                    q.emplace(i);",
            "                }",
            "            }",
            "",
            "            while (!q.empty()){",
            "                int s=q.front();",
            "                q.pop();",
            "",
            "                if (~L2R[root[s]])continue;",
            "",
            "                for (auto t:edge[s]){",
            "                    if (R2L[t]==-1){",
            "                        while (~t){",
            "                            R2L[t]=s;",
            "                            swap(L2R[s],t);",
            "                            s=backpath[s];",
            "                        }",
            "                        f=true;",
            "                        ret++;",
            "                        break;",
            "                    }",
            "",
            "                    int temps=R2L[t];",
            "                    if (~backpath[temps]) continue;",
            "",
            "                    backpath[temps]=s;",
            "                    root[temps]=root[s];",
            "                    q.emplace(temps);",
            "",
            "                }",
            "            }",
            "",
            "            if (f){",
            "                rep(i,L){",
            "                    backpath[i]=-1;",
            "                    root[i]=-1;",
            "                }",
            "            }",
            "",
            "        }",
            "",
            "        return ret;",
            "    }",
            "",
            "};",
        ],
        "description": "二部マッチング"
    },

    "AVR": {
        "prefix": "AVR",
        "body": [
            "#define F_CPU 8000000UL",
            "",
            "#include <avr/io.h>",
            "#include <util/delay.h>",
            "#include <avr/interrupt.h>",
            "#define rep(i,n) for (int i = 0; i < int(n); i++)",
            "",
            "",
            "int main(void){",
            "",
            "",
            "    cli();",
            "    // 初期化ルーチン",
            "",
            "",
            "    sei();",
            "    ",
            "",
            "    _delay_ms(1000);",
            "",
            "",
            "    // メインルーチン",
            "    while(1){",
            "",
            "    }",
            "}",
        ],
        "description": "AVRマイコン基本形"
    },


}
